/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./node_modules/mocha-loader/index.js!./test/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-loader/lib/index.js!./test/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/babel-loader/lib!./test/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "./node_modules/mocha-loader/index.js!./test/index.js":
/*!***************************************************!*\
  !*** ./node_modules/mocha-loader!./test/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/mocha-loader/web.js */ "./node_modules/mocha-loader/web.js");
if(typeof window !== 'undefined' && window.initMochaPhantomJS) { window.initMochaPhantomJS(); }
mocha.setup({"ui":"bdd"});
__webpack_require__(/*! !./node_modules/babel-loader/lib!./test/index.js */ "./node_modules/babel-loader/lib/index.js!./test/index.js")
__webpack_require__(/*! !./node_modules/mocha-loader/start.js */ "./node_modules/mocha-loader/start.js");
if(false) {}

/***/ }),

/***/ "./node_modules/mocha-loader/node_modules/css-loader/index.js!./node_modules/mocha/mocha.css":
/*!******************************************************************************************!*\
  !*** ./node_modules/mocha-loader/node_modules/css-loader!./node_modules/mocha/mocha.css ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../mocha-loader/node_modules/css-loader/lib/css-base.js */ "./node_modules/mocha-loader/node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "@charset \"utf-8\";\n\nbody {\n  margin:0;\n}\n\n#mocha {\n  font: 20px/1.5 \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  margin: 60px 50px;\n}\n\n#mocha ul,\n#mocha li {\n  margin: 0;\n  padding: 0;\n}\n\n#mocha ul {\n  list-style: none;\n}\n\n#mocha h1,\n#mocha h2 {\n  margin: 0;\n}\n\n#mocha h1 {\n  margin-top: 15px;\n  font-size: 1em;\n  font-weight: 200;\n}\n\n#mocha h1 a {\n  text-decoration: none;\n  color: inherit;\n}\n\n#mocha h1 a:hover {\n  text-decoration: underline;\n}\n\n#mocha .suite .suite h1 {\n  margin-top: 0;\n  font-size: .8em;\n}\n\n#mocha .hidden {\n  display: none;\n}\n\n#mocha h2 {\n  font-size: 12px;\n  font-weight: normal;\n  cursor: pointer;\n}\n\n#mocha .suite {\n  margin-left: 15px;\n}\n\n#mocha .test {\n  margin-left: 15px;\n  overflow: hidden;\n}\n\n#mocha .test.pending:hover h2::after {\n  content: '(pending)';\n  font-family: arial, sans-serif;\n}\n\n#mocha .test.pass.medium .duration {\n  background: #c09853;\n}\n\n#mocha .test.pass.slow .duration {\n  background: #b94a48;\n}\n\n#mocha .test.pass::before {\n  content: '\\2713';\n  font-size: 12px;\n  display: block;\n  float: left;\n  margin-right: 5px;\n  color: #00d6b2;\n}\n\n#mocha .test.pass .duration {\n  font-size: 9px;\n  margin-left: 5px;\n  padding: 2px 5px;\n  color: #fff;\n  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  -moz-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  -webkit-border-radius: 5px;\n  -moz-border-radius: 5px;\n  -ms-border-radius: 5px;\n  -o-border-radius: 5px;\n  border-radius: 5px;\n}\n\n#mocha .test.pass.fast .duration {\n  display: none;\n}\n\n#mocha .test.pending {\n  color: #0b97c4;\n}\n\n#mocha .test.pending::before {\n  content: '\\25E6';\n  color: #0b97c4;\n}\n\n#mocha .test.fail {\n  color: #c00;\n}\n\n#mocha .test.fail pre {\n  color: black;\n}\n\n#mocha .test.fail::before {\n  content: '\\2716';\n  font-size: 12px;\n  display: block;\n  float: left;\n  margin-right: 5px;\n  color: #c00;\n}\n\n#mocha .test pre.error {\n  color: #c00;\n  max-height: 300px;\n  overflow: auto;\n}\n\n#mocha .test .html-error {\n  overflow: auto;\n  color: black;\n  line-height: 1.5;\n  display: block;\n  float: left;\n  clear: left;\n  font: 12px/1.5 monaco, monospace;\n  margin: 5px;\n  padding: 15px;\n  border: 1px solid #eee;\n  max-width: 85%; /*(1)*/\n  max-width: -webkit-calc(100% - 42px);\n  max-width: -moz-calc(100% - 42px);\n  max-width: calc(100% - 42px); /*(2)*/\n  max-height: 300px;\n  word-wrap: break-word;\n  border-bottom-color: #ddd;\n  -webkit-box-shadow: 0 1px 3px #eee;\n  -moz-box-shadow: 0 1px 3px #eee;\n  box-shadow: 0 1px 3px #eee;\n  -webkit-border-radius: 3px;\n  -moz-border-radius: 3px;\n  border-radius: 3px;\n}\n\n#mocha .test .html-error pre.error {\n  border: none;\n  -webkit-border-radius: 0;\n  -moz-border-radius: 0;\n  border-radius: 0;\n  -webkit-box-shadow: 0;\n  -moz-box-shadow: 0;\n  box-shadow: 0;\n  padding: 0;\n  margin: 0;\n  margin-top: 18px;\n  max-height: none;\n}\n\n/**\n * (1): approximate for browsers not supporting calc\n * (2): 42 = 2*15 + 2*10 + 2*1 (padding + margin + border)\n *      ^^ seriously\n */\n#mocha .test pre {\n  display: block;\n  float: left;\n  clear: left;\n  font: 12px/1.5 monaco, monospace;\n  margin: 5px;\n  padding: 15px;\n  border: 1px solid #eee;\n  max-width: 85%; /*(1)*/\n  max-width: -webkit-calc(100% - 42px);\n  max-width: -moz-calc(100% - 42px);\n  max-width: calc(100% - 42px); /*(2)*/\n  word-wrap: break-word;\n  border-bottom-color: #ddd;\n  -webkit-box-shadow: 0 1px 3px #eee;\n  -moz-box-shadow: 0 1px 3px #eee;\n  box-shadow: 0 1px 3px #eee;\n  -webkit-border-radius: 3px;\n  -moz-border-radius: 3px;\n  border-radius: 3px;\n}\n\n#mocha .test h2 {\n  position: relative;\n}\n\n#mocha .test a.replay {\n  position: absolute;\n  top: 3px;\n  right: 0;\n  text-decoration: none;\n  vertical-align: middle;\n  display: block;\n  width: 15px;\n  height: 15px;\n  line-height: 15px;\n  text-align: center;\n  background: #eee;\n  font-size: 15px;\n  -webkit-border-radius: 15px;\n  -moz-border-radius: 15px;\n  border-radius: 15px;\n  -webkit-transition:opacity 200ms;\n  -moz-transition:opacity 200ms;\n  -o-transition:opacity 200ms;\n  transition: opacity 200ms;\n  opacity: 0.3;\n  color: #888;\n}\n\n#mocha .test:hover a.replay {\n  opacity: 1;\n}\n\n#mocha-report.pass .test.fail {\n  display: none;\n}\n\n#mocha-report.fail .test.pass {\n  display: none;\n}\n\n#mocha-report.pending .test.pass,\n#mocha-report.pending .test.fail {\n  display: none;\n}\n#mocha-report.pending .test.pass.pending {\n  display: block;\n}\n\n#mocha-error {\n  color: #c00;\n  font-size: 1.5em;\n  font-weight: 100;\n  letter-spacing: 1px;\n}\n\n#mocha-stats {\n  position: fixed;\n  top: 15px;\n  right: 10px;\n  font-size: 12px;\n  margin: 0;\n  color: #888;\n  z-index: 1;\n}\n\n#mocha-stats .progress {\n  float: right;\n  padding-top: 0;\n\n  /**\n   * Set safe initial values, so mochas .progress does not inherit these\n   * properties from Bootstrap .progress (which causes .progress height to\n   * equal line height set in Bootstrap).\n   */\n  height: auto;\n  -webkit-box-shadow: none;\n  -moz-box-shadow: none;\n  box-shadow: none;\n  background-color: initial;\n}\n\n#mocha-stats em {\n  color: black;\n}\n\n#mocha-stats a {\n  text-decoration: none;\n  color: inherit;\n}\n\n#mocha-stats a:hover {\n  border-bottom: 1px solid #eee;\n}\n\n#mocha-stats li {\n  display: inline-block;\n  margin: 0 5px;\n  list-style: none;\n  padding-top: 11px;\n}\n\n#mocha-stats canvas {\n  width: 40px;\n  height: 40px;\n}\n\n#mocha code .comment { color: #ddd; }\n#mocha code .init { color: #2f6fad; }\n#mocha code .string { color: #5890ad; }\n#mocha code .keyword { color: #8a6343; }\n#mocha code .number { color: #2f6fad; }\n\n@media screen and (max-device-width: 480px) {\n  #mocha {\n    margin: 60px 0px;\n  }\n\n  #mocha #stats {\n    position: absolute;\n  }\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/mocha-loader/node_modules/css-loader/lib/css-base.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mocha-loader/node_modules/css-loader/lib/css-base.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/mocha-loader/node_modules/style-loader/index.js!./node_modules/mocha-loader/node_modules/css-loader/index.js!./node_modules/mocha/mocha.css":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/mocha-loader/node_modules/style-loader!./node_modules/mocha-loader/node_modules/css-loader!./node_modules/mocha/mocha.css ***!
  \************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../mocha-loader/node_modules/css-loader!./mocha.css */ "./node_modules/mocha-loader/node_modules/css-loader/index.js!./node_modules/mocha/mocha.css");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(/*! ../mocha-loader/node_modules/style-loader/lib/addStyles.js */ "./node_modules/mocha-loader/node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "./node_modules/mocha-loader/node_modules/style-loader/lib/addStyles.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mocha-loader/node_modules/style-loader/lib/addStyles.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			var styleTarget = fn.call(this, selector);
			// Special case to return head of iframe instead of iframe itself
			if (styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[selector] = styleTarget;
		}
		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/mocha-loader/node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/mocha-loader/node_modules/style-loader/lib/urls.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mocha-loader/node_modules/style-loader/lib/urls.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./node_modules/mocha-loader/start.js":
/*!********************************************!*\
  !*** ./node_modules/mocha-loader/start.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {process.nextTick(function() {
	delete __webpack_require__.c[module.i];
	if(typeof window !== "undefined" && window.mochaPhantomJS)
		mochaPhantomJS.run();
	else
		mocha.run();
});

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/mocha-loader/web.js":
/*!******************************************!*\
  !*** ./node_modules/mocha-loader/web.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

if (! document.getElementById("mocha")) { document.write("<div id=\"mocha\"></div>"); }

__webpack_require__(/*! style-loader!css-loader!mocha/mocha.css */ "./node_modules/mocha-loader/node_modules/style-loader/index.js!./node_modules/mocha-loader/node_modules/css-loader/index.js!./node_modules/mocha/mocha.css");
__webpack_require__(/*! script-loader!mocha/mocha.js */ "./node_modules/script-loader/index.js!./node_modules/mocha/mocha.js");


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/mocha/mocha.js":
/*!***************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/mocha/mocha.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (process,global){\n'use strict';\n\n/* eslint no-unused-vars: off */\n/* eslint-env commonjs */\n\n/**\n * Shim process.stdout.\n */\n\nprocess.stdout = require('browser-stdout')({level: false});\n\nvar Mocha = require('./lib/mocha');\n\n/**\n * Create a Mocha instance.\n *\n * @return {undefined}\n */\n\nvar mocha = new Mocha({ reporter: 'html' });\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n\nvar uncaughtExceptionHandlers = [];\n\nvar originalOnerrorHandler = global.onerror;\n\n/**\n * Remove uncaughtException listener.\n * Revert to original onerror handler if previously defined.\n */\n\nprocess.removeListener = function (e, fn) {\n  if (e === 'uncaughtException') {\n    if (originalOnerrorHandler) {\n      global.onerror = originalOnerrorHandler;\n    } else {\n      global.onerror = function () {};\n    }\n    var i = uncaughtExceptionHandlers.indexOf(fn);\n    if (i !== -1) {\n      uncaughtExceptionHandlers.splice(i, 1);\n    }\n  }\n};\n\n/**\n * Implements uncaughtException listener.\n */\n\nprocess.on = function (e, fn) {\n  if (e === 'uncaughtException') {\n    global.onerror = function (err, url, line) {\n      fn(new Error(err + ' (' + url + ':' + line + ')'));\n      return !mocha.allowUncaught;\n    };\n    uncaughtExceptionHandlers.push(fn);\n  }\n};\n\n// The BDD UI is registered by default, but no UI will be functional in the\n// browser without an explicit call to the overridden `mocha.ui` (see below).\n// Ensure that this default UI does not expose its methods to the global scope.\nmocha.suite.removeAllListeners('pre-require');\n\nvar immediateQueue = [];\nvar immediateTimeout;\n\nfunction timeslice () {\n  var immediateStart = new Date().getTime();\n  while (immediateQueue.length && (new Date().getTime() - immediateStart) < 100) {\n    immediateQueue.shift()();\n  }\n  if (immediateQueue.length) {\n    immediateTimeout = setTimeout(timeslice, 0);\n  } else {\n    immediateTimeout = null;\n  }\n}\n\n/**\n * High-performance override of Runner.immediately.\n */\n\nMocha.Runner.immediately = function (callback) {\n  immediateQueue.push(callback);\n  if (!immediateTimeout) {\n    immediateTimeout = setTimeout(timeslice, 0);\n  }\n};\n\n/**\n * Function to allow assertion libraries to throw errors directly into mocha.\n * This is useful when running tests in a browser because window.onerror will\n * only receive the 'message' attribute of the Error.\n */\nmocha.throwError = function (err) {\n  uncaughtExceptionHandlers.forEach(function (fn) {\n    fn(err);\n  });\n  throw err;\n};\n\n/**\n * Override ui to ensure that the ui functions are initialized.\n * Normally this would happen in Mocha.prototype.loadFiles.\n */\n\nmocha.ui = function (ui) {\n  Mocha.prototype.ui.call(this, ui);\n  this.suite.emit('pre-require', global, null, this);\n  return this;\n};\n\n/**\n * Setup mocha with the given setting options.\n */\n\nmocha.setup = function (opts) {\n  if (typeof opts === 'string') {\n    opts = { ui: opts };\n  }\n  for (var opt in opts) {\n    if (opts.hasOwnProperty(opt)) {\n      this[opt](opts[opt]);\n    }\n  }\n  return this;\n};\n\n/**\n * Run mocha, returning the Runner.\n */\n\nmocha.run = function (fn) {\n  var options = mocha.options;\n  mocha.globals('location');\n\n  var query = Mocha.utils.parseQuery(global.location.search || '');\n  if (query.grep) {\n    mocha.grep(query.grep);\n  }\n  if (query.fgrep) {\n    mocha.fgrep(query.fgrep);\n  }\n  if (query.invert) {\n    mocha.invert();\n  }\n\n  return Mocha.prototype.run.call(mocha, function (err) {\n    // The DOM Document is not available in Web Workers.\n    var document = global.document;\n    if (document && document.getElementById('mocha') && options.noHighlighting !== true) {\n      Mocha.utils.highlightTags('code');\n    }\n    if (fn) {\n      fn(err);\n    }\n  });\n};\n\n/**\n * Expose the process shim.\n * https://github.com/mochajs/mocha/pull/916\n */\n\nMocha.process = process;\n\n/**\n * Expose mocha.\n */\n\nglobal.Mocha = Mocha;\nglobal.mocha = mocha;\n\n// this allows test/acceptance/required-tokens.js to pass; thus,\n// you can now do `const describe = require('mocha').describe` in a\n// browser context (assuming browserification).  should fix #880\nmodule.exports = global;\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./lib/mocha\":13,\"_process\":56,\"browser-stdout\":39}],2:[function(require,module,exports){\n'use strict';\n\n// just stub out growl\n\nmodule.exports = require('../utils').noop;\n\n},{\"../utils\":36}],3:[function(require,module,exports){\n'use strict';\n\n/**\n * Expose `Progress`.\n */\n\nmodule.exports = Progress;\n\n/**\n * Initialize a new `Progress` indicator.\n */\nfunction Progress () {\n  this.percent = 0;\n  this.size(0);\n  this.fontSize(11);\n  this.font('helvetica, arial, sans-serif');\n}\n\n/**\n * Set progress size to `size`.\n *\n * @api public\n * @param {number} size\n * @return {Progress} Progress instance.\n */\nProgress.prototype.size = function (size) {\n  this._size = size;\n  return this;\n};\n\n/**\n * Set text to `text`.\n *\n * @api public\n * @param {string} text\n * @return {Progress} Progress instance.\n */\nProgress.prototype.text = function (text) {\n  this._text = text;\n  return this;\n};\n\n/**\n * Set font size to `size`.\n *\n * @api public\n * @param {number} size\n * @return {Progress} Progress instance.\n */\nProgress.prototype.fontSize = function (size) {\n  this._fontSize = size;\n  return this;\n};\n\n/**\n * Set font to `family`.\n *\n * @param {string} family\n * @return {Progress} Progress instance.\n */\nProgress.prototype.font = function (family) {\n  this._font = family;\n  return this;\n};\n\n/**\n * Update percentage to `n`.\n *\n * @param {number} n\n * @return {Progress} Progress instance.\n */\nProgress.prototype.update = function (n) {\n  this.percent = n;\n  return this;\n};\n\n/**\n * Draw on `ctx`.\n *\n * @param {CanvasRenderingContext2d} ctx\n * @return {Progress} Progress instance.\n */\nProgress.prototype.draw = function (ctx) {\n  try {\n    var percent = Math.min(this.percent, 100);\n    var size = this._size;\n    var half = size / 2;\n    var x = half;\n    var y = half;\n    var rad = half - 1;\n    var fontSize = this._fontSize;\n\n    ctx.font = fontSize + 'px ' + this._font;\n\n    var angle = Math.PI * 2 * (percent / 100);\n    ctx.clearRect(0, 0, size, size);\n\n    // outer circle\n    ctx.strokeStyle = '#9f9f9f';\n    ctx.beginPath();\n    ctx.arc(x, y, rad, 0, angle, false);\n    ctx.stroke();\n\n    // inner circle\n    ctx.strokeStyle = '#eee';\n    ctx.beginPath();\n    ctx.arc(x, y, rad - 1, 0, angle, true);\n    ctx.stroke();\n\n    // text\n    var text = this._text || (percent | 0) + '%';\n    var w = ctx.measureText(text).width;\n\n    ctx.fillText(text, x - w / 2 + 1, y + fontSize / 2 - 1);\n  } catch (err) {\n    // don't fail if we can't render progress\n  }\n  return this;\n};\n\n},{}],4:[function(require,module,exports){\n(function (global){\n'use strict';\n\nexports.isatty = function isatty () {\n  return true;\n};\n\nexports.getWindowSize = function getWindowSize () {\n  if ('innerHeight' in global) {\n    return [global.innerHeight, global.innerWidth];\n  }\n  // In a Web Worker, the DOM Window is not available.\n  return [640, 480];\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],5:[function(require,module,exports){\n'use strict';\n/**\n * @module Context\n */\n/**\n * Expose `Context`.\n */\n\nmodule.exports = Context;\n\n/**\n * Initialize a new `Context`.\n *\n * @api private\n */\nfunction Context () {}\n\n/**\n * Set or get the context `Runnable` to `runnable`.\n *\n * @api private\n * @param {Runnable} runnable\n * @return {Context} context\n */\nContext.prototype.runnable = function (runnable) {\n  if (!arguments.length) {\n    return this._runnable;\n  }\n  this.test = this._runnable = runnable;\n  return this;\n};\n\n/**\n * Set or get test timeout `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {Context} self\n */\nContext.prototype.timeout = function (ms) {\n  if (!arguments.length) {\n    return this.runnable().timeout();\n  }\n  this.runnable().timeout(ms);\n  return this;\n};\n\n/**\n * Set test timeout `enabled`.\n *\n * @api private\n * @param {boolean} enabled\n * @return {Context} self\n */\nContext.prototype.enableTimeouts = function (enabled) {\n  if (!arguments.length) {\n    return this.runnable().enableTimeouts();\n  }\n  this.runnable().enableTimeouts(enabled);\n  return this;\n};\n\n/**\n * Set or get test slowness threshold `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {Context} self\n */\nContext.prototype.slow = function (ms) {\n  if (!arguments.length) {\n    return this.runnable().slow();\n  }\n  this.runnable().slow(ms);\n  return this;\n};\n\n/**\n * Mark a test as skipped.\n *\n * @api private\n * @throws Pending\n */\nContext.prototype.skip = function () {\n  this.runnable().skip();\n};\n\n/**\n * Set or get a number of allowed retries on failed tests\n *\n * @api private\n * @param {number} n\n * @return {Context} self\n */\nContext.prototype.retries = function (n) {\n  if (!arguments.length) {\n    return this.runnable().retries();\n  }\n  this.runnable().retries(n);\n  return this;\n};\n\n},{}],6:[function(require,module,exports){\n'use strict';\n/**\n * @module Hook\n *\n */\n/**\n * Module dependencies.\n */\n\nvar Runnable = require('./runnable');\nvar inherits = require('./utils').inherits;\n\n/**\n * Expose `Hook`.\n */\n\nmodule.exports = Hook;\n\n/**\n * Initialize a new `Hook` with the given `title` and callback `fn`. Derived from\n * `Runnable`.\n *\n * @memberof Mocha\n * @public\n * @class\n * @param {String} title\n * @param {Function} fn\n * @api private\n */\nfunction Hook (title, fn) {\n  Runnable.call(this, title, fn);\n  this.type = 'hook';\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\ninherits(Hook, Runnable);\n\n/**\n * Get or set the test `err`.\n *\n * @memberof Mocha.Hook\n * @public\n * @param {Error} err\n * @return {Error}\n * @api public\n */\nHook.prototype.error = function (err) {\n  if (!arguments.length) {\n    err = this._error;\n    this._error = null;\n    return err;\n  }\n\n  this._error = err;\n};\n\n},{\"./runnable\":32,\"./utils\":36}],7:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Test = require('../test');\n\n/**\n * BDD-style interface:\n *\n *      describe('Array', function() {\n *        describe('#indexOf()', function() {\n *          it('should return -1 when not present', function() {\n *            // ...\n *          });\n *\n *          it('should return the index when present', function() {\n *            // ...\n *          });\n *        });\n *      });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function (context, file, mocha) {\n    var common = require('./common')(suites, context, mocha);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`\n     * and callback `fn` containing nested suites\n     * and/or tests.\n     */\n\n    context.describe = context.context = function (title, fn) {\n      return common.suite.create({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Pending describe.\n     */\n\n    context.xdescribe = context.xcontext = context.describe.skip = function (title, fn) {\n      return common.suite.skip({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Exclusive suite.\n     */\n\n    context.describe.only = function (title, fn) {\n      return common.suite.only({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.it = context.specify = function (title, fn) {\n      var suite = suites[0];\n      if (suite.isPending()) {\n        fn = null;\n      }\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.it.only = function (title, fn) {\n      return common.test.only(mocha, context.it(title, fn));\n    };\n\n    /**\n     * Pending test case.\n     */\n\n    context.xit = context.xspecify = context.it.skip = function (title) {\n      return context.it(title);\n    };\n\n    /**\n     * Number of attempts to retry.\n     */\n    context.it.retries = function (n) {\n      context.retries(n);\n    };\n  });\n};\n\n},{\"../test\":35,\"./common\":8}],8:[function(require,module,exports){\n'use strict';\n\nvar Suite = require('../suite');\n\n/**\n * Functions common to more than one interface.\n *\n * @param {Suite[]} suites\n * @param {Context} context\n * @param {Mocha} mocha\n * @return {Object} An object containing common functions.\n */\nmodule.exports = function (suites, context, mocha) {\n  return {\n    /**\n     * This is only present if flag --delay is passed into Mocha. It triggers\n     * root suite execution.\n     *\n     * @param {Suite} suite The root suite.\n     * @return {Function} A function which runs the root suite\n     */\n    runWithSuite: function runWithSuite (suite) {\n      return function run () {\n        suite.run();\n      };\n    },\n\n    /**\n     * Execute before running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    before: function (name, fn) {\n      suites[0].beforeAll(name, fn);\n    },\n\n    /**\n     * Execute after running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    after: function (name, fn) {\n      suites[0].afterAll(name, fn);\n    },\n\n    /**\n     * Execute before each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    beforeEach: function (name, fn) {\n      suites[0].beforeEach(name, fn);\n    },\n\n    /**\n     * Execute after each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    afterEach: function (name, fn) {\n      suites[0].afterEach(name, fn);\n    },\n\n    suite: {\n      /**\n       * Create an exclusive Suite; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      only: function only (opts) {\n        opts.isOnly = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Create a Suite, but skip it; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      skip: function skip (opts) {\n        opts.pending = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Creates a suite.\n       * @param {Object} opts Options\n       * @param {string} opts.title Title of Suite\n       * @param {Function} [opts.fn] Suite Function (not always applicable)\n       * @param {boolean} [opts.pending] Is Suite pending?\n       * @param {string} [opts.file] Filepath where this Suite resides\n       * @param {boolean} [opts.isOnly] Is Suite exclusive?\n       * @returns {Suite}\n       */\n      create: function create (opts) {\n        var suite = Suite.create(suites[0], opts.title);\n        suite.pending = Boolean(opts.pending);\n        suite.file = opts.file;\n        suites.unshift(suite);\n        if (opts.isOnly) {\n          suite.parent._onlySuites = suite.parent._onlySuites.concat(suite);\n        }\n        if (typeof opts.fn === 'function') {\n          opts.fn.call(suite);\n          suites.shift();\n        } else if (typeof opts.fn === 'undefined' && !suite.pending) {\n          throw new Error('Suite \"' + suite.fullTitle() + '\" was defined but no callback was supplied. Supply a callback or explicitly skip the suite.');\n        } else if (!opts.fn && suite.pending) {\n          suites.shift();\n        }\n\n        return suite;\n      }\n    },\n\n    test: {\n\n      /**\n       * Exclusive test-case.\n       *\n       * @param {Object} mocha\n       * @param {Function} test\n       * @returns {*}\n       */\n      only: function (mocha, test) {\n        test.parent._onlyTests = test.parent._onlyTests.concat(test);\n        return test;\n      },\n\n      /**\n       * Pending test case.\n       *\n       * @param {string} title\n       */\n      skip: function (title) {\n        context.test(title);\n      },\n\n      /**\n       * Number of retry attempts\n       *\n       * @param {number} n\n       */\n      retries: function (n) {\n        context.retries(n);\n      }\n    }\n  };\n};\n\n},{\"../suite\":34}],9:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite');\nvar Test = require('../test');\n\n/**\n * Exports-style (as Node.js module) interface:\n *\n *     exports.Array = {\n *       '#indexOf()': {\n *         'should return -1 when the value is not present': function() {\n *\n *         },\n *\n *         'should return the correct index when the value is present': function() {\n *\n *         }\n *       }\n *     };\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on('require', visit);\n\n  function visit (obj, file) {\n    var suite;\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        var fn = obj[key];\n        switch (key) {\n          case 'before':\n            suites[0].beforeAll(fn);\n            break;\n          case 'after':\n            suites[0].afterAll(fn);\n            break;\n          case 'beforeEach':\n            suites[0].beforeEach(fn);\n            break;\n          case 'afterEach':\n            suites[0].afterEach(fn);\n            break;\n          default:\n            var test = new Test(key, fn);\n            test.file = file;\n            suites[0].addTest(test);\n        }\n      } else {\n        suite = Suite.create(suites[0], key);\n        suites.unshift(suite);\n        visit(obj[key], file);\n        suites.shift();\n      }\n    }\n  }\n};\n\n},{\"../suite\":34,\"../test\":35}],10:[function(require,module,exports){\n'use strict';\n\nexports.bdd = require('./bdd');\nexports.tdd = require('./tdd');\nexports.qunit = require('./qunit');\nexports.exports = require('./exports');\n\n},{\"./bdd\":7,\"./exports\":9,\"./qunit\":11,\"./tdd\":12}],11:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Test = require('../test');\n\n/**\n * QUnit-style interface:\n *\n *     suite('Array');\n *\n *     test('#length', function() {\n *       var arr = [1,2,3];\n *       ok(arr.length == 3);\n *     });\n *\n *     test('#indexOf()', function() {\n *       var arr = [1,2,3];\n *       ok(arr.indexOf(1) == 0);\n *       ok(arr.indexOf(2) == 1);\n *       ok(arr.indexOf(3) == 2);\n *     });\n *\n *     suite('String');\n *\n *     test('#length', function() {\n *       ok('foo'.length == 3);\n *     });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function (context, file, mocha) {\n    var common = require('./common')(suites, context, mocha);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`.\n     */\n\n    context.suite = function (title) {\n      if (suites.length > 1) {\n        suites.shift();\n      }\n      return common.suite.create({\n        title: title,\n        file: file,\n        fn: false\n      });\n    };\n\n    /**\n     * Exclusive Suite.\n     */\n\n    context.suite.only = function (title) {\n      if (suites.length > 1) {\n        suites.shift();\n      }\n      return common.suite.only({\n        title: title,\n        file: file,\n        fn: false\n      });\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.test = function (title, fn) {\n      var test = new Test(title, fn);\n      test.file = file;\n      suites[0].addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function (title, fn) {\n      return common.test.only(mocha, context.test(title, fn));\n    };\n\n    context.test.skip = common.test.skip;\n    context.test.retries = common.test.retries;\n  });\n};\n\n},{\"../test\":35,\"./common\":8}],12:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Test = require('../test');\n\n/**\n * TDD-style interface:\n *\n *      suite('Array', function() {\n *        suite('#indexOf()', function() {\n *          suiteSetup(function() {\n *\n *          });\n *\n *          test('should return -1 when not present', function() {\n *\n *          });\n *\n *          test('should return the index when present', function() {\n *\n *          });\n *\n *          suiteTeardown(function() {\n *\n *          });\n *        });\n *      });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function (context, file, mocha) {\n    var common = require('./common')(suites, context, mocha);\n\n    context.setup = common.beforeEach;\n    context.teardown = common.afterEach;\n    context.suiteSetup = common.before;\n    context.suiteTeardown = common.after;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n\n    /**\n     * Describe a \"suite\" with the given `title` and callback `fn` containing\n     * nested suites and/or tests.\n     */\n    context.suite = function (title, fn) {\n      return common.suite.create({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Pending suite.\n     */\n    context.suite.skip = function (title, fn) {\n      return common.suite.skip({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n    context.suite.only = function (title, fn) {\n      return common.suite.only({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Describe a specification or test-case with the given `title` and\n     * callback `fn` acting as a thunk.\n     */\n    context.test = function (title, fn) {\n      var suite = suites[0];\n      if (suite.isPending()) {\n        fn = null;\n      }\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function (title, fn) {\n      return common.test.only(mocha, context.test(title, fn));\n    };\n\n    context.test.skip = common.test.skip;\n    context.test.retries = common.test.retries;\n  });\n};\n\n},{\"../test\":35,\"./common\":8}],13:[function(require,module,exports){\n(function (process,global,__dirname){\n'use strict';\n\n/*!\n * mocha\n * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n/**\n * @namespace Mocha\n * @module Mocha\n */\n/**\n * Module dependencies.\n */\n\nvar escapeRe = require('escape-string-regexp');\nvar path = require('path');\nvar reporters = require('./reporters');\nvar utils = require('./utils');\n\n/**\n * Expose `Mocha`.\n */\n\nexports = module.exports = Mocha;\n\n/**\n * To require local UIs and reporters when running in node.\n */\n\nif (!process.browser) {\n  var cwd = process.cwd();\n  module.paths.push(cwd, path.join(cwd, 'node_modules'));\n}\n\n/**\n * Expose internals.\n */\n\n/**\n * @public\n * @class utils\n * @memberof Mocha\n */\nexports.utils = utils;\nexports.interfaces = require('./interfaces');\n/**\n *\n * @memberof Mocha\n * @public\n */\nexports.reporters = reporters;\nexports.Runnable = require('./runnable');\nexports.Context = require('./context');\n/**\n *\n * @memberof Mocha\n */\nexports.Runner = require('./runner');\nexports.Suite = require('./suite');\nexports.Hook = require('./hook');\nexports.Test = require('./test');\n\n/**\n * Return image `name` path.\n *\n * @api private\n * @param {string} name\n * @return {string}\n */\nfunction image (name) {\n  return path.join(__dirname, '../images', name + '.png');\n}\n\n/**\n * Set up mocha with `options`.\n *\n * Options:\n *\n *   - `ui` name \"bdd\", \"tdd\", \"exports\" etc\n *   - `reporter` reporter instance, defaults to `mocha.reporters.spec`\n *   - `globals` array of accepted globals\n *   - `timeout` timeout in milliseconds\n *   - `retries` number of times to retry failed tests\n *   - `bail` bail on the first test failure\n *   - `slow` milliseconds to wait before considering a test slow\n *   - `ignoreLeaks` ignore global leaks\n *   - `fullTrace` display the full stack-trace on failing\n *   - `grep` string or regexp to filter tests with\n *\n * @public\n * @class Mocha\n * @param {Object} options\n * @api public\n */\nfunction Mocha (options) {\n  options = options || {};\n  this.files = [];\n  this.options = options;\n  if (options.grep) {\n    this.grep(new RegExp(options.grep));\n  }\n  if (options.fgrep) {\n    this.fgrep(options.fgrep);\n  }\n  this.suite = new exports.Suite('', new exports.Context());\n  this.ui(options.ui);\n  this.bail(options.bail);\n  this.reporter(options.reporter, options.reporterOptions);\n  if (typeof options.timeout !== 'undefined' && options.timeout !== null) {\n    this.timeout(options.timeout);\n  }\n  if (typeof options.retries !== 'undefined' && options.retries !== null) {\n    this.retries(options.retries);\n  }\n  this.useColors(options.useColors);\n  if (options.enableTimeouts !== null) {\n    this.enableTimeouts(options.enableTimeouts);\n  }\n  if (options.slow) {\n    this.slow(options.slow);\n  }\n}\n\n/**\n * Enable or disable bailing on the first failure.\n *\n * @public\n * @api public\n * @param {boolean} [bail]\n */\nMocha.prototype.bail = function (bail) {\n  if (!arguments.length) {\n    bail = true;\n  }\n  this.suite.bail(bail);\n  return this;\n};\n\n/**\n * Add test `file`.\n *\n * @public\n * @api public\n * @param {string} file\n */\nMocha.prototype.addFile = function (file) {\n  this.files.push(file);\n  return this;\n};\n\n/**\n * Set reporter to `reporter`, defaults to \"spec\".\n *\n * @public\n * @param {String|Function} reporter name or constructor\n * @param {Object} reporterOptions optional options\n * @api public\n * @param {string|Function} reporter name or constructor\n * @param {Object} reporterOptions optional options\n */\nMocha.prototype.reporter = function (reporter, reporterOptions) {\n  if (typeof reporter === 'function') {\n    this._reporter = reporter;\n  } else {\n    reporter = reporter || 'spec';\n    var _reporter;\n    // Try to load a built-in reporter.\n    if (reporters[reporter]) {\n      _reporter = reporters[reporter];\n    }\n    // Try to load reporters from process.cwd() and node_modules\n    if (!_reporter) {\n      try {\n        _reporter = require(reporter);\n      } catch (err) {\n        if (err.message.indexOf('Cannot find module') !== -1) {\n          // Try to load reporters from a path (absolute or relative)\n          try {\n            _reporter = require(path.resolve(process.cwd(), reporter));\n          } catch (_err) {\n            err.message.indexOf('Cannot find module') !== -1 ? console.warn('\"' + reporter + '\" reporter not found')\n              : console.warn('\"' + reporter + '\" reporter blew up with error:\\n' + err.stack);\n          }\n        } else {\n          console.warn('\"' + reporter + '\" reporter blew up with error:\\n' + err.stack);\n        }\n      }\n    }\n    if (!_reporter && reporter === 'teamcity') {\n      console.warn('The Teamcity reporter was moved to a package named ' +\n        'mocha-teamcity-reporter ' +\n        '(https://npmjs.org/package/mocha-teamcity-reporter).');\n    }\n    if (!_reporter) {\n      throw new Error('invalid reporter \"' + reporter + '\"');\n    }\n    this._reporter = _reporter;\n  }\n  this.options.reporterOptions = reporterOptions;\n  return this;\n};\n\n/**\n * Set test UI `name`, defaults to \"bdd\".\n * @public\n * @api public\n * @param {string} bdd\n */\nMocha.prototype.ui = function (name) {\n  name = name || 'bdd';\n  this._ui = exports.interfaces[name];\n  if (!this._ui) {\n    try {\n      this._ui = require(name);\n    } catch (err) {\n      throw new Error('invalid interface \"' + name + '\"');\n    }\n  }\n  this._ui = this._ui(this.suite);\n\n  this.suite.on('pre-require', function (context) {\n    exports.afterEach = context.afterEach || context.teardown;\n    exports.after = context.after || context.suiteTeardown;\n    exports.beforeEach = context.beforeEach || context.setup;\n    exports.before = context.before || context.suiteSetup;\n    exports.describe = context.describe || context.suite;\n    exports.it = context.it || context.test;\n    exports.xit = context.xit || context.test.skip;\n    exports.setup = context.setup || context.beforeEach;\n    exports.suiteSetup = context.suiteSetup || context.before;\n    exports.suiteTeardown = context.suiteTeardown || context.after;\n    exports.suite = context.suite || context.describe;\n    exports.teardown = context.teardown || context.afterEach;\n    exports.test = context.test || context.it;\n    exports.run = context.run;\n  });\n\n  return this;\n};\n\n/**\n * Load registered files.\n *\n * @api private\n */\nMocha.prototype.loadFiles = function (fn) {\n  var self = this;\n  var suite = this.suite;\n  this.files.forEach(function (file) {\n    file = path.resolve(file);\n    suite.emit('pre-require', global, file, self);\n    suite.emit('require', require(file), file, self);\n    suite.emit('post-require', global, file, self);\n  });\n  fn && fn();\n};\n\n/**\n * Enable growl support.\n *\n * @api private\n */\nMocha.prototype._growl = function (runner, reporter) {\n  var notify = require('growl');\n\n  runner.on('end', function () {\n    var stats = reporter.stats;\n    if (stats.failures) {\n      var msg = stats.failures + ' of ' + runner.total + ' tests failed';\n      notify(msg, { name: 'mocha', title: 'Failed', image: image('error') });\n    } else {\n      notify(stats.passes + ' tests passed in ' + stats.duration + 'ms', {\n        name: 'mocha',\n        title: 'Passed',\n        image: image('ok')\n      });\n    }\n  });\n};\n\n/**\n * Escape string and add it to grep as a regexp.\n *\n * @public\n * @api public\n * @param str\n * @returns {Mocha}\n */\nMocha.prototype.fgrep = function (str) {\n  return this.grep(new RegExp(escapeRe(str)));\n};\n\n/**\n * Add regexp to grep, if `re` is a string it is escaped.\n *\n * @public\n * @param {RegExp|String} re\n * @return {Mocha}\n * @api public\n * @param {RegExp|string} re\n * @return {Mocha}\n */\nMocha.prototype.grep = function (re) {\n  if (utils.isString(re)) {\n    // extract args if it's regex-like, i.e: [string, pattern, flag]\n    var arg = re.match(/^\\/(.*)\\/(g|i|)$|.*/);\n    this.options.grep = new RegExp(arg[1] || arg[0], arg[2]);\n  } else {\n    this.options.grep = re;\n  }\n  return this;\n};\n/**\n * Invert `.grep()` matches.\n *\n * @public\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.invert = function () {\n  this.options.invert = true;\n  return this;\n};\n\n/**\n * Ignore global leaks.\n *\n * @public\n * @param {Boolean} ignore\n * @return {Mocha}\n * @api public\n * @param {boolean} ignore\n * @return {Mocha}\n */\nMocha.prototype.ignoreLeaks = function (ignore) {\n  this.options.ignoreLeaks = Boolean(ignore);\n  return this;\n};\n\n/**\n * Enable global leak checking.\n *\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.checkLeaks = function () {\n  this.options.ignoreLeaks = false;\n  return this;\n};\n\n/**\n * Display long stack-trace on failing\n *\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.fullTrace = function () {\n  this.options.fullStackTrace = true;\n  return this;\n};\n\n/**\n * Enable growl support.\n *\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.growl = function () {\n  this.options.growl = true;\n  return this;\n};\n\n/**\n * Ignore `globals` array or string.\n *\n * @param {Array|String} globals\n * @return {Mocha}\n * @api public\n * @public\n * @param {Array|string} globals\n * @return {Mocha}\n */\nMocha.prototype.globals = function (globals) {\n  this.options.globals = (this.options.globals || []).concat(globals);\n  return this;\n};\n\n/**\n * Emit color output.\n *\n * @param {Boolean} colors\n * @return {Mocha}\n * @api public\n * @public\n * @param {boolean} colors\n * @return {Mocha}\n */\nMocha.prototype.useColors = function (colors) {\n  if (colors !== undefined) {\n    this.options.useColors = colors;\n  }\n  return this;\n};\n\n/**\n * Use inline diffs rather than +/-.\n *\n * @param {Boolean} inlineDiffs\n * @return {Mocha}\n * @api public\n * @public\n * @param {boolean} inlineDiffs\n * @return {Mocha}\n */\nMocha.prototype.useInlineDiffs = function (inlineDiffs) {\n  this.options.useInlineDiffs = inlineDiffs !== undefined && inlineDiffs;\n  return this;\n};\n\n/**\n * Do not show diffs at all.\n *\n * @param {Boolean} hideDiff\n * @return {Mocha}\n * @api public\n * @public\n * @param {boolean} hideDiff\n * @return {Mocha}\n */\nMocha.prototype.hideDiff = function (hideDiff) {\n  this.options.hideDiff = hideDiff !== undefined && hideDiff;\n  return this;\n};\n\n/**\n * Set the timeout in milliseconds.\n *\n * @param {Number} timeout\n * @return {Mocha}\n * @api public\n * @public\n * @param {number} timeout\n * @return {Mocha}\n */\nMocha.prototype.timeout = function (timeout) {\n  this.suite.timeout(timeout);\n  return this;\n};\n\n/**\n * Set the number of times to retry failed tests.\n *\n * @param {Number} retry times\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.retries = function (n) {\n  this.suite.retries(n);\n  return this;\n};\n\n/**\n * Set slowness threshold in milliseconds.\n *\n * @param {Number} slow\n * @return {Mocha}\n * @api public\n * @public\n * @param {number} slow\n * @return {Mocha}\n */\nMocha.prototype.slow = function (slow) {\n  this.suite.slow(slow);\n  return this;\n};\n\n/**\n * Enable timeouts.\n *\n * @param {Boolean} enabled\n * @return {Mocha}\n * @api public\n * @public\n * @param {boolean} enabled\n * @return {Mocha}\n */\nMocha.prototype.enableTimeouts = function (enabled) {\n  this.suite.enableTimeouts(arguments.length && enabled !== undefined ? enabled : true);\n  return this;\n};\n\n/**\n * Makes all tests async (accepting a callback)\n *\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.asyncOnly = function () {\n  this.options.asyncOnly = true;\n  return this;\n};\n\n/**\n * Disable syntax highlighting (in browser).\n *\n * @api public\n * @public\n */\nMocha.prototype.noHighlighting = function () {\n  this.options.noHighlighting = true;\n  return this;\n};\n\n/**\n * Enable uncaught errors to propagate (in browser).\n *\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.allowUncaught = function () {\n  this.options.allowUncaught = true;\n  return this;\n};\n\n/**\n * Delay root suite execution.\n * @returns {Mocha}\n */\nMocha.prototype.delay = function delay () {\n  this.options.delay = true;\n  return this;\n};\n\n/**\n * Tests marked only fail the suite\n * @returns {Mocha}\n */\nMocha.prototype.forbidOnly = function () {\n  this.options.forbidOnly = true;\n  return this;\n};\n\n/**\n * Pending tests and tests marked skip fail the suite\n * @returns {Mocha}\n */\nMocha.prototype.forbidPending = function () {\n  this.options.forbidPending = true;\n  return this;\n};\n\n/**\n * Run tests and invoke `fn()` when complete.\n *\n * Note that `loadFiles` relies on Node's `require` to execute\n * the test interface functions and will be subject to the\n * cache - if the files are already in the `require` cache,\n * they will effectively be skipped. Therefore, to run tests\n * multiple times or to run tests in files that are already\n * in the `require` cache, make sure to clear them from the\n * cache first in whichever manner best suits your needs.\n *\n * @api public\n * @public\n * @param {Function} fn\n * @return {Runner}\n */\nMocha.prototype.run = function (fn) {\n  if (this.files.length) {\n    this.loadFiles();\n  }\n  var suite = this.suite;\n  var options = this.options;\n  options.files = this.files;\n  var runner = new exports.Runner(suite, options.delay);\n  var reporter = new this._reporter(runner, options);\n  runner.ignoreLeaks = options.ignoreLeaks !== false;\n  runner.fullStackTrace = options.fullStackTrace;\n  runner.asyncOnly = options.asyncOnly;\n  runner.allowUncaught = options.allowUncaught;\n  runner.forbidOnly = options.forbidOnly;\n  runner.forbidPending = options.forbidPending;\n  if (options.grep) {\n    runner.grep(options.grep, options.invert);\n  }\n  if (options.globals) {\n    runner.globals(options.globals);\n  }\n  if (options.growl) {\n    this._growl(runner, reporter);\n  }\n  if (options.useColors !== undefined) {\n    exports.reporters.Base.useColors = options.useColors;\n  }\n  exports.reporters.Base.inlineDiffs = options.useInlineDiffs;\n  exports.reporters.Base.hideDiff = options.hideDiff;\n\n  function done (failures) {\n    if (reporter.done) {\n      reporter.done(failures, fn);\n    } else {\n      fn && fn(failures);\n    }\n  }\n\n  return runner.run(done);\n};\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},\"/lib\")\n},{\"./context\":5,\"./hook\":6,\"./interfaces\":10,\"./reporters\":20,\"./runnable\":32,\"./runner\":33,\"./suite\":34,\"./test\":35,\"./utils\":36,\"_process\":56,\"escape-string-regexp\":46,\"growl\":2,\"path\":40}],14:[function(require,module,exports){\n'use strict';\n/**\n * @module milliseconds\n */\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * @memberof Mocha\n * @public\n * @api public\n * @param {string|number} val\n * @return {string|number}\n */\nmodule.exports = function (val) {\n  if (typeof val === 'string') {\n    return parse(val);\n  }\n  return format(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @api private\n * @param {string} str\n * @return {number}\n */\nfunction parse (str) {\n  var match = (/^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i).exec(str);\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 's':\n      return n * s;\n    case 'ms':\n      return n;\n    default:\n      // No default case\n  }\n}\n\n/**\n * Format for `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {string}\n */\nfunction format (ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n},{}],15:[function(require,module,exports){\n'use strict';\n\n/**\n * Expose `Pending`.\n */\n\nmodule.exports = Pending;\n\n/**\n * Initialize a new `Pending` error with the given message.\n *\n * @param {string} message\n */\nfunction Pending (message) {\n  this.message = message;\n}\n\n},{}],16:[function(require,module,exports){\n(function (process,global){\n'use strict';\n/**\n * @module Base\n */\n/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar diff = require('diff');\nvar ms = require('../ms');\nvar utils = require('../utils');\nvar supportsColor = process.browser ? null : require('supports-color');\n\n/**\n * Expose `Base`.\n */\n\nexports = module.exports = Base;\n\n/**\n * Save timer references to avoid Sinon interfering.\n * See: https://github.com/mochajs/mocha/issues/237\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Check if both stdio streams are associated with a tty.\n */\n\nvar isatty = tty.isatty(1) && tty.isatty(2);\n\n/**\n * Enable coloring by default, except in the browser interface.\n */\n\nexports.useColors = !process.browser && (supportsColor || (process.env.MOCHA_COLORS !== undefined));\n\n/**\n * Inline diffs instead of +/-\n */\n\nexports.inlineDiffs = false;\n\n/**\n * Default color map.\n */\n\nexports.colors = {\n  pass: 90,\n  fail: 31,\n  'bright pass': 92,\n  'bright fail': 91,\n  'bright yellow': 93,\n  pending: 36,\n  suite: 0,\n  'error title': 0,\n  'error message': 31,\n  'error stack': 90,\n  checkmark: 32,\n  fast: 90,\n  medium: 33,\n  slow: 31,\n  green: 32,\n  light: 90,\n  'diff gutter': 90,\n  'diff added': 32,\n  'diff removed': 31\n};\n\n/**\n * Default symbol map.\n */\n\nexports.symbols = {\n  ok: '✓',\n  err: '✖',\n  dot: '․',\n  comma: ',',\n  bang: '!'\n};\n\n// With node.js on Windows: use symbols available in terminal default fonts\nif (process.platform === 'win32') {\n  exports.symbols.ok = '\\u221A';\n  exports.symbols.err = '\\u00D7';\n  exports.symbols.dot = '.';\n}\n\n/**\n * Color `str` with the given `type`,\n * allowing colors to be disabled,\n * as well as user-defined color\n * schemes.\n *\n * @param {string} type\n * @param {string} str\n * @return {string}\n * @api private\n */\nvar color = exports.color = function (type, str) {\n  if (!exports.useColors) {\n    return String(str);\n  }\n  return '\\u001b[' + exports.colors[type] + 'm' + str + '\\u001b[0m';\n};\n\n/**\n * Expose term window size, with some defaults for when stderr is not a tty.\n */\n\nexports.window = {\n  width: 75\n};\n\nif (isatty) {\n  exports.window.width = process.stdout.getWindowSize\n    ? process.stdout.getWindowSize(1)[0]\n    : tty.getWindowSize()[1];\n}\n\n/**\n * Expose some basic cursor interactions that are common among reporters.\n */\n\nexports.cursor = {\n  hide: function () {\n    isatty && process.stdout.write('\\u001b[?25l');\n  },\n\n  show: function () {\n    isatty && process.stdout.write('\\u001b[?25h');\n  },\n\n  deleteLine: function () {\n    isatty && process.stdout.write('\\u001b[2K');\n  },\n\n  beginningOfLine: function () {\n    isatty && process.stdout.write('\\u001b[0G');\n  },\n\n  CR: function () {\n    if (isatty) {\n      exports.cursor.deleteLine();\n      exports.cursor.beginningOfLine();\n    } else {\n      process.stdout.write('\\r');\n    }\n  }\n};\n\nfunction showDiff (err) {\n  return err && err.showDiff !== false && sameType(err.actual, err.expected) && err.expected !== undefined;\n}\n\nfunction stringifyDiffObjs (err) {\n  if (!utils.isString(err.actual) || !utils.isString(err.expected)) {\n    err.actual = utils.stringify(err.actual);\n    err.expected = utils.stringify(err.expected);\n  }\n}\n\n/**\n * Returns a diff between 2 strings with coloured ANSI output.\n *\n * The diff will be either inline or unified dependant on the value\n * of `Base.inlineDiff`.\n *\n * @param {string} actual\n * @param {string} expected\n * @return {string} Diff\n */\nvar generateDiff = exports.generateDiff = function (actual, expected) {\n  return exports.inlineDiffs\n    ? inlineDiff(actual, expected)\n    : unifiedDiff(actual, expected);\n};\n\n/**\n * Output the given `failures` as a list.\n *\n * @public\n * @memberof Mocha.reporters.Base\n * @variation 1\n * @param {Array} failures\n * @api public\n */\n\nexports.list = function (failures) {\n  console.log();\n  failures.forEach(function (test, i) {\n    // format\n    var fmt = color('error title', '  %s) %s:\\n') +\n      color('error message', '     %s') +\n      color('error stack', '\\n%s\\n');\n\n    // msg\n    var msg;\n    var err = test.err;\n    var message;\n    if (err.message && typeof err.message.toString === 'function') {\n      message = err.message + '';\n    } else if (typeof err.inspect === 'function') {\n      message = err.inspect() + '';\n    } else {\n      message = '';\n    }\n    var stack = err.stack || message;\n    var index = message ? stack.indexOf(message) : -1;\n\n    if (index === -1) {\n      msg = message;\n    } else {\n      index += message.length;\n      msg = stack.slice(0, index);\n      // remove msg from stack\n      stack = stack.slice(index + 1);\n    }\n\n    // uncaught\n    if (err.uncaught) {\n      msg = 'Uncaught ' + msg;\n    }\n    // explicitly show diff\n    if (!exports.hideDiff && showDiff(err)) {\n      stringifyDiffObjs(err);\n      fmt = color('error title', '  %s) %s:\\n%s') + color('error stack', '\\n%s\\n');\n      var match = message.match(/^([^:]+): expected/);\n      msg = '\\n      ' + color('error message', match ? match[1] : msg);\n\n      msg += generateDiff(err.actual, err.expected);\n    }\n\n    // indent stack trace\n    stack = stack.replace(/^/gm, '  ');\n\n    // indented test title\n    var testTitle = '';\n    test.titlePath().forEach(function (str, index) {\n      if (index !== 0) {\n        testTitle += '\\n     ';\n      }\n      for (var i = 0; i < index; i++) {\n        testTitle += '  ';\n      }\n      testTitle += str;\n    });\n\n    console.log(fmt, (i + 1), testTitle, msg, stack);\n  });\n};\n\n/**\n * Initialize a new `Base` reporter.\n *\n * All other reporters generally\n * inherit from this reporter, providing\n * stats such as test duration, number\n * of tests passed / failed etc.\n *\n * @memberof Mocha.reporters\n * @public\n * @class\n * @param {Runner} runner\n * @api public\n */\n\nfunction Base (runner) {\n  var stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 };\n  var failures = this.failures = [];\n\n  if (!runner) {\n    return;\n  }\n  this.runner = runner;\n\n  runner.stats = stats;\n\n  runner.on('start', function () {\n    stats.start = new Date();\n  });\n\n  runner.on('suite', function (suite) {\n    stats.suites = stats.suites || 0;\n    suite.root || stats.suites++;\n  });\n\n  runner.on('test end', function () {\n    stats.tests = stats.tests || 0;\n    stats.tests++;\n  });\n\n  runner.on('pass', function (test) {\n    stats.passes = stats.passes || 0;\n\n    if (test.duration > test.slow()) {\n      test.speed = 'slow';\n    } else if (test.duration > test.slow() / 2) {\n      test.speed = 'medium';\n    } else {\n      test.speed = 'fast';\n    }\n\n    stats.passes++;\n  });\n\n  runner.on('fail', function (test, err) {\n    stats.failures = stats.failures || 0;\n    stats.failures++;\n    if (showDiff(err)) {\n      stringifyDiffObjs(err);\n    }\n    test.err = err;\n    failures.push(test);\n  });\n\n  runner.once('end', function () {\n    stats.end = new Date();\n    stats.duration = stats.end - stats.start;\n  });\n\n  runner.on('pending', function () {\n    stats.pending++;\n  });\n}\n\n/**\n * Output common epilogue used by many of\n * the bundled reporters.\n *\n * @memberof Mocha.reporters.Base\n * @public\n * @api public\n */\nBase.prototype.epilogue = function () {\n  var stats = this.stats;\n  var fmt;\n\n  console.log();\n\n  // passes\n  fmt = color('bright pass', ' ') +\n    color('green', ' %d passing') +\n    color('light', ' (%s)');\n\n  console.log(fmt,\n    stats.passes || 0,\n    ms(stats.duration));\n\n  // pending\n  if (stats.pending) {\n    fmt = color('pending', ' ') +\n      color('pending', ' %d pending');\n\n    console.log(fmt, stats.pending);\n  }\n\n  // failures\n  if (stats.failures) {\n    fmt = color('fail', '  %d failing');\n\n    console.log(fmt, stats.failures);\n\n    Base.list(this.failures);\n    console.log();\n  }\n\n  console.log();\n};\n\n/**\n * Pad the given `str` to `len`.\n *\n * @api private\n * @param {string} str\n * @param {string} len\n * @return {string}\n */\nfunction pad (str, len) {\n  str = String(str);\n  return Array(len - str.length + 1).join(' ') + str;\n}\n\n/**\n * Returns an inline diff between 2 strings with coloured ANSI output.\n *\n * @api private\n * @param {String} actual\n * @param {String} expected\n * @return {string} Diff\n */\nfunction inlineDiff (actual, expected) {\n  var msg = errorDiff(actual, expected);\n\n  // linenos\n  var lines = msg.split('\\n');\n  if (lines.length > 4) {\n    var width = String(lines.length).length;\n    msg = lines.map(function (str, i) {\n      return pad(++i, width) + ' |' + ' ' + str;\n    }).join('\\n');\n  }\n\n  // legend\n  msg = '\\n' +\n    color('diff removed', 'actual') +\n    ' ' +\n    color('diff added', 'expected') +\n    '\\n\\n' +\n    msg +\n    '\\n';\n\n  // indent\n  msg = msg.replace(/^/gm, '      ');\n  return msg;\n}\n\n/**\n * Returns a unified diff between two strings with coloured ANSI output.\n *\n * @api private\n * @param {String} actual\n * @param {String} expected\n * @return {string} The diff.\n */\nfunction unifiedDiff (actual, expected) {\n  var indent = '      ';\n  function cleanUp (line) {\n    if (line[0] === '+') {\n      return indent + colorLines('diff added', line);\n    }\n    if (line[0] === '-') {\n      return indent + colorLines('diff removed', line);\n    }\n    if (line.match(/@@/)) {\n      return '--';\n    }\n    if (line.match(/\\\\ No newline/)) {\n      return null;\n    }\n    return indent + line;\n  }\n  function notBlank (line) {\n    return typeof line !== 'undefined' && line !== null;\n  }\n  var msg = diff.createPatch('string', actual, expected);\n  var lines = msg.split('\\n').splice(5);\n  return '\\n      ' +\n    colorLines('diff added', '+ expected') + ' ' +\n    colorLines('diff removed', '- actual') +\n    '\\n\\n' +\n    lines.map(cleanUp).filter(notBlank).join('\\n');\n}\n\n/**\n * Return a character diff for `err`.\n *\n * @api private\n * @param {String} actual\n * @param {String} expected\n * @return {string} the diff\n */\nfunction errorDiff (actual, expected) {\n  return diff.diffWordsWithSpace(actual, expected).map(function (str) {\n    if (str.added) {\n      return colorLines('diff added', str.value);\n    }\n    if (str.removed) {\n      return colorLines('diff removed', str.value);\n    }\n    return str.value;\n  }).join('');\n}\n\n/**\n * Color lines for `str`, using the color `name`.\n *\n * @api private\n * @param {string} name\n * @param {string} str\n * @return {string}\n */\nfunction colorLines (name, str) {\n  return str.split('\\n').map(function (str) {\n    return color(name, str);\n  }).join('\\n');\n}\n\n/**\n * Object#toString reference.\n */\nvar objToString = Object.prototype.toString;\n\n/**\n * Check that a / b have the same type.\n *\n * @api private\n * @param {Object} a\n * @param {Object} b\n * @return {boolean}\n */\nfunction sameType (a, b) {\n  return objToString.call(a) === objToString.call(b);\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../ms\":14,\"../utils\":36,\"_process\":56,\"diff\":45,\"supports-color\":40,\"tty\":4}],17:[function(require,module,exports){\n'use strict';\n/**\n * @module Doc\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\n\n/**\n * Expose `Doc`.\n */\n\nexports = module.exports = Doc;\n\n/**\n * Initialize a new `Doc` reporter.\n *\n * @class\n * @memberof Mocha.reporters\n * @extends {Base}\n * @public\n * @param {Runner} runner\n * @api public\n */\nfunction Doc (runner) {\n  Base.call(this, runner);\n\n  var indents = 2;\n\n  function indent () {\n    return Array(indents).join('  ');\n  }\n\n  runner.on('suite', function (suite) {\n    if (suite.root) {\n      return;\n    }\n    ++indents;\n    console.log('%s<section class=\"suite\">', indent());\n    ++indents;\n    console.log('%s<h1>%s</h1>', indent(), utils.escape(suite.title));\n    console.log('%s<dl>', indent());\n  });\n\n  runner.on('suite end', function (suite) {\n    if (suite.root) {\n      return;\n    }\n    console.log('%s</dl>', indent());\n    --indents;\n    console.log('%s</section>', indent());\n    --indents;\n  });\n\n  runner.on('pass', function (test) {\n    console.log('%s  <dt>%s</dt>', indent(), utils.escape(test.title));\n    var code = utils.escape(utils.clean(test.body));\n    console.log('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);\n  });\n\n  runner.on('fail', function (test, err) {\n    console.log('%s  <dt class=\"error\">%s</dt>', indent(), utils.escape(test.title));\n    var code = utils.escape(utils.clean(test.body));\n    console.log('%s  <dd class=\"error\"><pre><code>%s</code></pre></dd>', indent(), code);\n    console.log('%s  <dd class=\"error\">%s</dd>', indent(), utils.escape(err));\n  });\n}\n\n},{\"../utils\":36,\"./base\":16}],18:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Dot\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = Dot;\n\n/**\n * Initialize a new `Dot` matrix test reporter.\n *\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @public\n * @api public\n * @param {Runner} runner\n */\nfunction Dot (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * 0.75 | 0;\n  var n = -1;\n\n  runner.on('start', function () {\n    process.stdout.write('\\n');\n  });\n\n  runner.on('pending', function () {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    process.stdout.write(color('pending', Base.symbols.comma));\n  });\n\n  runner.on('pass', function (test) {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    if (test.speed === 'slow') {\n      process.stdout.write(color('bright yellow', Base.symbols.dot));\n    } else {\n      process.stdout.write(color(test.speed, Base.symbols.dot));\n    }\n  });\n\n  runner.on('fail', function () {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    process.stdout.write(color('fail', Base.symbols.bang));\n  });\n\n  runner.once('end', function () {\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Dot, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],19:[function(require,module,exports){\n(function (global){\n'use strict';\n\n/* eslint-env browser */\n/**\n * @module HTML\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\nvar Progress = require('../browser/progress');\nvar escapeRe = require('escape-string-regexp');\nvar escape = utils.escape;\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Expose `HTML`.\n */\n\nexports = module.exports = HTML;\n\n/**\n * Stats template.\n */\n\nvar statsTemplate = '<ul id=\"mocha-stats\">' +\n  '<li class=\"progress\"><canvas width=\"40\" height=\"40\"></canvas></li>' +\n  '<li class=\"passes\"><a href=\"javascript:void(0);\">passes:</a> <em>0</em></li>' +\n  '<li class=\"failures\"><a href=\"javascript:void(0);\">failures:</a> <em>0</em></li>' +\n  '<li class=\"duration\">duration: <em>0</em>s</li>' +\n  '</ul>';\n\nvar playIcon = '&#x2023;';\n\n/**\n * Initialize a new `HTML` reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction HTML (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var stats = this.stats;\n  var stat = fragment(statsTemplate);\n  var items = stat.getElementsByTagName('li');\n  var passes = items[1].getElementsByTagName('em')[0];\n  var passesLink = items[1].getElementsByTagName('a')[0];\n  var failures = items[2].getElementsByTagName('em')[0];\n  var failuresLink = items[2].getElementsByTagName('a')[0];\n  var duration = items[3].getElementsByTagName('em')[0];\n  var canvas = stat.getElementsByTagName('canvas')[0];\n  var report = fragment('<ul id=\"mocha-report\"></ul>');\n  var stack = [report];\n  var progress;\n  var ctx;\n  var root = document.getElementById('mocha');\n\n  if (canvas.getContext) {\n    var ratio = window.devicePixelRatio || 1;\n    canvas.style.width = canvas.width;\n    canvas.style.height = canvas.height;\n    canvas.width *= ratio;\n    canvas.height *= ratio;\n    ctx = canvas.getContext('2d');\n    ctx.scale(ratio, ratio);\n    progress = new Progress();\n  }\n\n  if (!root) {\n    return error('#mocha div missing, add it to your document');\n  }\n\n  // pass toggle\n  on(passesLink, 'click', function (evt) {\n    evt.preventDefault();\n    unhide();\n    var name = (/pass/).test(report.className) ? '' : ' pass';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) {\n      hideSuitesWithout('test pass');\n    }\n  });\n\n  // failure toggle\n  on(failuresLink, 'click', function (evt) {\n    evt.preventDefault();\n    unhide();\n    var name = (/fail/).test(report.className) ? '' : ' fail';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) {\n      hideSuitesWithout('test fail');\n    }\n  });\n\n  root.appendChild(stat);\n  root.appendChild(report);\n\n  if (progress) {\n    progress.size(40);\n  }\n\n  runner.on('suite', function (suite) {\n    if (suite.root) {\n      return;\n    }\n\n    // suite\n    var url = self.suiteURL(suite);\n    var el = fragment('<li class=\"suite\"><h1><a href=\"%s\">%s</a></h1></li>', url, escape(suite.title));\n\n    // container\n    stack[0].appendChild(el);\n    stack.unshift(document.createElement('ul'));\n    el.appendChild(stack[0]);\n  });\n\n  runner.on('suite end', function (suite) {\n    if (suite.root) {\n      updateStats();\n      return;\n    }\n    stack.shift();\n  });\n\n  runner.on('pass', function (test) {\n    var url = self.testURL(test);\n    var markup = '<li class=\"test pass %e\"><h2>%e<span class=\"duration\">%ems</span> ' +\n      '<a href=\"%s\" class=\"replay\">' + playIcon + '</a></h2></li>';\n    var el = fragment(markup, test.speed, test.title, test.duration, url);\n    self.addCodeToggle(el, test.body);\n    appendToStack(el);\n    updateStats();\n  });\n\n  runner.on('fail', function (test) {\n    var el = fragment('<li class=\"test fail\"><h2>%e <a href=\"%e\" class=\"replay\">' + playIcon + '</a></h2></li>',\n      test.title, self.testURL(test));\n    var stackString; // Note: Includes leading newline\n    var message = test.err.toString();\n\n    // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we\n    // check for the result of the stringifying.\n    if (message === '[object Error]') {\n      message = test.err.message;\n    }\n\n    if (test.err.stack) {\n      var indexOfMessage = test.err.stack.indexOf(test.err.message);\n      if (indexOfMessage === -1) {\n        stackString = test.err.stack;\n      } else {\n        stackString = test.err.stack.substr(test.err.message.length + indexOfMessage);\n      }\n    } else if (test.err.sourceURL && test.err.line !== undefined) {\n      // Safari doesn't give you a stack. Let's at least provide a source line.\n      stackString = '\\n(' + test.err.sourceURL + ':' + test.err.line + ')';\n    }\n\n    stackString = stackString || '';\n\n    if (test.err.htmlMessage && stackString) {\n      el.appendChild(fragment('<div class=\"html-error\">%s\\n<pre class=\"error\">%e</pre></div>',\n        test.err.htmlMessage, stackString));\n    } else if (test.err.htmlMessage) {\n      el.appendChild(fragment('<div class=\"html-error\">%s</div>', test.err.htmlMessage));\n    } else {\n      el.appendChild(fragment('<pre class=\"error\">%e%e</pre>', message, stackString));\n    }\n\n    self.addCodeToggle(el, test.body);\n    appendToStack(el);\n    updateStats();\n  });\n\n  runner.on('pending', function (test) {\n    var el = fragment('<li class=\"test pass pending\"><h2>%e</h2></li>', test.title);\n    appendToStack(el);\n    updateStats();\n  });\n\n  function appendToStack (el) {\n    // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.\n    if (stack[0]) {\n      stack[0].appendChild(el);\n    }\n  }\n\n  function updateStats () {\n    // TODO: add to stats\n    var percent = stats.tests / runner.total * 100 | 0;\n    if (progress) {\n      progress.update(percent).draw(ctx);\n    }\n\n    // update stats\n    var ms = new Date() - stats.start;\n    text(passes, stats.passes);\n    text(failures, stats.failures);\n    text(duration, (ms / 1000).toFixed(2));\n  }\n}\n\n/**\n * Makes a URL, preserving querystring (\"search\") parameters.\n *\n * @param {string} s\n * @return {string} A new URL.\n */\nfunction makeUrl (s) {\n  var search = window.location.search;\n\n  // Remove previous grep query parameter if present\n  if (search) {\n    search = search.replace(/[?&]grep=[^&\\s]*/g, '').replace(/^&/, '?');\n  }\n\n  return window.location.pathname + (search ? search + '&' : '?') + 'grep=' + encodeURIComponent(escapeRe(s));\n}\n\n/**\n * Provide suite URL.\n *\n * @param {Object} [suite]\n */\nHTML.prototype.suiteURL = function (suite) {\n  return makeUrl(suite.fullTitle());\n};\n\n/**\n * Provide test URL.\n *\n * @param {Object} [test]\n */\nHTML.prototype.testURL = function (test) {\n  return makeUrl(test.fullTitle());\n};\n\n/**\n * Adds code toggle functionality for the provided test's list element.\n *\n * @param {HTMLLIElement} el\n * @param {string} contents\n */\nHTML.prototype.addCodeToggle = function (el, contents) {\n  var h2 = el.getElementsByTagName('h2')[0];\n\n  on(h2, 'click', function () {\n    pre.style.display = pre.style.display === 'none' ? 'block' : 'none';\n  });\n\n  var pre = fragment('<pre><code>%e</code></pre>', utils.clean(contents));\n  el.appendChild(pre);\n  pre.style.display = 'none';\n};\n\n/**\n * Display error `msg`.\n *\n * @param {string} msg\n */\nfunction error (msg) {\n  document.body.appendChild(fragment('<div id=\"mocha-error\">%s</div>', msg));\n}\n\n/**\n * Return a DOM fragment from `html`.\n *\n * @param {string} html\n */\nfunction fragment (html) {\n  var args = arguments;\n  var div = document.createElement('div');\n  var i = 1;\n\n  div.innerHTML = html.replace(/%([se])/g, function (_, type) {\n    switch (type) {\n      case 's': return String(args[i++]);\n      case 'e': return escape(args[i++]);\n      // no default\n    }\n  });\n\n  return div.firstChild;\n}\n\n/**\n * Check for suites that do not have elements\n * with `classname`, and hide them.\n *\n * @param {text} classname\n */\nfunction hideSuitesWithout (classname) {\n  var suites = document.getElementsByClassName('suite');\n  for (var i = 0; i < suites.length; i++) {\n    var els = suites[i].getElementsByClassName(classname);\n    if (!els.length) {\n      suites[i].className += ' hidden';\n    }\n  }\n}\n\n/**\n * Unhide .hidden suites.\n */\nfunction unhide () {\n  var els = document.getElementsByClassName('suite hidden');\n  for (var i = 0; i < els.length; ++i) {\n    els[i].className = els[i].className.replace('suite hidden', 'suite');\n  }\n}\n\n/**\n * Set an element's text contents.\n *\n * @param {HTMLElement} el\n * @param {string} contents\n */\nfunction text (el, contents) {\n  if (el.textContent) {\n    el.textContent = contents;\n  } else {\n    el.innerText = contents;\n  }\n}\n\n/**\n * Listen on `event` with callback `fn`.\n */\nfunction on (el, event, fn) {\n  if (el.addEventListener) {\n    el.addEventListener(event, fn, false);\n  } else {\n    el.attachEvent('on' + event, fn);\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../browser/progress\":3,\"../utils\":36,\"./base\":16,\"escape-string-regexp\":46}],20:[function(require,module,exports){\n'use strict';\n\n// Alias exports to a their normalized format Mocha#reporter to prevent a need\n// for dynamic (try/catch) requires, which Browserify doesn't handle.\nexports.Base = exports.base = require('./base');\nexports.Dot = exports.dot = require('./dot');\nexports.Doc = exports.doc = require('./doc');\nexports.TAP = exports.tap = require('./tap');\nexports.JSON = exports.json = require('./json');\nexports.HTML = exports.html = require('./html');\nexports.List = exports.list = require('./list');\nexports.Min = exports.min = require('./min');\nexports.Spec = exports.spec = require('./spec');\nexports.Nyan = exports.nyan = require('./nyan');\nexports.XUnit = exports.xunit = require('./xunit');\nexports.Markdown = exports.markdown = require('./markdown');\nexports.Progress = exports.progress = require('./progress');\nexports.Landing = exports.landing = require('./landing');\nexports.JSONStream = exports['json-stream'] = require('./json-stream');\n\n},{\"./base\":16,\"./doc\":17,\"./dot\":18,\"./html\":19,\"./json\":22,\"./json-stream\":21,\"./landing\":23,\"./list\":24,\"./markdown\":25,\"./min\":26,\"./nyan\":27,\"./progress\":28,\"./spec\":29,\"./tap\":30,\"./xunit\":31}],21:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module JSONStream\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Initialize a new `JSONStream` test reporter.\n *\n * @public\n * @name JSONStream\n * @class JSONStream\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction List (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var total = runner.total;\n\n  runner.on('start', function () {\n    console.log(JSON.stringify(['start', { total: total }]));\n  });\n\n  runner.on('pass', function (test) {\n    console.log(JSON.stringify(['pass', clean(test)]));\n  });\n\n  runner.on('fail', function (test, err) {\n    test = clean(test);\n    test.err = err.message;\n    test.stack = err.stack || null;\n    console.log(JSON.stringify(['fail', test]));\n  });\n\n  runner.once('end', function () {\n    process.stdout.write(JSON.stringify(['end', self.stats]));\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @api private\n * @param {Object} test\n * @return {Object}\n */\nfunction clean (test) {\n  return {\n    title: test.title,\n    fullTitle: test.fullTitle(),\n    duration: test.duration,\n    currentRetry: test.currentRetry()\n  };\n}\n\n}).call(this,require('_process'))\n},{\"./base\":16,\"_process\":56}],22:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module JSON\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `JSON`.\n */\n\nexports = module.exports = JSONReporter;\n\n/**\n * Initialize a new `JSON` reporter.\n *\n * @public\n * @class JSON\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction JSONReporter (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var tests = [];\n  var pending = [];\n  var failures = [];\n  var passes = [];\n\n  runner.on('test end', function (test) {\n    tests.push(test);\n  });\n\n  runner.on('pass', function (test) {\n    passes.push(test);\n  });\n\n  runner.on('fail', function (test) {\n    failures.push(test);\n  });\n\n  runner.on('pending', function (test) {\n    pending.push(test);\n  });\n\n  runner.once('end', function () {\n    var obj = {\n      stats: self.stats,\n      tests: tests.map(clean),\n      pending: pending.map(clean),\n      failures: failures.map(clean),\n      passes: passes.map(clean)\n    };\n\n    runner.testResults = obj;\n\n    process.stdout.write(JSON.stringify(obj, null, 2));\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @api private\n * @param {Object} test\n * @return {Object}\n */\nfunction clean (test) {\n  var err = test.err || {};\n  if (err instanceof Error) {\n    err = errorJSON(err);\n  }\n\n  return {\n    title: test.title,\n    fullTitle: test.fullTitle(),\n    duration: test.duration,\n    currentRetry: test.currentRetry(),\n    err: cleanCycles(err)\n  };\n}\n\n/**\n * Replaces any circular references inside `obj` with '[object Object]'\n *\n * @api private\n * @param {Object} obj\n * @return {Object}\n */\nfunction cleanCycles (obj) {\n  var cache = [];\n  return JSON.parse(JSON.stringify(obj, function (key, value) {\n    if (typeof value === 'object' && value !== null) {\n      if (cache.indexOf(value) !== -1) {\n        // Instead of going in a circle, we'll print [object Object]\n        return '' + value;\n      }\n      cache.push(value);\n    }\n\n    return value;\n  }));\n}\n\n/**\n * Transform an Error object into a JSON object.\n *\n * @api private\n * @param {Error} err\n * @return {Object}\n */\nfunction errorJSON (err) {\n  var res = {};\n  Object.getOwnPropertyNames(err).forEach(function (key) {\n    res[key] = err[key];\n  }, err);\n  return res;\n}\n\n}).call(this,require('_process'))\n},{\"./base\":16,\"_process\":56}],23:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Landing\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar cursor = Base.cursor;\nvar color = Base.color;\n\n/**\n * Expose `Landing`.\n */\n\nexports = module.exports = Landing;\n\n/**\n * Airplane color.\n */\n\nBase.colors.plane = 0;\n\n/**\n * Airplane crash color.\n */\n\nBase.colors['plane crash'] = 31;\n\n/**\n * Runway color.\n */\n\nBase.colors.runway = 90;\n\n/**\n * Initialize a new `Landing` reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction Landing (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * 0.75 | 0;\n  var total = runner.total;\n  var stream = process.stdout;\n  var plane = color('plane', '✈');\n  var crashed = -1;\n  var n = 0;\n\n  function runway () {\n    var buf = Array(width).join('-');\n    return '  ' + color('runway', buf);\n  }\n\n  runner.on('start', function () {\n    stream.write('\\n\\n\\n  ');\n    cursor.hide();\n  });\n\n  runner.on('test end', function (test) {\n    // check if the plane crashed\n    var col = crashed === -1 ? width * ++n / total | 0 : crashed;\n\n    // show the crash\n    if (test.state === 'failed') {\n      plane = color('plane crash', '✈');\n      crashed = col;\n    }\n\n    // render landing strip\n    stream.write('\\u001b[' + (width + 1) + 'D\\u001b[2A');\n    stream.write(runway());\n    stream.write('\\n  ');\n    stream.write(color('runway', Array(col).join('⋅')));\n    stream.write(plane);\n    stream.write(color('runway', Array(width - col).join('⋅') + '\\n'));\n    stream.write(runway());\n    stream.write('\\u001b[0m');\n  });\n\n  runner.once('end', function () {\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Landing, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],24:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module List\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\nvar cursor = Base.cursor;\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Initialize a new `List` test reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction List (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var n = 0;\n\n  runner.on('start', function () {\n    console.log();\n  });\n\n  runner.on('test', function (test) {\n    process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));\n  });\n\n  runner.on('pending', function (test) {\n    var fmt = color('checkmark', '  -') +\n      color('pending', ' %s');\n    console.log(fmt, test.fullTitle());\n  });\n\n  runner.on('pass', function (test) {\n    var fmt = color('checkmark', '  ' + Base.symbols.ok) +\n      color('pass', ' %s: ') +\n      color(test.speed, '%dms');\n    cursor.CR();\n    console.log(fmt, test.fullTitle(), test.duration);\n  });\n\n  runner.on('fail', function (test) {\n    cursor.CR();\n    console.log(color('fail', '  %d) %s'), ++n, test.fullTitle());\n  });\n\n  runner.once('end', self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(List, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],25:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Markdown\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\n\n/**\n * Constants\n */\n\nvar SUITE_PREFIX = '$';\n\n/**\n * Expose `Markdown`.\n */\n\nexports = module.exports = Markdown;\n\n/**\n * Initialize a new `Markdown` reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction Markdown (runner) {\n  Base.call(this, runner);\n\n  var level = 0;\n  var buf = '';\n\n  function title (str) {\n    return Array(level).join('#') + ' ' + str;\n  }\n\n  function mapTOC (suite, obj) {\n    var ret = obj;\n    var key = SUITE_PREFIX + suite.title;\n\n    obj = obj[key] = obj[key] || { suite: suite };\n    suite.suites.forEach(function (suite) {\n      mapTOC(suite, obj);\n    });\n\n    return ret;\n  }\n\n  function stringifyTOC (obj, level) {\n    ++level;\n    var buf = '';\n    var link;\n    for (var key in obj) {\n      if (key === 'suite') {\n        continue;\n      }\n      if (key !== SUITE_PREFIX) {\n        link = ' - [' + key.substring(1) + ']';\n        link += '(#' + utils.slug(obj[key].suite.fullTitle()) + ')\\n';\n        buf += Array(level).join('  ') + link;\n      }\n      buf += stringifyTOC(obj[key], level);\n    }\n    return buf;\n  }\n\n  function generateTOC (suite) {\n    var obj = mapTOC(suite, {});\n    return stringifyTOC(obj, 0);\n  }\n\n  generateTOC(runner.suite);\n\n  runner.on('suite', function (suite) {\n    ++level;\n    var slug = utils.slug(suite.fullTitle());\n    buf += '<a name=\"' + slug + '\"></a>' + '\\n';\n    buf += title(suite.title) + '\\n';\n  });\n\n  runner.on('suite end', function () {\n    --level;\n  });\n\n  runner.on('pass', function (test) {\n    var code = utils.clean(test.body);\n    buf += test.title + '.\\n';\n    buf += '\\n```js\\n';\n    buf += code + '\\n';\n    buf += '```\\n\\n';\n  });\n\n  runner.once('end', function () {\n    process.stdout.write('# TOC\\n');\n    process.stdout.write(generateTOC(runner.suite));\n    process.stdout.write(buf);\n  });\n}\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],26:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Min\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\n\n/**\n * Expose `Min`.\n */\n\nexports = module.exports = Min;\n\n/**\n * Initialize a new `Min` minimal test reporter (best used with --watch).\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction Min (runner) {\n  Base.call(this, runner);\n\n  runner.on('start', function () {\n    // clear screen\n    process.stdout.write('\\u001b[2J');\n    // set cursor position\n    process.stdout.write('\\u001b[1;3H');\n  });\n\n  runner.once('end', this.epilogue.bind(this));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Min, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],27:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Nyan\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = NyanCat;\n\n/**\n * Initialize a new `Dot` matrix test reporter.\n *\n * @param {Runner} runner\n * @api public\n * @public\n * @class Nyan\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n */\n\nfunction NyanCat (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * 0.75 | 0;\n  var nyanCatWidth = this.nyanCatWidth = 11;\n\n  this.colorIndex = 0;\n  this.numberOfLines = 4;\n  this.rainbowColors = self.generateColors();\n  this.scoreboardWidth = 5;\n  this.tick = 0;\n  this.trajectories = [[], [], [], []];\n  this.trajectoryWidthMax = (width - nyanCatWidth);\n\n  runner.on('start', function () {\n    Base.cursor.hide();\n    self.draw();\n  });\n\n  runner.on('pending', function () {\n    self.draw();\n  });\n\n  runner.on('pass', function () {\n    self.draw();\n  });\n\n  runner.on('fail', function () {\n    self.draw();\n  });\n\n  runner.once('end', function () {\n    Base.cursor.show();\n    for (var i = 0; i < self.numberOfLines; i++) {\n      write('\\n');\n    }\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(NyanCat, Base);\n\n/**\n * Draw the nyan cat\n *\n * @api private\n */\n\nNyanCat.prototype.draw = function () {\n  this.appendRainbow();\n  this.drawScoreboard();\n  this.drawRainbow();\n  this.drawNyanCat();\n  this.tick = !this.tick;\n};\n\n/**\n * Draw the \"scoreboard\" showing the number\n * of passes, failures and pending tests.\n *\n * @api private\n */\n\nNyanCat.prototype.drawScoreboard = function () {\n  var stats = this.stats;\n\n  function draw (type, n) {\n    write(' ');\n    write(Base.color(type, n));\n    write('\\n');\n  }\n\n  draw('green', stats.passes);\n  draw('fail', stats.failures);\n  draw('pending', stats.pending);\n  write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Append the rainbow.\n *\n * @api private\n */\n\nNyanCat.prototype.appendRainbow = function () {\n  var segment = this.tick ? '_' : '-';\n  var rainbowified = this.rainbowify(segment);\n\n  for (var index = 0; index < this.numberOfLines; index++) {\n    var trajectory = this.trajectories[index];\n    if (trajectory.length >= this.trajectoryWidthMax) {\n      trajectory.shift();\n    }\n    trajectory.push(rainbowified);\n  }\n};\n\n/**\n * Draw the rainbow.\n *\n * @api private\n */\n\nNyanCat.prototype.drawRainbow = function () {\n  var self = this;\n\n  this.trajectories.forEach(function (line) {\n    write('\\u001b[' + self.scoreboardWidth + 'C');\n    write(line.join(''));\n    write('\\n');\n  });\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw the nyan cat\n *\n * @api private\n */\nNyanCat.prototype.drawNyanCat = function () {\n  var self = this;\n  var startWidth = this.scoreboardWidth + this.trajectories[0].length;\n  var dist = '\\u001b[' + startWidth + 'C';\n  var padding = '';\n\n  write(dist);\n  write('_,------,');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? '  ' : '   ';\n  write('_|' + padding + '/\\\\_/\\\\ ');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? '_' : '__';\n  var tail = self.tick ? '~' : '^';\n  write(tail + '|' + padding + this.face() + ' ');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? ' ' : '  ';\n  write(padding + '\"\"  \"\" ');\n  write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw nyan cat face.\n *\n * @api private\n * @return {string}\n */\n\nNyanCat.prototype.face = function () {\n  var stats = this.stats;\n  if (stats.failures) {\n    return '( x .x)';\n  } else if (stats.pending) {\n    return '( o .o)';\n  } else if (stats.passes) {\n    return '( ^ .^)';\n  }\n  return '( - .-)';\n};\n\n/**\n * Move cursor up `n`.\n *\n * @api private\n * @param {number} n\n */\n\nNyanCat.prototype.cursorUp = function (n) {\n  write('\\u001b[' + n + 'A');\n};\n\n/**\n * Move cursor down `n`.\n *\n * @api private\n * @param {number} n\n */\n\nNyanCat.prototype.cursorDown = function (n) {\n  write('\\u001b[' + n + 'B');\n};\n\n/**\n * Generate rainbow colors.\n *\n * @api private\n * @return {Array}\n */\nNyanCat.prototype.generateColors = function () {\n  var colors = [];\n\n  for (var i = 0; i < (6 * 7); i++) {\n    var pi3 = Math.floor(Math.PI / 3);\n    var n = (i * (1.0 / 6));\n    var r = Math.floor(3 * Math.sin(n) + 3);\n    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);\n    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);\n    colors.push(36 * r + 6 * g + b + 16);\n  }\n\n  return colors;\n};\n\n/**\n * Apply rainbow to the given `str`.\n *\n * @api private\n * @param {string} str\n * @return {string}\n */\nNyanCat.prototype.rainbowify = function (str) {\n  if (!Base.useColors) {\n    return str;\n  }\n  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];\n  this.colorIndex += 1;\n  return '\\u001b[38;5;' + color + 'm' + str + '\\u001b[0m';\n};\n\n/**\n * Stdout helper.\n *\n * @param {string} string A message to write to stdout.\n */\nfunction write (string) {\n  process.stdout.write(string);\n}\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],28:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Progress\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\nvar cursor = Base.cursor;\n\n/**\n * Expose `Progress`.\n */\n\nexports = module.exports = Progress;\n\n/**\n * General progress bar color.\n */\n\nBase.colors.progress = 90;\n\n/**\n * Initialize a new `Progress` bar test reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n * @param {Object} options\n */\nfunction Progress (runner, options) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * 0.50 | 0;\n  var total = runner.total;\n  var complete = 0;\n  var lastN = -1;\n\n  // default chars\n  options = options || {};\n  var reporterOptions = options.reporterOptions || {};\n\n  options.open = reporterOptions.open || '[';\n  options.complete = reporterOptions.complete || '▬';\n  options.incomplete = reporterOptions.incomplete || Base.symbols.dot;\n  options.close = reporterOptions.close || ']';\n  options.verbose = reporterOptions.verbose || false;\n\n  // tests started\n  runner.on('start', function () {\n    console.log();\n    cursor.hide();\n  });\n\n  // tests complete\n  runner.on('test end', function () {\n    complete++;\n\n    var percent = complete / total;\n    var n = width * percent | 0;\n    var i = width - n;\n\n    if (n === lastN && !options.verbose) {\n      // Don't re-render the line if it hasn't changed\n      return;\n    }\n    lastN = n;\n\n    cursor.CR();\n    process.stdout.write('\\u001b[J');\n    process.stdout.write(color('progress', '  ' + options.open));\n    process.stdout.write(Array(n).join(options.complete));\n    process.stdout.write(Array(i).join(options.incomplete));\n    process.stdout.write(color('progress', options.close));\n    if (options.verbose) {\n      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));\n    }\n  });\n\n  // tests are complete, output some stats\n  // and the failures if any\n  runner.once('end', function () {\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Progress, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],29:[function(require,module,exports){\n'use strict';\n/**\n * @module Spec\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\n\n/**\n * Expose `Spec`.\n */\n\nexports = module.exports = Spec;\n\n/**\n * Initialize a new `Spec` test reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction Spec (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var indents = 0;\n  var n = 0;\n\n  function indent () {\n    return Array(indents).join('  ');\n  }\n\n  runner.on('start', function () {\n    console.log();\n  });\n\n  runner.on('suite', function (suite) {\n    ++indents;\n    console.log(color('suite', '%s%s'), indent(), suite.title);\n  });\n\n  runner.on('suite end', function () {\n    --indents;\n    if (indents === 1) {\n      console.log();\n    }\n  });\n\n  runner.on('pending', function (test) {\n    var fmt = indent() + color('pending', '  - %s');\n    console.log(fmt, test.title);\n  });\n\n  runner.on('pass', function (test) {\n    var fmt;\n    if (test.speed === 'fast') {\n      fmt = indent() +\n        color('checkmark', '  ' + Base.symbols.ok) +\n        color('pass', ' %s');\n      console.log(fmt, test.title);\n    } else {\n      fmt = indent() +\n        color('checkmark', '  ' + Base.symbols.ok) +\n        color('pass', ' %s') +\n        color(test.speed, ' (%dms)');\n      console.log(fmt, test.title, test.duration);\n    }\n  });\n\n  runner.on('fail', function (test) {\n    console.log(indent() + color('fail', '  %d) %s'), ++n, test.title);\n  });\n\n  runner.once('end', self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Spec, Base);\n\n},{\"../utils\":36,\"./base\":16}],30:[function(require,module,exports){\n'use strict';\n/**\n * @module TAP\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `TAP`.\n */\n\nexports = module.exports = TAP;\n\n/**\n * Initialize a new `TAP` reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction TAP (runner) {\n  Base.call(this, runner);\n\n  var n = 1;\n  var passes = 0;\n  var failures = 0;\n\n  runner.on('start', function () {\n    var total = runner.grepTotal(runner.suite);\n    console.log('%d..%d', 1, total);\n  });\n\n  runner.on('test end', function () {\n    ++n;\n  });\n\n  runner.on('pending', function (test) {\n    console.log('ok %d %s # SKIP -', n, title(test));\n  });\n\n  runner.on('pass', function (test) {\n    passes++;\n    console.log('ok %d %s', n, title(test));\n  });\n\n  runner.on('fail', function (test, err) {\n    failures++;\n    console.log('not ok %d %s', n, title(test));\n    if (err.stack) {\n      console.log(err.stack.replace(/^/gm, '  '));\n    }\n  });\n\n  runner.once('end', function () {\n    console.log('# tests ' + (passes + failures));\n    console.log('# pass ' + passes);\n    console.log('# fail ' + failures);\n  });\n}\n\n/**\n * Return a TAP-safe title of `test`\n *\n * @api private\n * @param {Object} test\n * @return {String}\n */\nfunction title (test) {\n  return test.fullTitle().replace(/#/g, '');\n}\n\n},{\"./base\":16}],31:[function(require,module,exports){\n(function (process,global){\n'use strict';\n/**\n * @module XUnit\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\nvar inherits = utils.inherits;\nvar fs = require('fs');\nvar escape = utils.escape;\nvar mkdirp = require('mkdirp');\nvar path = require('path');\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Expose `XUnit`.\n */\n\nexports = module.exports = XUnit;\n\n/**\n * Initialize a new `XUnit` reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction XUnit (runner, options) {\n  Base.call(this, runner);\n\n  var stats = this.stats;\n  var tests = [];\n  var self = this;\n\n  // the name of the test suite, as it will appear in the resulting XML file\n  var suiteName;\n\n  // the default name of the test suite if none is provided\n  var DEFAULT_SUITE_NAME = 'Mocha Tests';\n\n  if (options && options.reporterOptions) {\n    if (options.reporterOptions.output) {\n      if (!fs.createWriteStream) {\n        throw new Error('file output not supported in browser');\n      }\n\n      mkdirp.sync(path.dirname(options.reporterOptions.output));\n      self.fileStream = fs.createWriteStream(options.reporterOptions.output);\n    }\n\n    // get the suite name from the reporter options (if provided)\n    suiteName = options.reporterOptions.suiteName;\n  }\n\n  // fall back to the default suite name\n  suiteName = suiteName || DEFAULT_SUITE_NAME;\n\n  runner.on('pending', function (test) {\n    tests.push(test);\n  });\n\n  runner.on('pass', function (test) {\n    tests.push(test);\n  });\n\n  runner.on('fail', function (test) {\n    tests.push(test);\n  });\n\n  runner.once('end', function () {\n    self.write(tag('testsuite', {\n      name: suiteName,\n      tests: stats.tests,\n      failures: stats.failures,\n      errors: stats.failures,\n      skipped: stats.tests - stats.failures - stats.passes,\n      timestamp: (new Date()).toUTCString(),\n      time: (stats.duration / 1000) || 0\n    }, false));\n\n    tests.forEach(function (t) {\n      self.test(t);\n    });\n\n    self.write('</testsuite>');\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(XUnit, Base);\n\n/**\n * Override done to close the stream (if it's a file).\n *\n * @param failures\n * @param {Function} fn\n */\nXUnit.prototype.done = function (failures, fn) {\n  if (this.fileStream) {\n    this.fileStream.end(function () {\n      fn(failures);\n    });\n  } else {\n    fn(failures);\n  }\n};\n\n/**\n * Write out the given line.\n *\n * @param {string} line\n */\nXUnit.prototype.write = function (line) {\n  if (this.fileStream) {\n    this.fileStream.write(line + '\\n');\n  } else if (typeof process === 'object' && process.stdout) {\n    process.stdout.write(line + '\\n');\n  } else {\n    console.log(line);\n  }\n};\n\n/**\n * Output tag for the given `test.`\n *\n * @param {Test} test\n */\nXUnit.prototype.test = function (test) {\n  var attrs = {\n    classname: test.parent.fullTitle(),\n    name: test.title,\n    time: (test.duration / 1000) || 0\n  };\n\n  if (test.state === 'failed') {\n    var err = test.err;\n    this.write(tag('testcase', attrs, false, tag('failure', {}, false, escape(err.message) + '\\n' + escape(err.stack))));\n  } else if (test.isPending()) {\n    this.write(tag('testcase', attrs, false, tag('skipped', {}, true)));\n  } else {\n    this.write(tag('testcase', attrs, true));\n  }\n};\n\n/**\n * HTML tag helper.\n *\n * @param name\n * @param attrs\n * @param close\n * @param content\n * @return {string}\n */\nfunction tag (name, attrs, close, content) {\n  var end = close ? '/>' : '>';\n  var pairs = [];\n  var tag;\n\n  for (var key in attrs) {\n    if (Object.prototype.hasOwnProperty.call(attrs, key)) {\n      pairs.push(key + '=\"' + escape(attrs[key]) + '\"');\n    }\n  }\n\n  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;\n  if (content) {\n    tag += content + '</' + name + end;\n  }\n  return tag;\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../utils\":36,\"./base\":16,\"_process\":56,\"fs\":40,\"mkdirp\":53,\"path\":40}],32:[function(require,module,exports){\n(function (global){\n'use strict';\n/**\n * @module Runnable\n */\n/**\n * Module dependencies.\n */\nvar EventEmitter = require('events').EventEmitter;\nvar Pending = require('./pending');\nvar debug = require('debug')('mocha:runnable');\nvar milliseconds = require('./ms');\nvar utils = require('./utils');\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Object#toString().\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Expose `Runnable`.\n */\n\nmodule.exports = Runnable;\n\n/**\n * Initialize a new `Runnable` with the given `title` and callback `fn`.  Derived from [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter)\n *\n * @memberof Mocha\n * @public\n * @class\n * @param {String} title\n * @param {Function} fn\n */\nfunction Runnable (title, fn) {\n  this.title = title;\n  this.fn = fn;\n  this.body = (fn || '').toString();\n  this.async = fn && fn.length;\n  this.sync = !this.async;\n  this._timeout = 2000;\n  this._slow = 75;\n  this._enableTimeouts = true;\n  this.timedOut = false;\n  this._retries = -1;\n  this._currentRetry = 0;\n  this.pending = false;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\nutils.inherits(Runnable, EventEmitter);\n\n/**\n * Set & get timeout `ms`.\n *\n * @api private\n * @param {number|string} ms\n * @return {Runnable|number} ms or Runnable instance.\n */\nRunnable.prototype.timeout = function (ms) {\n  if (!arguments.length) {\n    return this._timeout;\n  }\n  // see #1652 for reasoning\n  if (ms === 0 || ms > Math.pow(2, 31)) {\n    this._enableTimeouts = false;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._timeout = ms;\n  if (this.timer) {\n    this.resetTimeout();\n  }\n  return this;\n};\n\n/**\n * Set or get slow `ms`.\n *\n * @api private\n * @param {number|string} ms\n * @return {Runnable|number} ms or Runnable instance.\n */\nRunnable.prototype.slow = function (ms) {\n  if (!arguments.length || typeof ms === 'undefined') {\n    return this._slow;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('slow %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Set and get whether timeout is `enabled`.\n *\n * @api private\n * @param {boolean} enabled\n * @return {Runnable|boolean} enabled or Runnable instance.\n */\nRunnable.prototype.enableTimeouts = function (enabled) {\n  if (!arguments.length) {\n    return this._enableTimeouts;\n  }\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Halt and mark as pending.\n *\n * @memberof Mocha.Runnable\n * @public\n * @api public\n */\nRunnable.prototype.skip = function () {\n  throw new Pending('sync skip');\n};\n\n/**\n * Check if this runnable or its parent suite is marked as pending.\n *\n * @api private\n */\nRunnable.prototype.isPending = function () {\n  return this.pending || (this.parent && this.parent.isPending());\n};\n\n/**\n * Return `true` if this Runnable has failed.\n * @return {boolean}\n * @private\n */\nRunnable.prototype.isFailed = function () {\n  return !this.isPending() && this.state === 'failed';\n};\n\n/**\n * Return `true` if this Runnable has passed.\n * @return {boolean}\n * @private\n */\nRunnable.prototype.isPassed = function () {\n  return !this.isPending() && this.state === 'passed';\n};\n\n/**\n * Set or get number of retries.\n *\n * @api private\n */\nRunnable.prototype.retries = function (n) {\n  if (!arguments.length) {\n    return this._retries;\n  }\n  this._retries = n;\n};\n\n/**\n * Set or get current retry\n *\n * @api private\n */\nRunnable.prototype.currentRetry = function (n) {\n  if (!arguments.length) {\n    return this._currentRetry;\n  }\n  this._currentRetry = n;\n};\n\n/**\n * Return the full title generated by recursively concatenating the parent's\n * full title.\n *\n * @memberof Mocha.Runnable\n * @public\n * @api public\n * @return {string}\n */\nRunnable.prototype.fullTitle = function () {\n  return this.titlePath().join(' ');\n};\n\n/**\n * Return the title path generated by concatenating the parent's title path with the title.\n *\n * @memberof Mocha.Runnable\n * @public\n * @api public\n * @return {string}\n */\nRunnable.prototype.titlePath = function () {\n  return this.parent.titlePath().concat([this.title]);\n};\n\n/**\n * Clear the timeout.\n *\n * @api private\n */\nRunnable.prototype.clearTimeout = function () {\n  clearTimeout(this.timer);\n};\n\n/**\n * Inspect the runnable void of private properties.\n *\n * @api private\n * @return {string}\n */\nRunnable.prototype.inspect = function () {\n  return JSON.stringify(this, function (key, val) {\n    if (key[0] === '_') {\n      return;\n    }\n    if (key === 'parent') {\n      return '#<Suite>';\n    }\n    if (key === 'ctx') {\n      return '#<Context>';\n    }\n    return val;\n  }, 2);\n};\n\n/**\n * Reset the timeout.\n *\n * @api private\n */\nRunnable.prototype.resetTimeout = function () {\n  var self = this;\n  var ms = this.timeout() || 1e9;\n\n  if (!this._enableTimeouts) {\n    return;\n  }\n  this.clearTimeout();\n  this.timer = setTimeout(function () {\n    if (!self._enableTimeouts) {\n      return;\n    }\n    self.callback(self._timeoutError(ms));\n    self.timedOut = true;\n  }, ms);\n};\n\n/**\n * Set or get a list of whitelisted globals for this test run.\n *\n * @api private\n * @param {string[]} globals\n */\nRunnable.prototype.globals = function (globals) {\n  if (!arguments.length) {\n    return this._allowedGlobals;\n  }\n  this._allowedGlobals = globals;\n};\n\n/**\n * Run the test and invoke `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\nRunnable.prototype.run = function (fn) {\n  var self = this;\n  var start = new Date();\n  var ctx = this.ctx;\n  var finished;\n  var emitted;\n\n  // Sometimes the ctx exists, but it is not runnable\n  if (ctx && ctx.runnable) {\n    ctx.runnable(this);\n  }\n\n  // called multiple times\n  function multiple (err) {\n    if (emitted) {\n      return;\n    }\n    emitted = true;\n    var msg = 'done() called multiple times';\n    if (err && err.message) {\n      err.message += \" (and Mocha's \" + msg + ')';\n      self.emit('error', err);\n    } else {\n      self.emit('error', new Error(msg));\n    }\n  }\n\n  // finished\n  function done (err) {\n    var ms = self.timeout();\n    if (self.timedOut) {\n      return;\n    }\n\n    if (finished) {\n      return multiple(err);\n    }\n\n    self.clearTimeout();\n    self.duration = new Date() - start;\n    finished = true;\n    if (!err && self.duration > ms && self._enableTimeouts) {\n      err = self._timeoutError(ms);\n    }\n    fn(err);\n  }\n\n  // for .resetTimeout()\n  this.callback = done;\n\n  // explicit async with `done` argument\n  if (this.async) {\n    this.resetTimeout();\n\n    // allows skip() to be used in an explicit async context\n    this.skip = function asyncSkip () {\n      done(new Pending('async skip call'));\n      // halt execution.  the Runnable will be marked pending\n      // by the previous call, and the uncaught handler will ignore\n      // the failure.\n      throw new Pending('async skip; aborting execution');\n    };\n\n    if (this.allowUncaught) {\n      return callFnAsync(this.fn);\n    }\n    try {\n      callFnAsync(this.fn);\n    } catch (err) {\n      emitted = true;\n      done(utils.getError(err));\n    }\n    return;\n  }\n\n  if (this.allowUncaught) {\n    if (this.isPending()) {\n      done();\n    } else {\n      callFn(this.fn);\n    }\n    return;\n  }\n\n  // sync or promise-returning\n  try {\n    if (this.isPending()) {\n      done();\n    } else {\n      callFn(this.fn);\n    }\n  } catch (err) {\n    emitted = true;\n    done(utils.getError(err));\n  }\n\n  function callFn (fn) {\n    var result = fn.call(ctx);\n    if (result && typeof result.then === 'function') {\n      self.resetTimeout();\n      result\n        .then(function () {\n          done();\n          // Return null so libraries like bluebird do not warn about\n          // subsequently constructed Promises.\n          return null;\n        },\n        function (reason) {\n          done(reason || new Error('Promise rejected with no or falsy reason'));\n        });\n    } else {\n      if (self.asyncOnly) {\n        return done(new Error('--async-only option in use without declaring `done()` or returning a promise'));\n      }\n\n      done();\n    }\n  }\n\n  function callFnAsync (fn) {\n    var result = fn.call(ctx, function (err) {\n      if (err instanceof Error || toString.call(err) === '[object Error]') {\n        return done(err);\n      }\n      if (err) {\n        if (Object.prototype.toString.call(err) === '[object Object]') {\n          return done(new Error('done() invoked with non-Error: ' +\n            JSON.stringify(err)));\n        }\n        return done(new Error('done() invoked with non-Error: ' + err));\n      }\n      if (result && utils.isPromise(result)) {\n        return done(new Error('Resolution method is overspecified. Specify a callback *or* return a Promise; not both.'));\n      }\n\n      done();\n    });\n  }\n};\n\n/**\n * Instantiates a \"timeout\" error\n *\n * @param {number} ms - Timeout (in milliseconds)\n * @returns {Error} a \"timeout\" error\n * @private\n */\nRunnable.prototype._timeoutError = function (ms) {\n  var msg = 'Timeout of ' + ms + 'ms exceeded. For async tests and hooks, ensure \"done()\" is called; if returning a Promise, ensure it resolves.';\n  if (this.file) {\n    msg += ' (' + this.file + ')';\n  }\n  return new Error(msg);\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./ms\":14,\"./pending\":15,\"./utils\":36,\"debug\":43,\"events\":47}],33:[function(require,module,exports){\n(function (process,global){\n'use strict';\n\n/**\n * @module Runner\n */\n/**\n * Module dependencies.\n */\nvar EventEmitter = require('events').EventEmitter;\nvar Pending = require('./pending');\nvar utils = require('./utils');\nvar inherits = utils.inherits;\nvar debug = require('debug')('mocha:runner');\nvar Runnable = require('./runnable');\nvar stackFilter = utils.stackTraceFilter();\nvar stringify = utils.stringify;\nvar type = utils.type;\nvar undefinedError = utils.undefinedError;\n\n/**\n * Non-enumerable globals.\n */\n\nvar globals = [\n  'setTimeout',\n  'clearTimeout',\n  'setInterval',\n  'clearInterval',\n  'XMLHttpRequest',\n  'Date',\n  'setImmediate',\n  'clearImmediate'\n];\n\n/**\n * Expose `Runner`.\n */\n\nmodule.exports = Runner;\n\n/**\n * Initialize a `Runner` for the given `suite`. Derived from [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter)\n *\n * Events:\n *\n *   - `start`  execution started\n *   - `end`  execution complete\n *   - `suite`  (suite) test suite execution started\n *   - `suite end`  (suite) all tests (and sub-suites) have finished\n *   - `test`  (test) test execution started\n *   - `test end`  (test) test completed\n *   - `hook`  (hook) hook execution started\n *   - `hook end`  (hook) hook complete\n *   - `pass`  (test) test passed\n *   - `fail`  (test, err) test failed\n *   - `pending`  (test) test pending\n *\n * @memberof Mocha\n * @public\n * @class\n * @api public\n * @param {Suite} [suite] Root suite\n * @param {boolean} [delay] Whether or not to delay execution of root suite\n * until ready.\n */\nfunction Runner (suite, delay) {\n  var self = this;\n  this._globals = [];\n  this._abort = false;\n  this._delay = delay;\n  this.suite = suite;\n  this.started = false;\n  this.total = suite.total();\n  this.failures = 0;\n  this.on('test end', function (test) {\n    self.checkGlobals(test);\n  });\n  this.on('hook end', function (hook) {\n    self.checkGlobals(hook);\n  });\n  this._defaultGrep = /.*/;\n  this.grep(this._defaultGrep);\n  this.globals(this.globalProps().concat(extraGlobals()));\n}\n\n/**\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n *\n * @param {Function} fn\n * @api private\n */\nRunner.immediately = global.setImmediate || process.nextTick;\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Runner, EventEmitter);\n\n/**\n * Run tests with full titles matching `re`. Updates runner.total\n * with number of tests matched.\n *\n * @api public\n * @public\n * @memberof Mocha.Runner\n * @param {RegExp} re\n * @param {boolean} invert\n * @return {Runner} Runner instance.\n */\nRunner.prototype.grep = function (re, invert) {\n  debug('grep %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n};\n\n/**\n * Returns the number of tests matching the grep search for the\n * given suite.\n *\n * @memberof Mocha.Runner\n * @api public\n * @public\n * @param {Suite} suite\n * @return {number}\n */\nRunner.prototype.grepTotal = function (suite) {\n  var self = this;\n  var total = 0;\n\n  suite.eachTest(function (test) {\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (match) {\n      total++;\n    }\n  });\n\n  return total;\n};\n\n/**\n * Return a list of global properties.\n *\n * @return {Array}\n * @api private\n */\nRunner.prototype.globalProps = function () {\n  var props = Object.keys(global);\n\n  // non-enumerables\n  for (var i = 0; i < globals.length; ++i) {\n    if (~props.indexOf(globals[i])) {\n      continue;\n    }\n    props.push(globals[i]);\n  }\n\n  return props;\n};\n\n/**\n * Allow the given `arr` of globals.\n *\n * @api public\n * @public\n * @memberof Mocha.Runner\n * @param {Array} arr\n * @return {Runner} Runner instance.\n */\nRunner.prototype.globals = function (arr) {\n  if (!arguments.length) {\n    return this._globals;\n  }\n  debug('globals %j', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n};\n\n/**\n * Check for global variable leaks.\n *\n * @api private\n */\nRunner.prototype.checkGlobals = function (test) {\n  if (this.ignoreLeaks) {\n    return;\n  }\n  var ok = this._globals;\n\n  var globals = this.globalProps();\n  var leaks;\n\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n\n  if (this.prevGlobalsLength === globals.length) {\n    return;\n  }\n  this.prevGlobalsLength = globals.length;\n\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n\n  if (leaks.length > 1) {\n    this.fail(test, new Error('global leaks detected: ' + leaks.join(', ') + ''));\n  } else if (leaks.length) {\n    this.fail(test, new Error('global leak detected: ' + leaks[0]));\n  }\n};\n\n/**\n * Fail the given `test`.\n *\n * @api private\n * @param {Test} test\n * @param {Error} err\n */\nRunner.prototype.fail = function (test, err) {\n  if (test.isPending()) {\n    return;\n  }\n\n  ++this.failures;\n  test.state = 'failed';\n\n  if (!(err instanceof Error || (err && typeof err.message === 'string'))) {\n    err = new Error('the ' + type(err) + ' ' + stringify(err) + ' was thrown, throw an Error :)');\n  }\n\n  try {\n    err.stack = (this.fullStackTrace || !err.stack)\n      ? err.stack\n      : stackFilter(err.stack);\n  } catch (ignored) {\n    // some environments do not take kindly to monkeying with the stack\n  }\n\n  this.emit('fail', test, err);\n};\n\n/**\n * Fail the given `hook` with `err`.\n *\n * Hook failures work in the following pattern:\n * - If bail, then exit\n * - Failed `before` hook skips all tests in a suite and subsuites,\n *   but jumps to corresponding `after` hook\n * - Failed `before each` hook skips remaining tests in a\n *   suite and jumps to corresponding `after each` hook,\n *   which is run only once\n * - Failed `after` hook does not alter\n *   execution order\n * - Failed `after each` hook skips remaining tests in a\n *   suite and subsuites, but executes other `after each`\n *   hooks\n *\n * @api private\n * @param {Hook} hook\n * @param {Error} err\n */\nRunner.prototype.failHook = function (hook, err) {\n  if (hook.ctx && hook.ctx.currentTest) {\n    hook.originalTitle = hook.originalTitle || hook.title;\n    hook.title = hook.originalTitle + ' for \"' + hook.ctx.currentTest.title + '\"';\n  }\n\n  if (this.suite.bail()) {\n    this.emit('end');\n  }\n  this.fail(hook, err);\n};\n\n/**\n * Run hook `name` callbacks and then invoke `fn()`.\n *\n * @api private\n * @param {string} name\n * @param {Function} fn\n */\n\nRunner.prototype.hook = function (name, fn) {\n  var suite = this.suite;\n  var hooks = suite['_' + name];\n  var self = this;\n\n  function next (i) {\n    var hook = hooks[i];\n    if (!hook) {\n      return fn();\n    }\n    self.currentRunnable = hook;\n\n    hook.ctx.currentTest = self.test;\n\n    self.emit('hook', hook);\n\n    if (!hook.listeners('error').length) {\n      hook.on('error', function (err) {\n        self.failHook(hook, err);\n      });\n    }\n\n    hook.run(function (err) {\n      var testError = hook.error();\n      if (testError) {\n        self.fail(self.test, testError);\n      }\n      if (err) {\n        if (err instanceof Pending) {\n          if (name === 'beforeEach' || name === 'afterEach') {\n            self.test.pending = true;\n          } else {\n            suite.tests.forEach(function (test) {\n              test.pending = true;\n            });\n            // a pending hook won't be executed twice.\n            hook.pending = true;\n          }\n        } else {\n          self.failHook(hook, err);\n\n          // stop executing hooks, notify callee of hook err\n          return fn(err);\n        }\n      }\n      self.emit('hook end', hook);\n      delete hook.ctx.currentTest;\n      next(++i);\n    });\n  }\n\n  Runner.immediately(function () {\n    next(0);\n  });\n};\n\n/**\n * Run hook `name` for the given array of `suites`\n * in order, and callback `fn(err, errSuite)`.\n *\n * @api private\n * @param {string} name\n * @param {Array} suites\n * @param {Function} fn\n */\nRunner.prototype.hooks = function (name, suites, fn) {\n  var self = this;\n  var orig = this.suite;\n\n  function next (suite) {\n    self.suite = suite;\n\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n\n    self.hook(name, function (err) {\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n\n      next(suites.pop());\n    });\n  }\n\n  next(suites.pop());\n};\n\n/**\n * Run hooks from the top level down.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.hookUp = function (name, fn) {\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Run hooks from the bottom up.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.hookDown = function (name, fn) {\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Return an array of parent Suites from\n * closest to furthest.\n *\n * @return {Array}\n * @api private\n */\nRunner.prototype.parents = function () {\n  var suite = this.suite;\n  var suites = [];\n  while (suite.parent) {\n    suite = suite.parent;\n    suites.push(suite);\n  }\n  return suites;\n};\n\n/**\n * Run the current test and callback `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.runTest = function (fn) {\n  var self = this;\n  var test = this.test;\n\n  if (!test) {\n    return;\n  }\n  if (this.forbidOnly && hasOnly(this.parents().reverse()[0] || this.suite)) {\n    fn(new Error('`.only` forbidden'));\n    return;\n  }\n  if (this.asyncOnly) {\n    test.asyncOnly = true;\n  }\n  test.on('error', function (err) {\n    self.fail(test, err);\n  });\n  if (this.allowUncaught) {\n    test.allowUncaught = true;\n    return test.run(fn);\n  }\n  try {\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\n *\n * @api private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runTests = function (suite, fn) {\n  var self = this;\n  var tests = suite.tests.slice();\n  var test;\n\n  function hookErr (_, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite;\n\n    // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n    self.suite = after ? errSuite.parent : errSuite;\n\n    if (self.suite) {\n      // call hookUp afterEach\n      self.hookUp('afterEach', function (err2, errSuite2) {\n        self.suite = orig;\n        // some hooks may fail even now\n        if (err2) {\n          return hookErr(err2, errSuite2, true);\n        }\n        // report error suite\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n\n  function next (err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) {\n      return fn();\n    }\n\n    if (self._abort) {\n      return fn();\n    }\n\n    if (err) {\n      return hookErr(err, errSuite, true);\n    }\n\n    // next test\n    test = tests.shift();\n\n    // all done\n    if (!test) {\n      return fn();\n    }\n\n    // grep\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (!match) {\n      // Run immediately only if we have defined a grep. When we\n      // define a grep — It can cause maximum callstack error if\n      // the grep is doing a large recursive loop by neglecting\n      // all tests. The run immediately function also comes with\n      // a performance cost. So we don't want to run immediately\n      // if we run the whole test suite, because running the whole\n      // test suite don't do any immediate recursive loops. Thus,\n      // allowing a JS runtime to breathe.\n      if (self._grep !== self._defaultGrep) {\n        Runner.immediately(next);\n      } else {\n        next();\n      }\n      return;\n    }\n\n    if (test.isPending()) {\n      if (self.forbidPending) {\n        test.isPending = alwaysFalse;\n        self.fail(test, new Error('Pending test forbidden'));\n        delete test.isPending;\n      } else {\n        self.emit('pending', test);\n      }\n      self.emit('test end', test);\n      return next();\n    }\n\n    // execute test and hook(s)\n    self.emit('test', self.test = test);\n    self.hookDown('beforeEach', function (err, errSuite) {\n      if (test.isPending()) {\n        if (self.forbidPending) {\n          test.isPending = alwaysFalse;\n          self.fail(test, new Error('Pending test forbidden'));\n          delete test.isPending;\n        } else {\n          self.emit('pending', test);\n        }\n        self.emit('test end', test);\n        return next();\n      }\n      if (err) {\n        return hookErr(err, errSuite, false);\n      }\n      self.currentRunnable = self.test;\n      self.runTest(function (err) {\n        test = self.test;\n        if (err) {\n          var retry = test.currentRetry();\n          if (err instanceof Pending && self.forbidPending) {\n            self.fail(test, new Error('Pending test forbidden'));\n          } else if (err instanceof Pending) {\n            test.pending = true;\n            self.emit('pending', test);\n          } else if (retry < test.retries()) {\n            var clonedTest = test.clone();\n            clonedTest.currentRetry(retry + 1);\n            tests.unshift(clonedTest);\n\n            // Early return + hook trigger so that it doesn't\n            // increment the count wrong\n            return self.hookUp('afterEach', next);\n          } else {\n            self.fail(test, err);\n          }\n          self.emit('test end', test);\n\n          if (err instanceof Pending) {\n            return next();\n          }\n\n          return self.hookUp('afterEach', next);\n        }\n\n        test.state = 'passed';\n        self.emit('pass', test);\n        self.emit('test end', test);\n        self.hookUp('afterEach', next);\n      });\n    });\n  }\n\n  this.next = next;\n  this.hookErr = hookErr;\n  next();\n};\n\nfunction alwaysFalse () {\n  return false;\n}\n\n/**\n * Run the given `suite` and invoke the callback `fn()` when complete.\n *\n * @api private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runSuite = function (suite, fn) {\n  var i = 0;\n  var self = this;\n  var total = this.grepTotal(suite);\n  var afterAllHookCalled = false;\n\n  debug('run suite %s', suite.fullTitle());\n\n  if (!total || (self.failures && suite._bail)) {\n    return fn();\n  }\n\n  this.emit('suite', this.suite = suite);\n\n  function next (errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite === suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      }\n      // errSuite is among the parents of current suite\n      // stop execution of errSuite and all sub-suites\n      return done(errSuite);\n    }\n\n    if (self._abort) {\n      return done();\n    }\n\n    var curr = suite.suites[i++];\n    if (!curr) {\n      return done();\n    }\n\n    // Avoid grep neglecting large number of tests causing a\n    // huge recursive loop and thus a maximum call stack error.\n    // See comment in `this.runTests()` for more information.\n    if (self._grep !== self._defaultGrep) {\n      Runner.immediately(function () {\n        self.runSuite(curr, next);\n      });\n    } else {\n      self.runSuite(curr, next);\n    }\n  }\n\n  function done (errSuite) {\n    self.suite = suite;\n    self.nextSuite = next;\n\n    if (afterAllHookCalled) {\n      fn(errSuite);\n    } else {\n      // mark that the afterAll block has been called once\n      // and so can be skipped if there is an error in it.\n      afterAllHookCalled = true;\n\n      // remove reference to test\n      delete self.test;\n\n      self.hook('afterAll', function () {\n        self.emit('suite end', suite);\n        fn(errSuite);\n      });\n    }\n  }\n\n  this.nextSuite = next;\n\n  this.hook('beforeAll', function (err) {\n    if (err) {\n      return done();\n    }\n    self.runTests(suite, next);\n  });\n};\n\n/**\n * Handle uncaught exceptions.\n *\n * @param {Error} err\n * @api private\n */\nRunner.prototype.uncaught = function (err) {\n  if (err) {\n    debug('uncaught exception %s', err === (function () {\n      return this;\n    }.call(err)) ? (err.message || err) : err);\n  } else {\n    debug('uncaught undefined exception');\n    err = undefinedError();\n  }\n  err.uncaught = true;\n\n  var runnable = this.currentRunnable;\n\n  if (!runnable) {\n    runnable = new Runnable('Uncaught error outside test suite');\n    runnable.parent = this.suite;\n\n    if (this.started) {\n      this.fail(runnable, err);\n    } else {\n      // Can't recover from this failure\n      this.emit('start');\n      this.fail(runnable, err);\n      this.emit('end');\n    }\n\n    return;\n  }\n\n  runnable.clearTimeout();\n\n  // Ignore errors if already failed or pending\n  // See #3226\n  if (runnable.isFailed() || runnable.isPending()) {\n    return;\n  }\n  // we cannot recover gracefully if a Runnable has already passed\n  // then fails asynchronously\n  var alreadyPassed = runnable.isPassed();\n  // this will change the state to \"failed\" regardless of the current value\n  this.fail(runnable, err);\n  if (!alreadyPassed) {\n    // recover from test\n    if (runnable.type === 'test') {\n      this.emit('test end', runnable);\n      this.hookUp('afterEach', this.next);\n      return;\n    }\n\n    // recover from hooks\n    var errSuite = this.suite;\n    // if hook failure is in afterEach block\n    if (runnable.fullTitle().indexOf('after each') > -1) {\n      return this.hookErr(err, errSuite, true);\n    }\n    // if hook failure is in beforeEach block\n    if (runnable.fullTitle().indexOf('before each') > -1) {\n      return this.hookErr(err, errSuite, false);\n    }\n    // if hook failure is in after or before blocks\n    return this.nextSuite(errSuite);\n  }\n\n  // bail\n  this.emit('end');\n};\n\n/**\n * Cleans up the references to all the deferred functions\n * (before/after/beforeEach/afterEach) and tests of a Suite.\n * These must be deleted otherwise a memory leak can happen,\n * as those functions may reference variables from closures,\n * thus those variables can never be garbage collected as long\n * as the deferred functions exist.\n *\n * @param {Suite} suite\n */\nfunction cleanSuiteReferences (suite) {\n  function cleanArrReferences (arr) {\n    for (var i = 0; i < arr.length; i++) {\n      delete arr[i].fn;\n    }\n  }\n\n  if (Array.isArray(suite._beforeAll)) {\n    cleanArrReferences(suite._beforeAll);\n  }\n\n  if (Array.isArray(suite._beforeEach)) {\n    cleanArrReferences(suite._beforeEach);\n  }\n\n  if (Array.isArray(suite._afterAll)) {\n    cleanArrReferences(suite._afterAll);\n  }\n\n  if (Array.isArray(suite._afterEach)) {\n    cleanArrReferences(suite._afterEach);\n  }\n\n  for (var i = 0; i < suite.tests.length; i++) {\n    delete suite.tests[i].fn;\n  }\n}\n\n/**\n * Run the root suite and invoke `fn(failures)`\n * on completion.\n *\n * @api public\n * @public\n * @memberof Mocha.Runner\n * @param {Function} fn\n * @return {Runner} Runner instance.\n */\nRunner.prototype.run = function (fn) {\n  var self = this;\n  var rootSuite = this.suite;\n\n  fn = fn || function () {};\n\n  function uncaught (err) {\n    self.uncaught(err);\n  }\n\n  function start () {\n    // If there is an `only` filter\n    if (hasOnly(rootSuite)) {\n      filterOnly(rootSuite);\n    }\n    self.started = true;\n    self.emit('start');\n    self.runSuite(rootSuite, function () {\n      debug('finished running');\n      self.emit('end');\n    });\n  }\n\n  debug('start');\n\n  // references cleanup to avoid memory leaks\n  this.on('suite end', cleanSuiteReferences);\n\n  // callback\n  this.on('end', function () {\n    debug('end');\n    process.removeListener('uncaughtException', uncaught);\n    fn(self.failures);\n  });\n\n  // uncaught exception\n  process.on('uncaughtException', uncaught);\n\n  if (this._delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit('waiting', rootSuite);\n    rootSuite.once('run', start);\n  } else {\n    start();\n  }\n\n  return this;\n};\n\n/**\n * Cleanly abort execution.\n *\n * @memberof Mocha.Runner\n * @public\n * @api public\n * @return {Runner} Runner instance.\n */\nRunner.prototype.abort = function () {\n  debug('aborting');\n  this._abort = true;\n\n  return this;\n};\n\n/**\n * Filter suites based on `isOnly` logic.\n *\n * @param {Array} suite\n * @returns {Boolean}\n * @api private\n */\nfunction filterOnly (suite) {\n  if (suite._onlyTests.length) {\n    // If the suite contains `only` tests, run those and ignore any nested suites.\n    suite.tests = suite._onlyTests;\n    suite.suites = [];\n  } else {\n    // Otherwise, do not run any of the tests in this suite.\n    suite.tests = [];\n    suite._onlySuites.forEach(function (onlySuite) {\n      // If there are other `only` tests/suites nested in the current `only` suite, then filter that `only` suite.\n      // Otherwise, all of the tests on this `only` suite should be run, so don't filter it.\n      if (hasOnly(onlySuite)) {\n        filterOnly(onlySuite);\n      }\n    });\n    // Run the `only` suites, as well as any other suites that have `only` tests/suites as descendants.\n    suite.suites = suite.suites.filter(function (childSuite) {\n      return suite._onlySuites.indexOf(childSuite) !== -1 || filterOnly(childSuite);\n    });\n  }\n  // Keep the suite only if there is something to run\n  return suite.tests.length || suite.suites.length;\n}\n\n/**\n * Determines whether a suite has an `only` test or suite as a descendant.\n *\n * @param {Array} suite\n * @returns {Boolean}\n * @api private\n */\nfunction hasOnly (suite) {\n  return suite._onlyTests.length || suite._onlySuites.length || suite.suites.some(hasOnly);\n}\n\n/**\n * Filter leaks with the given globals flagged as `ok`.\n *\n * @api private\n * @param {Array} ok\n * @param {Array} globals\n * @return {Array}\n */\nfunction filterLeaks (ok, globals) {\n  return globals.filter(function (key) {\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^\\d+/.test(key)) {\n      return false;\n    }\n\n    // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method\n    // not init at first it is assigned in some seconds\n    if (global.navigator && (/^getInterface/).test(key)) {\n      return false;\n    }\n\n    // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n    if (global.navigator && (/^\\d+/).test(key)) {\n      return false;\n    }\n\n    // Opera and IE expose global variables for HTML element IDs (issue #243)\n    if (/^mocha-/.test(key)) {\n      return false;\n    }\n\n    var matched = ok.filter(function (ok) {\n      if (~ok.indexOf('*')) {\n        return key.indexOf(ok.split('*')[0]) === 0;\n      }\n      return key === ok;\n    });\n    return !matched.length && (!global.navigator || key !== 'onerror');\n  });\n}\n\n/**\n * Array of globals dependent on the environment.\n *\n * @return {Array}\n * @api private\n */\nfunction extraGlobals () {\n  if (typeof process === 'object' && typeof process.version === 'string') {\n    var parts = process.version.split('.');\n    var nodeVersion = parts.reduce(function (a, v) {\n      return a << 8 | v;\n    });\n\n    // 'errno' was renamed to process._errno in v0.9.11.\n\n    if (nodeVersion < 0x00090B) {\n      return ['errno'];\n    }\n  }\n\n  return [];\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./pending\":15,\"./runnable\":32,\"./utils\":36,\"_process\":56,\"debug\":43,\"events\":47}],34:[function(require,module,exports){\n'use strict';\n/**\n * @module Suite\n */\n\n/**\n * Module dependencies.\n */\nvar EventEmitter = require('events').EventEmitter;\nvar Hook = require('./hook');\nvar utils = require('./utils');\nvar inherits = utils.inherits;\nvar debug = require('debug')('mocha:suite');\nvar milliseconds = require('./ms');\n\n/**\n * Expose `Suite`.\n */\n\nexports = module.exports = Suite;\n\n/**\n * Create a new `Suite` with the given `title` and parent `Suite`. When a suite\n * with the same title is already present, that suite is returned to provide\n * nicer reporter and more flexible meta-testing.\n *\n * @memberof Mocha\n * @public\n * @api public\n * @param {Suite} parent\n * @param {string} title\n * @return {Suite}\n */\nexports.create = function (parent, title) {\n  var suite = new Suite(title, parent.ctx);\n  suite.parent = parent;\n  title = suite.fullTitle();\n  parent.addSuite(suite);\n  return suite;\n};\n\n/**\n * Initialize a new `Suite` with the given `title` and `ctx`. Derived from [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter)\n *\n * @memberof Mocha\n * @public\n * @class\n * @param {string} title\n * @param {Context} parentContext\n */\nfunction Suite (title, parentContext) {\n  if (!utils.isString(title)) {\n    throw new Error('Suite `title` should be a \"string\" but \"' + typeof title + '\" was given instead.');\n  }\n  this.title = title;\n  function Context () {}\n  Context.prototype = parentContext;\n  this.ctx = new Context();\n  this.suites = [];\n  this.tests = [];\n  this.pending = false;\n  this._beforeEach = [];\n  this._beforeAll = [];\n  this._afterEach = [];\n  this._afterAll = [];\n  this.root = !title;\n  this._timeout = 2000;\n  this._enableTimeouts = true;\n  this._slow = 75;\n  this._bail = false;\n  this._retries = -1;\n  this._onlyTests = [];\n  this._onlySuites = [];\n  this.delayed = false;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Suite, EventEmitter);\n\n/**\n * Return a clone of this `Suite`.\n *\n * @api private\n * @return {Suite}\n */\nSuite.prototype.clone = function () {\n  var suite = new Suite(this.title);\n  debug('clone');\n  suite.ctx = this.ctx;\n  suite.timeout(this.timeout());\n  suite.retries(this.retries());\n  suite.enableTimeouts(this.enableTimeouts());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  return suite;\n};\n\n/**\n * Set or get timeout `ms` or short-hand such as \"2s\".\n *\n * @api private\n * @param {number|string} ms\n * @return {Suite|number} for chaining\n */\nSuite.prototype.timeout = function (ms) {\n  if (!arguments.length) {\n    return this._timeout;\n  }\n  if (ms.toString() === '0') {\n    this._enableTimeouts = false;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._timeout = parseInt(ms, 10);\n  return this;\n};\n\n/**\n * Set or get number of times to retry a failed test.\n *\n * @api private\n * @param {number|string} n\n * @return {Suite|number} for chaining\n */\nSuite.prototype.retries = function (n) {\n  if (!arguments.length) {\n    return this._retries;\n  }\n  debug('retries %d', n);\n  this._retries = parseInt(n, 10) || 0;\n  return this;\n};\n\n/**\n  * Set or get timeout to `enabled`.\n  *\n  * @api private\n  * @param {boolean} enabled\n  * @return {Suite|boolean} self or enabled\n  */\nSuite.prototype.enableTimeouts = function (enabled) {\n  if (!arguments.length) {\n    return this._enableTimeouts;\n  }\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Set or get slow `ms` or short-hand such as \"2s\".\n *\n * @api private\n * @param {number|string} ms\n * @return {Suite|number} for chaining\n */\nSuite.prototype.slow = function (ms) {\n  if (!arguments.length) {\n    return this._slow;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('slow %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Set or get whether to bail after first error.\n *\n * @api private\n * @param {boolean} bail\n * @return {Suite|number} for chaining\n */\nSuite.prototype.bail = function (bail) {\n  if (!arguments.length) {\n    return this._bail;\n  }\n  debug('bail %s', bail);\n  this._bail = bail;\n  return this;\n};\n\n/**\n * Check if this suite or its parent suite is marked as pending.\n *\n * @api private\n */\nSuite.prototype.isPending = function () {\n  return this.pending || (this.parent && this.parent.isPending());\n};\n\n/**\n * Generic hook-creator.\n * @private\n * @param {string} title - Title of hook\n * @param {Function} fn - Hook callback\n * @returns {Hook} A new hook\n */\nSuite.prototype._createHook = function (title, fn) {\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  hook.file = this.file;\n  return hook;\n};\n\n/**\n * Run `fn(test[, done])` before running tests.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.beforeAll = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before all\" hook' + (title ? ': ' + title : '');\n\n  var hook = this._createHook(title, fn);\n  this._beforeAll.push(hook);\n  this.emit('beforeAll', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after running tests.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.afterAll = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after all\" hook' + (title ? ': ' + title : '');\n\n  var hook = this._createHook(title, fn);\n  this._afterAll.push(hook);\n  this.emit('afterAll', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` before each test case.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.beforeEach = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before each\" hook' + (title ? ': ' + title : '');\n\n  var hook = this._createHook(title, fn);\n  this._beforeEach.push(hook);\n  this.emit('beforeEach', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after each test case.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.afterEach = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after each\" hook' + (title ? ': ' + title : '');\n\n  var hook = this._createHook(title, fn);\n  this._afterEach.push(hook);\n  this.emit('afterEach', hook);\n  return this;\n};\n\n/**\n * Add a test `suite`.\n *\n * @api private\n * @param {Suite} suite\n * @return {Suite} for chaining\n */\nSuite.prototype.addSuite = function (suite) {\n  suite.parent = this;\n  suite.timeout(this.timeout());\n  suite.retries(this.retries());\n  suite.enableTimeouts(this.enableTimeouts());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  this.suites.push(suite);\n  this.emit('suite', suite);\n  return this;\n};\n\n/**\n * Add a `test` to this suite.\n *\n * @api private\n * @param {Test} test\n * @return {Suite} for chaining\n */\nSuite.prototype.addTest = function (test) {\n  test.parent = this;\n  test.timeout(this.timeout());\n  test.retries(this.retries());\n  test.enableTimeouts(this.enableTimeouts());\n  test.slow(this.slow());\n  test.ctx = this.ctx;\n  this.tests.push(test);\n  this.emit('test', test);\n  return this;\n};\n\n/**\n * Return the full title generated by recursively concatenating the parent's\n * full title.\n *\n * @memberof Mocha.Suite\n * @public\n * @api public\n * @return {string}\n */\nSuite.prototype.fullTitle = function () {\n  return this.titlePath().join(' ');\n};\n\n/**\n * Return the title path generated by recursively concatenating the parent's\n * title path.\n *\n * @memberof Mocha.Suite\n * @public\n * @api public\n * @return {string}\n */\nSuite.prototype.titlePath = function () {\n  var result = [];\n  if (this.parent) {\n    result = result.concat(this.parent.titlePath());\n  }\n  if (!this.root) {\n    result.push(this.title);\n  }\n  return result;\n};\n\n/**\n * Return the total number of tests.\n *\n * @memberof Mocha.Suite\n * @public\n * @api public\n * @return {number}\n */\nSuite.prototype.total = function () {\n  return this.suites.reduce(function (sum, suite) {\n    return sum + suite.total();\n  }, 0) + this.tests.length;\n};\n\n/**\n * Iterates through each suite recursively to find all tests. Applies a\n * function in the format `fn(test)`.\n *\n * @api private\n * @param {Function} fn\n * @return {Suite}\n */\nSuite.prototype.eachTest = function (fn) {\n  this.tests.forEach(fn);\n  this.suites.forEach(function (suite) {\n    suite.eachTest(fn);\n  });\n  return this;\n};\n\n/**\n * This will run the root suite if we happen to be running in delayed mode.\n */\nSuite.prototype.run = function run () {\n  if (this.root) {\n    this.emit('run');\n  }\n};\n\n},{\"./hook\":6,\"./ms\":14,\"./utils\":36,\"debug\":43,\"events\":47}],35:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Runnable = require('./runnable');\nvar utils = require('./utils');\nvar isString = utils.isString;\n\n/**\n * Expose `Test`.\n */\n\nmodule.exports = Test;\n\n/**\n * Initialize a new `Test` with the given `title` and callback `fn`.\n *\n * @api private\n * @param {String} title\n * @param {Function} fn\n */\nfunction Test (title, fn) {\n  if (!isString(title)) {\n    throw new Error('Test `title` should be a \"string\" but \"' + typeof title + '\" was given instead.');\n  }\n  Runnable.call(this, title, fn);\n  this.pending = !fn;\n  this.type = 'test';\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\nutils.inherits(Test, Runnable);\n\nTest.prototype.clone = function () {\n  var test = new Test(this.title, this.fn);\n  test.timeout(this.timeout());\n  test.slow(this.slow());\n  test.enableTimeouts(this.enableTimeouts());\n  test.retries(this.retries());\n  test.currentRetry(this.currentRetry());\n  test.globals(this.globals());\n  test.parent = this.parent;\n  test.file = this.file;\n  test.ctx = this.ctx;\n  return test;\n};\n\n},{\"./runnable\":32,\"./utils\":36}],36:[function(require,module,exports){\n(function (process,Buffer){\n'use strict';\n\n/**\n * @module\n */\n\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('mocha:watch');\nvar fs = require('fs');\nvar glob = require('glob');\nvar path = require('path');\nvar join = path.join;\nvar he = require('he');\n\n/**\n * Ignored directories.\n */\n\nvar ignore = ['node_modules', '.git'];\n\nexports.inherits = require('util').inherits;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @api private\n * @param  {string} html\n * @return {string}\n */\nexports.escape = function (html) {\n  return he.encode(String(html), { useNamedReferences: false });\n};\n\n/**\n * Test if the given obj is type of string.\n *\n * @api private\n * @param {Object} obj\n * @return {boolean}\n */\nexports.isString = function (obj) {\n  return typeof obj === 'string';\n};\n\n/**\n * Watch the given `files` for changes\n * and invoke `fn(file)` on modification.\n *\n * @api private\n * @param {Array} files\n * @param {Function} fn\n */\nexports.watch = function (files, fn) {\n  var options = { interval: 100 };\n  files.forEach(function (file) {\n    debug('file %s', file);\n    fs.watchFile(file, options, function (curr, prev) {\n      if (prev.mtime < curr.mtime) {\n        fn(file);\n      }\n    });\n  });\n};\n\n/**\n * Ignored files.\n *\n * @api private\n * @param {string} path\n * @return {boolean}\n */\nfunction ignored (path) {\n  return !~ignore.indexOf(path);\n}\n\n/**\n * Lookup files in the given `dir`.\n *\n * @api private\n * @param {string} dir\n * @param {string[]} [ext=['.js']]\n * @param {Array} [ret=[]]\n * @return {Array}\n */\nexports.files = function (dir, ext, ret) {\n  ret = ret || [];\n  ext = ext || ['js'];\n\n  var re = new RegExp('\\\\.(' + ext.join('|') + ')$');\n\n  fs.readdirSync(dir)\n    .filter(ignored)\n    .forEach(function (path) {\n      path = join(dir, path);\n      if (fs.lstatSync(path).isDirectory()) {\n        exports.files(path, ext, ret);\n      } else if (path.match(re)) {\n        ret.push(path);\n      }\n    });\n\n  return ret;\n};\n\n/**\n * Compute a slug from the given `str`.\n *\n * @api private\n * @param {string} str\n * @return {string}\n */\nexports.slug = function (str) {\n  return str\n    .toLowerCase()\n    .replace(/ +/g, '-')\n    .replace(/[^-\\w]/g, '');\n};\n\n/**\n * Strip the function definition from `str`, and re-indent for pre whitespace.\n *\n * @param {string} str\n * @return {string}\n */\nexports.clean = function (str) {\n  str = str\n    .replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, '\\n').replace(/^\\uFEFF/, '')\n    // (traditional)->  space/name     parameters    body     (lambda)-> parameters       body   multi-statement/single          keep body content\n    .replace(/^function(?:\\s*|\\s+[^(]*)\\([^)]*\\)\\s*\\{((?:.|\\n)*?)\\s*\\}$|^\\([^)]*\\)\\s*=>\\s*(?:\\{((?:.|\\n)*?)\\s*\\}|((?:.|\\n)*))$/, '$1$2$3');\n\n  var spaces = str.match(/^\\n?( *)/)[1].length;\n  var tabs = str.match(/^\\n?(\\t*)/)[1].length;\n  var re = new RegExp('^\\n?' + (tabs ? '\\t' : ' ') + '{' + (tabs || spaces) + '}', 'gm');\n\n  str = str.replace(re, '');\n\n  return str.trim();\n};\n\n/**\n * Parse the given `qs`.\n *\n * @api private\n * @param {string} qs\n * @return {Object}\n */\nexports.parseQuery = function (qs) {\n  return qs.replace('?', '').split('&').reduce(function (obj, pair) {\n    var i = pair.indexOf('=');\n    var key = pair.slice(0, i);\n    var val = pair.slice(++i);\n\n    // Due to how the URLSearchParams API treats spaces\n    obj[key] = decodeURIComponent(val.replace(/\\+/g, '%20'));\n\n    return obj;\n  }, {});\n};\n\n/**\n * Highlight the given string of `js`.\n *\n * @api private\n * @param {string} js\n * @return {string}\n */\nfunction highlight (js) {\n  return js\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\\/\\/(.*)/gm, '<span class=\"comment\">//$1</span>')\n    .replace(/('.*?')/gm, '<span class=\"string\">$1</span>')\n    .replace(/(\\d+\\.\\d+)/gm, '<span class=\"number\">$1</span>')\n    .replace(/(\\d+)/gm, '<span class=\"number\">$1</span>')\n    .replace(/\\bnew[ \\t]+(\\w+)/gm, '<span class=\"keyword\">new</span> <span class=\"init\">$1</span>')\n    .replace(/\\b(function|new|throw|return|var|if|else)\\b/gm, '<span class=\"keyword\">$1</span>');\n}\n\n/**\n * Highlight the contents of tag `name`.\n *\n * @api private\n * @param {string} name\n */\nexports.highlightTags = function (name) {\n  var code = document.getElementById('mocha').getElementsByTagName(name);\n  for (var i = 0, len = code.length; i < len; ++i) {\n    code[i].innerHTML = highlight(code[i].innerHTML);\n  }\n};\n\n/**\n * If a value could have properties, and has none, this function is called,\n * which returns a string representation of the empty value.\n *\n * Functions w/ no properties return `'[Function]'`\n * Arrays w/ length === 0 return `'[]'`\n * Objects w/ no properties return `'{}'`\n * All else: return result of `value.toString()`\n *\n * @api private\n * @param {*} value The value to inspect.\n * @param {string} typeHint The type of the value\n * @returns {string}\n */\nfunction emptyRepresentation (value, typeHint) {\n  switch (typeHint) {\n    case 'function':\n      return '[Function]';\n    case 'object':\n      return '{}';\n    case 'array':\n      return '[]';\n    default:\n      return value.toString();\n  }\n}\n\n/**\n * Takes some variable and asks `Object.prototype.toString()` what it thinks it\n * is.\n *\n * @api private\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n * @param {*} value The value to test.\n * @returns {string} Computed type\n * @example\n * type({}) // 'object'\n * type([]) // 'array'\n * type(1) // 'number'\n * type(false) // 'boolean'\n * type(Infinity) // 'number'\n * type(null) // 'null'\n * type(new Date()) // 'date'\n * type(/foo/) // 'regexp'\n * type('type') // 'string'\n * type(global) // 'global'\n * type(new String('foo') // 'object'\n */\nvar type = exports.type = function type (value) {\n  if (value === undefined) {\n    return 'undefined';\n  } else if (value === null) {\n    return 'null';\n  } else if (Buffer.isBuffer(value)) {\n    return 'buffer';\n  }\n  return Object.prototype.toString.call(value)\n    .replace(/^\\[.+\\s(.+?)]$/, '$1')\n    .toLowerCase();\n};\n\n/**\n * Stringify `value`. Different behavior depending on type of value:\n *\n * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively.\n * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes.\n * - If `value` is an *empty* object, function, or array, return result of function\n *   {@link emptyRepresentation}.\n * - If `value` has properties, call {@link exports.canonicalize} on it, then return result of\n *   JSON.stringify().\n *\n * @api private\n * @see exports.type\n * @param {*} value\n * @return {string}\n */\nexports.stringify = function (value) {\n  var typeHint = type(value);\n\n  if (!~['object', 'array', 'function'].indexOf(typeHint)) {\n    if (typeHint === 'buffer') {\n      var json = Buffer.prototype.toJSON.call(value);\n      // Based on the toJSON result\n      return jsonStringify(json.data && json.type ? json.data : json, 2)\n        .replace(/,(\\n|$)/g, '$1');\n    }\n\n    // IE7/IE8 has a bizarre String constructor; needs to be coerced\n    // into an array and back to obj.\n    if (typeHint === 'string' && typeof value === 'object') {\n      value = value.split('').reduce(function (acc, char, idx) {\n        acc[idx] = char;\n        return acc;\n      }, {});\n      typeHint = 'object';\n    } else {\n      return jsonStringify(value);\n    }\n  }\n\n  for (var prop in value) {\n    if (Object.prototype.hasOwnProperty.call(value, prop)) {\n      return jsonStringify(exports.canonicalize(value, null, typeHint), 2).replace(/,(\\n|$)/g, '$1');\n    }\n  }\n\n  return emptyRepresentation(value, typeHint);\n};\n\n/**\n * like JSON.stringify but more sense.\n *\n * @api private\n * @param {Object}  object\n * @param {number=} spaces\n * @param {number=} depth\n * @returns {*}\n */\nfunction jsonStringify (object, spaces, depth) {\n  if (typeof spaces === 'undefined') {\n    // primitive types\n    return _stringify(object);\n  }\n\n  depth = depth || 1;\n  var space = spaces * depth;\n  var str = Array.isArray(object) ? '[' : '{';\n  var end = Array.isArray(object) ? ']' : '}';\n  var length = typeof object.length === 'number' ? object.length : Object.keys(object).length;\n  // `.repeat()` polyfill\n  function repeat (s, n) {\n    return new Array(n).join(s);\n  }\n\n  function _stringify (val) {\n    switch (type(val)) {\n      case 'null':\n      case 'undefined':\n        val = '[' + val + ']';\n        break;\n      case 'array':\n      case 'object':\n        val = jsonStringify(val, spaces, depth + 1);\n        break;\n      case 'boolean':\n      case 'regexp':\n      case 'symbol':\n      case 'number':\n        val = val === 0 && (1 / val) === -Infinity // `-0`\n          ? '-0'\n          : val.toString();\n        break;\n      case 'date':\n        var sDate = isNaN(val.getTime()) ? val.toString() : val.toISOString();\n        val = '[Date: ' + sDate + ']';\n        break;\n      case 'buffer':\n        var json = val.toJSON();\n        // Based on the toJSON result\n        json = json.data && json.type ? json.data : json;\n        val = '[Buffer: ' + jsonStringify(json, 2, depth + 1) + ']';\n        break;\n      default:\n        val = (val === '[Function]' || val === '[Circular]')\n          ? val\n          : JSON.stringify(val); // string\n    }\n    return val;\n  }\n\n  for (var i in object) {\n    if (!Object.prototype.hasOwnProperty.call(object, i)) {\n      continue; // not my business\n    }\n    --length;\n    str += '\\n ' + repeat(' ', space) +\n      (Array.isArray(object) ? '' : '\"' + i + '\": ') + // key\n      _stringify(object[i]) + // value\n      (length ? ',' : ''); // comma\n  }\n\n  return str +\n    // [], {}\n    (str.length !== 1 ? '\\n' + repeat(' ', --space) + end : end);\n}\n\n/**\n * Return a new Thing that has the keys in sorted order. Recursive.\n *\n * If the Thing...\n * - has already been seen, return string `'[Circular]'`\n * - is `undefined`, return string `'[undefined]'`\n * - is `null`, return value `null`\n * - is some other primitive, return the value\n * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method\n * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.\n * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`\n *\n * @api private\n * @see {@link exports.stringify}\n * @param {*} value Thing to inspect.  May or may not have properties.\n * @param {Array} [stack=[]] Stack of seen values\n * @param {string} [typeHint] Type hint\n * @return {(Object|Array|Function|string|undefined)}\n */\nexports.canonicalize = function canonicalize (value, stack, typeHint) {\n  var canonicalizedObj;\n  /* eslint-disable no-unused-vars */\n  var prop;\n  /* eslint-enable no-unused-vars */\n  typeHint = typeHint || type(value);\n  function withStack (value, fn) {\n    stack.push(value);\n    fn();\n    stack.pop();\n  }\n\n  stack = stack || [];\n\n  if (stack.indexOf(value) !== -1) {\n    return '[Circular]';\n  }\n\n  switch (typeHint) {\n    case 'undefined':\n    case 'buffer':\n    case 'null':\n      canonicalizedObj = value;\n      break;\n    case 'array':\n      withStack(value, function () {\n        canonicalizedObj = value.map(function (item) {\n          return exports.canonicalize(item, stack);\n        });\n      });\n      break;\n    case 'function':\n      /* eslint-disable guard-for-in */\n      for (prop in value) {\n        canonicalizedObj = {};\n        break;\n      }\n      /* eslint-enable guard-for-in */\n      if (!canonicalizedObj) {\n        canonicalizedObj = emptyRepresentation(value, typeHint);\n        break;\n      }\n    /* falls through */\n    case 'object':\n      canonicalizedObj = canonicalizedObj || {};\n      withStack(value, function () {\n        Object.keys(value).sort().forEach(function (key) {\n          canonicalizedObj[key] = exports.canonicalize(value[key], stack);\n        });\n      });\n      break;\n    case 'date':\n    case 'number':\n    case 'regexp':\n    case 'boolean':\n    case 'symbol':\n      canonicalizedObj = value;\n      break;\n    default:\n      canonicalizedObj = value + '';\n  }\n\n  return canonicalizedObj;\n};\n\n/**\n * Lookup file names at the given `path`.\n *\n * @memberof Mocha.utils\n * @public\n * @api public\n * @param {string} filepath Base path to start searching from.\n * @param {string[]} extensions File extensions to look for.\n * @param {boolean} recursive Whether or not to recurse into subdirectories.\n * @return {string[]} An array of paths.\n */\nexports.lookupFiles = function lookupFiles (filepath, extensions, recursive) {\n  var files = [];\n\n  if (!fs.existsSync(filepath)) {\n    if (fs.existsSync(filepath + '.js')) {\n      filepath += '.js';\n    } else {\n      files = glob.sync(filepath);\n      if (!files.length) {\n        throw new Error(\"cannot resolve path (or pattern) '\" + filepath + \"'\");\n      }\n      return files;\n    }\n  }\n\n  try {\n    var stat = fs.statSync(filepath);\n    if (stat.isFile()) {\n      return filepath;\n    }\n  } catch (err) {\n    // ignore error\n    return;\n  }\n\n  fs.readdirSync(filepath).forEach(function (file) {\n    file = path.join(filepath, file);\n    try {\n      var stat = fs.statSync(file);\n      if (stat.isDirectory()) {\n        if (recursive) {\n          files = files.concat(lookupFiles(file, extensions, recursive));\n        }\n        return;\n      }\n    } catch (err) {\n      // ignore error\n      return;\n    }\n    var re = new RegExp('\\\\.(?:' + extensions.join('|') + ')$');\n    if (!stat.isFile() || !re.test(file) || path.basename(file)[0] === '.') {\n      return;\n    }\n    files.push(file);\n  });\n\n  return files;\n};\n\n/**\n * Generate an undefined error with a message warning the user.\n *\n * @return {Error}\n */\n\nexports.undefinedError = function () {\n  return new Error('Caught undefined error, did you throw without specifying what?');\n};\n\n/**\n * Generate an undefined error if `err` is not defined.\n *\n * @param {Error} err\n * @return {Error}\n */\n\nexports.getError = function (err) {\n  return err || exports.undefinedError();\n};\n\n/**\n * @summary\n * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`)\n * @description\n * When invoking this function you get a filter function that get the Error.stack as an input,\n * and return a prettify output.\n * (i.e: strip Mocha and internal node functions from stack trace).\n * @returns {Function}\n */\nexports.stackTraceFilter = function () {\n  // TODO: Replace with `process.browser`\n  var is = typeof document === 'undefined' ? { node: true } : { browser: true };\n  var slash = path.sep;\n  var cwd;\n  if (is.node) {\n    cwd = process.cwd() + slash;\n  } else {\n    cwd = (typeof location === 'undefined'\n      ? window.location\n      : location).href.replace(/\\/[^/]*$/, '/');\n    slash = '/';\n  }\n\n  function isMochaInternal (line) {\n    return (~line.indexOf('node_modules' + slash + 'mocha' + slash)) ||\n      (~line.indexOf('node_modules' + slash + 'mocha.js')) ||\n      (~line.indexOf('bower_components' + slash + 'mocha.js')) ||\n      (~line.indexOf(slash + 'mocha.js'));\n  }\n\n  function isNodeInternal (line) {\n    return (~line.indexOf('(timers.js:')) ||\n      (~line.indexOf('(events.js:')) ||\n      (~line.indexOf('(node.js:')) ||\n      (~line.indexOf('(module.js:')) ||\n      (~line.indexOf('GeneratorFunctionPrototype.next (native)')) ||\n      false;\n  }\n\n  return function (stack) {\n    stack = stack.split('\\n');\n\n    stack = stack.reduce(function (list, line) {\n      if (isMochaInternal(line)) {\n        return list;\n      }\n\n      if (is.node && isNodeInternal(line)) {\n        return list;\n      }\n\n      // Clean up cwd(absolute)\n      if (/\\(?.+:\\d+:\\d+\\)?$/.test(line)) {\n        line = line.replace('(' + cwd, '(');\n      }\n\n      list.push(line);\n      return list;\n    }, []);\n\n    return stack.join('\\n');\n  };\n};\n\n/**\n * Crude, but effective.\n * @api\n * @param {*} value\n * @returns {boolean} Whether or not `value` is a Promise\n */\nexports.isPromise = function isPromise (value) {\n  return typeof value === 'object' && typeof value.then === 'function';\n};\n\n/**\n * It's a noop.\n * @api\n */\nexports.noop = function () {};\n\n}).call(this,require('_process'),require(\"buffer\").Buffer)\n},{\"_process\":56,\"buffer\":41,\"debug\":43,\"fs\":40,\"glob\":40,\"he\":48,\"path\":40,\"util\":76}],37:[function(require,module,exports){\n'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n},{}],38:[function(require,module,exports){\n\n},{}],39:[function(require,module,exports){\n(function (process){\nvar WritableStream = require('stream').Writable\nvar inherits = require('util').inherits\n\nmodule.exports = BrowserStdout\n\n\ninherits(BrowserStdout, WritableStream)\n\nfunction BrowserStdout(opts) {\n  if (!(this instanceof BrowserStdout)) return new BrowserStdout(opts)\n\n  opts = opts || {}\n  WritableStream.call(this, opts)\n  this.label = (opts.label !== undefined) ? opts.label : 'stdout'\n}\n\nBrowserStdout.prototype._write = function(chunks, encoding, cb) {\n  var output = chunks.toString ? chunks.toString() : chunks\n  if (this.label === false) {\n    console.log(output)\n  } else {\n    console.log(this.label+':', output)\n  }\n  process.nextTick(cb)\n}\n\n}).call(this,require('_process'))\n},{\"_process\":56,\"stream\":71,\"util\":76}],40:[function(require,module,exports){\narguments[4][38][0].apply(exports,arguments)\n},{\"dup\":38}],41:[function(require,module,exports){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('Invalid typed array length')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (isArrayBuffer(value)) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  return fromObject(value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj) {\n    if (isArrayBufferView(obj) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n        return createBuffer(0)\n      }\n      return fromArrayLike(obj)\n    }\n\n    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n      return fromArrayLike(obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (isArrayBufferView(string) || isArrayBuffer(string)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : new Buffer(val, encoding)\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check\n// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166\nfunction isArrayBuffer (obj) {\n  return obj instanceof ArrayBuffer ||\n    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&\n      typeof obj.byteLength === 'number')\n}\n\n// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`\nfunction isArrayBufferView (obj) {\n  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)\n}\n\nfunction numberIsNaN (obj) {\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n},{\"base64-js\":37,\"ieee754\":49}],42:[function(require,module,exports){\n(function (Buffer){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n}).call(this,{\"isBuffer\":require(\"../../is-buffer/index.js\")})\n},{\"../../is-buffer/index.js\":51}],43:[function(require,module,exports){\n(function (process){\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n}).call(this,require('_process'))\n},{\"./debug\":44,\"_process\":56}],44:[function(require,module,exports){\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n},{\"ms\":54}],45:[function(require,module,exports){\n/*!\n\n diff v3.5.0\n\nSoftware License Agreement (BSD License)\n\nCopyright (c) 2009-2015, Kevin Decker <kpdecker@gmail.com>\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of Kevin Decker nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\nCONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\nIN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n@license\n*/\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(false)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JsDiff\"] = factory();\n\telse\n\t\troot[\"JsDiff\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.canonicalize = exports.convertChangesToXML = exports.convertChangesToDMP = exports.merge = exports.parsePatch = exports.applyPatches = exports.applyPatch = exports.createPatch = exports.createTwoFilesPatch = exports.structuredPatch = exports.diffArrays = exports.diffJson = exports.diffCss = exports.diffSentences = exports.diffTrimmedLines = exports.diffLines = exports.diffWordsWithSpace = exports.diffWords = exports.diffChars = exports.Diff = undefined;\n\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_character = __webpack_require__(2) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_word = __webpack_require__(3) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_sentence = __webpack_require__(6) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_css = __webpack_require__(7) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_json = __webpack_require__(8) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_array = __webpack_require__(9) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_apply = __webpack_require__(10) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_merge = __webpack_require__(13) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_create = __webpack_require__(14) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_dmp = __webpack_require__(16) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_xml = __webpack_require__(17) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/* See LICENSE file for terms of use */\n\n\t/*\n\t * Text diff implementation.\n\t *\n\t * This library supports the following APIS:\n\t * JsDiff.diffChars: Character by character diff\n\t * JsDiff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\n\t * JsDiff.diffLines: Line based diff\n\t *\n\t * JsDiff.diffCss: Diff targeted at CSS content\n\t *\n\t * These methods are based on the implementation proposed in\n\t * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\n\t * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\n\t */\n\texports. /*istanbul ignore end*/Diff = _base2['default'];\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffChars = _character.diffChars;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWords = _word.diffWords;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = _word.diffWordsWithSpace;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffLines = _line.diffLines;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = _line.diffTrimmedLines;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffSentences = _sentence.diffSentences;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffCss = _css.diffCss;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffJson = _json.diffJson;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffArrays = _array.diffArrays;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/structuredPatch = _create.structuredPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = _create.createTwoFilesPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = _create.createPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatch = _apply.applyPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = _apply.applyPatches;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/parsePatch = _parse.parsePatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/merge = _merge.merge;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToDMP = _dmp.convertChangesToDMP;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToXML = _xml.convertChangesToXML;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = _json.canonicalize;\n\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports['default'] = /*istanbul ignore end*/Diff;\n\tfunction Diff() {}\n\n\tDiff.prototype = {\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/diff: function diff(oldString, newString) {\n\t    /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\t    var callback = options.callback;\n\t    if (typeof options === 'function') {\n\t      callback = options;\n\t      options = {};\n\t    }\n\t    this.options = options;\n\n\t    var self = this;\n\n\t    function done(value) {\n\t      if (callback) {\n\t        setTimeout(function () {\n\t          callback(undefined, value);\n\t        }, 0);\n\t        return true;\n\t      } else {\n\t        return value;\n\t      }\n\t    }\n\n\t    // Allow subclasses to massage the input prior to running\n\t    oldString = this.castInput(oldString);\n\t    newString = this.castInput(newString);\n\n\t    oldString = this.removeEmpty(this.tokenize(oldString));\n\t    newString = this.removeEmpty(this.tokenize(newString));\n\n\t    var newLen = newString.length,\n\t        oldLen = oldString.length;\n\t    var editLength = 1;\n\t    var maxEditLength = newLen + oldLen;\n\t    var bestPath = [{ newPos: -1, components: [] }];\n\n\t    // Seed editLength = 0, i.e. the content starts with the same values\n\t    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\t    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n\t      // Identity per the equality and tokenizer\n\t      return done([{ value: this.join(newString), count: newString.length }]);\n\t    }\n\n\t    // Main worker method. checks all permutations of a given edit length for acceptance.\n\t    function execEditLength() {\n\t      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n\t        var basePath = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\t        var addPath = bestPath[diagonalPath - 1],\n\t            removePath = bestPath[diagonalPath + 1],\n\t            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\t        if (addPath) {\n\t          // No one else is going to attempt to use this value, clear it\n\t          bestPath[diagonalPath - 1] = undefined;\n\t        }\n\n\t        var canAdd = addPath && addPath.newPos + 1 < newLen,\n\t            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\t        if (!canAdd && !canRemove) {\n\t          // If this path is a terminal then prune\n\t          bestPath[diagonalPath] = undefined;\n\t          continue;\n\t        }\n\n\t        // Select the diagonal that we want to branch from. We select the prior\n\t        // path whose position in the new string is the farthest from the origin\n\t        // and does not pass the bounds of the diff graph\n\t        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n\t          basePath = clonePath(removePath);\n\t          self.pushComponent(basePath.components, undefined, true);\n\t        } else {\n\t          basePath = addPath; // No need to clone, we've pulled it from the list\n\t          basePath.newPos++;\n\t          self.pushComponent(basePath.components, true, undefined);\n\t        }\n\n\t        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n\t        // If we have hit the end of both strings, then we are done\n\t        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n\t          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n\t        } else {\n\t          // Otherwise track this path as a potential candidate and continue.\n\t          bestPath[diagonalPath] = basePath;\n\t        }\n\t      }\n\n\t      editLength++;\n\t    }\n\n\t    // Performs the length of edit iteration. Is a bit fugly as this has to support the\n\t    // sync and async mode which is never fun. Loops over execEditLength until a value\n\t    // is produced.\n\t    if (callback) {\n\t      (function exec() {\n\t        setTimeout(function () {\n\t          // This should not happen, but we want to be safe.\n\t          /* istanbul ignore next */\n\t          if (editLength > maxEditLength) {\n\t            return callback();\n\t          }\n\n\t          if (!execEditLength()) {\n\t            exec();\n\t          }\n\t        }, 0);\n\t      })();\n\t    } else {\n\t      while (editLength <= maxEditLength) {\n\t        var ret = execEditLength();\n\t        if (ret) {\n\t          return ret;\n\t        }\n\t      }\n\t    }\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/pushComponent: function pushComponent(components, added, removed) {\n\t    var last = components[components.length - 1];\n\t    if (last && last.added === added && last.removed === removed) {\n\t      // We need to clone here as the component clone operation is just\n\t      // as shallow array clone\n\t      components[components.length - 1] = { count: last.count + 1, added: added, removed: removed };\n\t    } else {\n\t      components.push({ count: 1, added: added, removed: removed });\n\t    }\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n\t    var newLen = newString.length,\n\t        oldLen = oldString.length,\n\t        newPos = basePath.newPos,\n\t        oldPos = newPos - diagonalPath,\n\t        commonCount = 0;\n\t    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n\t      newPos++;\n\t      oldPos++;\n\t      commonCount++;\n\t    }\n\n\t    if (commonCount) {\n\t      basePath.components.push({ count: commonCount });\n\t    }\n\n\t    basePath.newPos = newPos;\n\t    return oldPos;\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/equals: function equals(left, right) {\n\t    if (this.options.comparator) {\n\t      return this.options.comparator(left, right);\n\t    } else {\n\t      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n\t    }\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/removeEmpty: function removeEmpty(array) {\n\t    var ret = [];\n\t    for (var i = 0; i < array.length; i++) {\n\t      if (array[i]) {\n\t        ret.push(array[i]);\n\t      }\n\t    }\n\t    return ret;\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/castInput: function castInput(value) {\n\t    return value;\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/tokenize: function tokenize(value) {\n\t    return value.split('');\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/join: function join(chars) {\n\t    return chars.join('');\n\t  }\n\t};\n\n\tfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n\t  var componentPos = 0,\n\t      componentLen = components.length,\n\t      newPos = 0,\n\t      oldPos = 0;\n\n\t  for (; componentPos < componentLen; componentPos++) {\n\t    var component = components[componentPos];\n\t    if (!component.removed) {\n\t      if (!component.added && useLongestToken) {\n\t        var value = newString.slice(newPos, newPos + component.count);\n\t        value = value.map(function (value, i) {\n\t          var oldValue = oldString[oldPos + i];\n\t          return oldValue.length > value.length ? oldValue : value;\n\t        });\n\n\t        component.value = diff.join(value);\n\t      } else {\n\t        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n\t      }\n\t      newPos += component.count;\n\n\t      // Common case\n\t      if (!component.added) {\n\t        oldPos += component.count;\n\t      }\n\t    } else {\n\t      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n\t      oldPos += component.count;\n\n\t      // Reverse add and remove so removes are output first to match common convention\n\t      // The diffing algorithm is tied to add then remove output and this is the simplest\n\t      // route to get the desired output with minimal overhead.\n\t      if (componentPos && components[componentPos - 1].added) {\n\t        var tmp = components[componentPos - 1];\n\t        components[componentPos - 1] = components[componentPos];\n\t        components[componentPos] = tmp;\n\t      }\n\t    }\n\t  }\n\n\t  // Special case handle for when one terminal is ignored (i.e. whitespace).\n\t  // For this case we merge the terminal into the prior string and drop the change.\n\t  // This is only available for string mode.\n\t  var lastComponent = components[componentLen - 1];\n\t  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n\t    components[componentLen - 2].value += lastComponent.value;\n\t    components.pop();\n\t  }\n\n\t  return components;\n\t}\n\n\tfunction clonePath(path) {\n\t  return { newPos: path.newPos, components: path.components.slice(0) };\n\t}\n\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.characterDiff = undefined;\n\texports. /*istanbul ignore end*/diffChars = diffChars;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var characterDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/characterDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\tfunction diffChars(oldStr, newStr, options) {\n\t  return characterDiff.diff(oldStr, newStr, options);\n\t}\n\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.wordDiff = undefined;\n\texports. /*istanbul ignore end*/diffWords = diffWords;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = diffWordsWithSpace;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_params = __webpack_require__(4) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/ // Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n\t//\n\t// Ranges and exceptions:\n\t// Latin-1 Supplement, 0080–00FF\n\t//  - U+00D7  × Multiplication sign\n\t//  - U+00F7  ÷ Division sign\n\t// Latin Extended-A, 0100–017F\n\t// Latin Extended-B, 0180–024F\n\t// IPA Extensions, 0250–02AF\n\t// Spacing Modifier Letters, 02B0–02FF\n\t//  - U+02C7  ˇ &#711;  Caron\n\t//  - U+02D8  ˘ &#728;  Breve\n\t//  - U+02D9  ˙ &#729;  Dot Above\n\t//  - U+02DA  ˚ &#730;  Ring Above\n\t//  - U+02DB  ˛ &#731;  Ogonek\n\t//  - U+02DC  ˜ &#732;  Small Tilde\n\t//  - U+02DD  ˝ &#733;  Double Acute Accent\n\t// Latin Extended Additional, 1E00–1EFF\n\tvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\n\n\tvar reWhitespace = /\\S/;\n\n\tvar wordDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/wordDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\twordDiff.equals = function (left, right) {\n\t  if (this.options.ignoreCase) {\n\t    left = left.toLowerCase();\n\t    right = right.toLowerCase();\n\t  }\n\t  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n\t};\n\twordDiff.tokenize = function (value) {\n\t  var tokens = value.split(/(\\s+|\\b)/);\n\n\t  // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\t  for (var i = 0; i < tokens.length - 1; i++) {\n\t    // If we have an empty string in the next field and we have only word chars before and after, merge\n\t    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n\t      tokens[i] += tokens[i + 2];\n\t      tokens.splice(i + 1, 2);\n\t      i--;\n\t    }\n\t  }\n\n\t  return tokens;\n\t};\n\n\tfunction diffWords(oldStr, newStr, options) {\n\t  options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(options, { ignoreWhitespace: true });\n\t  return wordDiff.diff(oldStr, newStr, options);\n\t}\n\n\tfunction diffWordsWithSpace(oldStr, newStr, options) {\n\t  return wordDiff.diff(oldStr, newStr, options);\n\t}\n\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/generateOptions = generateOptions;\n\tfunction generateOptions(options, defaults) {\n\t  if (typeof options === 'function') {\n\t    defaults.callback = options;\n\t  } else if (options) {\n\t    for (var name in options) {\n\t      /* istanbul ignore else */\n\t      if (options.hasOwnProperty(name)) {\n\t        defaults[name] = options[name];\n\t      }\n\t    }\n\t  }\n\t  return defaults;\n\t}\n\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.lineDiff = undefined;\n\texports. /*istanbul ignore end*/diffLines = diffLines;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = diffTrimmedLines;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_params = __webpack_require__(4) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var lineDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/lineDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\tlineDiff.tokenize = function (value) {\n\t  var retLines = [],\n\t      linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n\n\t  // Ignore the final empty token that occurs if the string ends with a new line\n\t  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n\t    linesAndNewlines.pop();\n\t  }\n\n\t  // Merge the content and line separators into single tokens\n\t  for (var i = 0; i < linesAndNewlines.length; i++) {\n\t    var line = linesAndNewlines[i];\n\n\t    if (i % 2 && !this.options.newlineIsToken) {\n\t      retLines[retLines.length - 1] += line;\n\t    } else {\n\t      if (this.options.ignoreWhitespace) {\n\t        line = line.trim();\n\t      }\n\t      retLines.push(line);\n\t    }\n\t  }\n\n\t  return retLines;\n\t};\n\n\tfunction diffLines(oldStr, newStr, callback) {\n\t  return lineDiff.diff(oldStr, newStr, callback);\n\t}\n\tfunction diffTrimmedLines(oldStr, newStr, callback) {\n\t  var options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(callback, { ignoreWhitespace: true });\n\t  return lineDiff.diff(oldStr, newStr, options);\n\t}\n\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.sentenceDiff = undefined;\n\texports. /*istanbul ignore end*/diffSentences = diffSentences;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var sentenceDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/sentenceDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\tsentenceDiff.tokenize = function (value) {\n\t  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n\t};\n\n\tfunction diffSentences(oldStr, newStr, callback) {\n\t  return sentenceDiff.diff(oldStr, newStr, callback);\n\t}\n\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.cssDiff = undefined;\n\texports. /*istanbul ignore end*/diffCss = diffCss;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var cssDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/cssDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\tcssDiff.tokenize = function (value) {\n\t  return value.split(/([{}:;,]|\\s+)/);\n\t};\n\n\tfunction diffCss(oldStr, newStr, callback) {\n\t  return cssDiff.diff(oldStr, newStr, callback);\n\t}\n\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.jsonDiff = undefined;\n\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n\texports. /*istanbul ignore end*/diffJson = diffJson;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = canonicalize;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var objectPrototypeToString = Object.prototype.toString;\n\n\tvar jsonDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/jsonDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\t// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n\t// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\tjsonDiff.useLongestToken = true;\n\n\tjsonDiff.tokenize = /*istanbul ignore start*/_line.lineDiff /*istanbul ignore end*/.tokenize;\n\tjsonDiff.castInput = function (value) {\n\t  /*istanbul ignore start*/var _options = /*istanbul ignore end*/this.options,\n\t      undefinedReplacement = _options.undefinedReplacement,\n\t      _options$stringifyRep = _options.stringifyReplacer,\n\t      stringifyReplacer = _options$stringifyRep === undefined ? function (k, v) /*istanbul ignore start*/{\n\t    return (/*istanbul ignore end*/typeof v === 'undefined' ? undefinedReplacement : v\n\t    );\n\t  } : _options$stringifyRep;\n\n\n\t  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n\t};\n\tjsonDiff.equals = function (left, right) {\n\t  return (/*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'))\n\t  );\n\t};\n\n\tfunction diffJson(oldObj, newObj, options) {\n\t  return jsonDiff.diff(oldObj, newObj, options);\n\t}\n\n\t// This function handles the presence of circular references by bailing out when encountering an\n\t// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\tfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n\t  stack = stack || [];\n\t  replacementStack = replacementStack || [];\n\n\t  if (replacer) {\n\t    obj = replacer(key, obj);\n\t  }\n\n\t  var i = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\n\t  for (i = 0; i < stack.length; i += 1) {\n\t    if (stack[i] === obj) {\n\t      return replacementStack[i];\n\t    }\n\t  }\n\n\t  var canonicalizedObj = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\n\t  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n\t    stack.push(obj);\n\t    canonicalizedObj = new Array(obj.length);\n\t    replacementStack.push(canonicalizedObj);\n\t    for (i = 0; i < obj.length; i += 1) {\n\t      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n\t    }\n\t    stack.pop();\n\t    replacementStack.pop();\n\t    return canonicalizedObj;\n\t  }\n\n\t  if (obj && obj.toJSON) {\n\t    obj = obj.toJSON();\n\t  }\n\n\t  if ( /*istanbul ignore start*/(typeof /*istanbul ignore end*/obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null) {\n\t    stack.push(obj);\n\t    canonicalizedObj = {};\n\t    replacementStack.push(canonicalizedObj);\n\t    var sortedKeys = [],\n\t        _key = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\t    for (_key in obj) {\n\t      /* istanbul ignore else */\n\t      if (obj.hasOwnProperty(_key)) {\n\t        sortedKeys.push(_key);\n\t      }\n\t    }\n\t    sortedKeys.sort();\n\t    for (i = 0; i < sortedKeys.length; i += 1) {\n\t      _key = sortedKeys[i];\n\t      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n\t    }\n\t    stack.pop();\n\t    replacementStack.pop();\n\t  } else {\n\t    canonicalizedObj = obj;\n\t  }\n\t  return canonicalizedObj;\n\t}\n\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.arrayDiff = undefined;\n\texports. /*istanbul ignore end*/diffArrays = diffArrays;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var arrayDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/arrayDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\tarrayDiff.tokenize = function (value) {\n\t  return value.slice();\n\t};\n\tarrayDiff.join = arrayDiff.removeEmpty = function (value) {\n\t  return value;\n\t};\n\n\tfunction diffArrays(oldArr, newArr, callback) {\n\t  return arrayDiff.diff(oldArr, newArr, callback);\n\t}\n\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/applyPatch = applyPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = applyPatches;\n\n\tvar /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_distanceIterator = __webpack_require__(12) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _distanceIterator2 = _interopRequireDefault(_distanceIterator);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/function applyPatch(source, uniDiff) {\n\t  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\t  if (typeof uniDiff === 'string') {\n\t    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);\n\t  }\n\n\t  if (Array.isArray(uniDiff)) {\n\t    if (uniDiff.length > 1) {\n\t      throw new Error('applyPatch only works with a single input.');\n\t    }\n\n\t    uniDiff = uniDiff[0];\n\t  }\n\n\t  // Apply the diff to the input\n\t  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n\t      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n\t      hunks = uniDiff.hunks,\n\t      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) /*istanbul ignore start*/{\n\t    return (/*istanbul ignore end*/line === patchContent\n\t    );\n\t  },\n\t      errorCount = 0,\n\t      fuzzFactor = options.fuzzFactor || 0,\n\t      minLine = 0,\n\t      offset = 0,\n\t      removeEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,\n\t      addEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\n\t  /**\n\t   * Checks if the hunk exactly fits on the provided location\n\t   */\n\t  function hunkFits(hunk, toPos) {\n\t    for (var j = 0; j < hunk.lines.length; j++) {\n\t      var line = hunk.lines[j],\n\t          operation = line.length > 0 ? line[0] : ' ',\n\t          content = line.length > 0 ? line.substr(1) : line;\n\n\t      if (operation === ' ' || operation === '-') {\n\t        // Context sanity check\n\t        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n\t          errorCount++;\n\n\t          if (errorCount > fuzzFactor) {\n\t            return false;\n\t          }\n\t        }\n\t        toPos++;\n\t      }\n\t    }\n\n\t    return true;\n\t  }\n\n\t  // Search best fit offsets for each hunk based on the previous ones\n\t  for (var i = 0; i < hunks.length; i++) {\n\t    var hunk = hunks[i],\n\t        maxLine = lines.length - hunk.oldLines,\n\t        localOffset = 0,\n\t        toPos = offset + hunk.oldStart - 1;\n\n\t    var iterator = /*istanbul ignore start*/(0, _distanceIterator2['default']) /*istanbul ignore end*/(toPos, minLine, maxLine);\n\n\t    for (; localOffset !== undefined; localOffset = iterator()) {\n\t      if (hunkFits(hunk, toPos + localOffset)) {\n\t        hunk.offset = offset += localOffset;\n\t        break;\n\t      }\n\t    }\n\n\t    if (localOffset === undefined) {\n\t      return false;\n\t    }\n\n\t    // Set lower text limit to end of the current hunk, so next ones don't try\n\t    // to fit over already patched text\n\t    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n\t  }\n\n\t  // Apply patch hunks\n\t  var diffOffset = 0;\n\t  for (var _i = 0; _i < hunks.length; _i++) {\n\t    var _hunk = hunks[_i],\n\t        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\t    diffOffset += _hunk.newLines - _hunk.oldLines;\n\n\t    if (_toPos < 0) {\n\t      // Creating a new file\n\t      _toPos = 0;\n\t    }\n\n\t    for (var j = 0; j < _hunk.lines.length; j++) {\n\t      var line = _hunk.lines[j],\n\t          operation = line.length > 0 ? line[0] : ' ',\n\t          content = line.length > 0 ? line.substr(1) : line,\n\t          delimiter = _hunk.linedelimiters[j];\n\n\t      if (operation === ' ') {\n\t        _toPos++;\n\t      } else if (operation === '-') {\n\t        lines.splice(_toPos, 1);\n\t        delimiters.splice(_toPos, 1);\n\t        /* istanbul ignore else */\n\t      } else if (operation === '+') {\n\t        lines.splice(_toPos, 0, content);\n\t        delimiters.splice(_toPos, 0, delimiter);\n\t        _toPos++;\n\t      } else if (operation === '\\\\') {\n\t        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\t        if (previousOperation === '+') {\n\t          removeEOFNL = true;\n\t        } else if (previousOperation === '-') {\n\t          addEOFNL = true;\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  // Handle EOFNL insertion/removal\n\t  if (removeEOFNL) {\n\t    while (!lines[lines.length - 1]) {\n\t      lines.pop();\n\t      delimiters.pop();\n\t    }\n\t  } else if (addEOFNL) {\n\t    lines.push('');\n\t    delimiters.push('\\n');\n\t  }\n\t  for (var _k = 0; _k < lines.length - 1; _k++) {\n\t    lines[_k] = lines[_k] + delimiters[_k];\n\t  }\n\t  return lines.join('');\n\t}\n\n\t// Wrapper that supports multiple file patches via callbacks.\n\tfunction applyPatches(uniDiff, options) {\n\t  if (typeof uniDiff === 'string') {\n\t    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);\n\t  }\n\n\t  var currentIndex = 0;\n\t  function processIndex() {\n\t    var index = uniDiff[currentIndex++];\n\t    if (!index) {\n\t      return options.complete();\n\t    }\n\n\t    options.loadFile(index, function (err, data) {\n\t      if (err) {\n\t        return options.complete(err);\n\t      }\n\n\t      var updatedContent = applyPatch(data, index, options);\n\t      options.patched(index, updatedContent, function (err) {\n\t        if (err) {\n\t          return options.complete(err);\n\t        }\n\n\t        processIndex();\n\t      });\n\t    });\n\t  }\n\t  processIndex();\n\t}\n\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/parsePatch = parsePatch;\n\tfunction parsePatch(uniDiff) {\n\t  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n\t      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n\t      list = [],\n\t      i = 0;\n\n\t  function parseIndex() {\n\t    var index = {};\n\t    list.push(index);\n\n\t    // Parse diff metadata\n\t    while (i < diffstr.length) {\n\t      var line = diffstr[i];\n\n\t      // File header found, end parsing diff metadata\n\t      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n\t        break;\n\t      }\n\n\t      // Diff index\n\t      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\t      if (header) {\n\t        index.index = header[1];\n\t      }\n\n\t      i++;\n\t    }\n\n\t    // Parse file headers if they are defined. Unified diff requires them, but\n\t    // there's no technical issues to have an isolated hunk without file header\n\t    parseFileHeader(index);\n\t    parseFileHeader(index);\n\n\t    // Parse hunks\n\t    index.hunks = [];\n\n\t    while (i < diffstr.length) {\n\t      var _line = diffstr[i];\n\n\t      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n\t        break;\n\t      } else if (/^@@/.test(_line)) {\n\t        index.hunks.push(parseHunk());\n\t      } else if (_line && options.strict) {\n\t        // Ignore unexpected content unless in strict mode\n\t        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n\t      } else {\n\t        i++;\n\t      }\n\t    }\n\t  }\n\n\t  // Parses the --- and +++ headers, if none are found, no lines\n\t  // are consumed.\n\t  function parseFileHeader(index) {\n\t    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\t    if (fileHeader) {\n\t      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n\t      var data = fileHeader[2].split('\\t', 2);\n\t      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\t      if (/^\".*\"$/.test(fileName)) {\n\t        fileName = fileName.substr(1, fileName.length - 2);\n\t      }\n\t      index[keyPrefix + 'FileName'] = fileName;\n\t      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n\n\t      i++;\n\t    }\n\t  }\n\n\t  // Parses a hunk\n\t  // This assumes that we are at the start of a hunk.\n\t  function parseHunk() {\n\t    var chunkHeaderIndex = i,\n\t        chunkHeaderLine = diffstr[i++],\n\t        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n\n\t    var hunk = {\n\t      oldStart: +chunkHeader[1],\n\t      oldLines: +chunkHeader[2] || 1,\n\t      newStart: +chunkHeader[3],\n\t      newLines: +chunkHeader[4] || 1,\n\t      lines: [],\n\t      linedelimiters: []\n\t    };\n\n\t    var addCount = 0,\n\t        removeCount = 0;\n\t    for (; i < diffstr.length; i++) {\n\t      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n\t      // But they could be the header for the next file. Therefore prune such cases out.\n\t      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n\t        break;\n\t      }\n\t      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n\t      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n\t        hunk.lines.push(diffstr[i]);\n\t        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n\t        if (operation === '+') {\n\t          addCount++;\n\t        } else if (operation === '-') {\n\t          removeCount++;\n\t        } else if (operation === ' ') {\n\t          addCount++;\n\t          removeCount++;\n\t        }\n\t      } else {\n\t        break;\n\t      }\n\t    }\n\n\t    // Handle the empty block count case\n\t    if (!addCount && hunk.newLines === 1) {\n\t      hunk.newLines = 0;\n\t    }\n\t    if (!removeCount && hunk.oldLines === 1) {\n\t      hunk.oldLines = 0;\n\t    }\n\n\t    // Perform optional sanity checking\n\t    if (options.strict) {\n\t      if (addCount !== hunk.newLines) {\n\t        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n\t      }\n\t      if (removeCount !== hunk.oldLines) {\n\t        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n\t      }\n\t    }\n\n\t    return hunk;\n\t  }\n\n\t  while (i < diffstr.length) {\n\t    parseIndex();\n\t  }\n\n\t  return list;\n\t}\n\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/\"use strict\";\n\n\texports.__esModule = true;\n\n\texports[\"default\"] = /*istanbul ignore end*/function (start, minLine, maxLine) {\n\t  var wantForward = true,\n\t      backwardExhausted = false,\n\t      forwardExhausted = false,\n\t      localOffset = 1;\n\n\t  return function iterator() {\n\t    if (wantForward && !forwardExhausted) {\n\t      if (backwardExhausted) {\n\t        localOffset++;\n\t      } else {\n\t        wantForward = false;\n\t      }\n\n\t      // Check if trying to fit beyond text length, and if not, check it fits\n\t      // after offset location (or desired location on first iteration)\n\t      if (start + localOffset <= maxLine) {\n\t        return localOffset;\n\t      }\n\n\t      forwardExhausted = true;\n\t    }\n\n\t    if (!backwardExhausted) {\n\t      if (!forwardExhausted) {\n\t        wantForward = true;\n\t      }\n\n\t      // Check if trying to fit before text beginning, and if not, check it fits\n\t      // before offset location\n\t      if (minLine <= start - localOffset) {\n\t        return -localOffset++;\n\t      }\n\n\t      backwardExhausted = true;\n\t      return iterator();\n\t    }\n\n\t    // We tried to fit hunk before text beginning and beyond text length, then\n\t    // hunk can't fit on the text. Return undefined\n\t  };\n\t};\n\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/calcLineCount = calcLineCount;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/merge = merge;\n\n\tvar /*istanbul ignore start*/_create = __webpack_require__(14) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_array = __webpack_require__(15) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\t/*istanbul ignore end*/function calcLineCount(hunk) {\n\t  /*istanbul ignore start*/var _calcOldNewLineCount = /*istanbul ignore end*/calcOldNewLineCount(hunk.lines),\n\t      oldLines = _calcOldNewLineCount.oldLines,\n\t      newLines = _calcOldNewLineCount.newLines;\n\n\t  if (oldLines !== undefined) {\n\t    hunk.oldLines = oldLines;\n\t  } else {\n\t    delete hunk.oldLines;\n\t  }\n\n\t  if (newLines !== undefined) {\n\t    hunk.newLines = newLines;\n\t  } else {\n\t    delete hunk.newLines;\n\t  }\n\t}\n\n\tfunction merge(mine, theirs, base) {\n\t  mine = loadPatch(mine, base);\n\t  theirs = loadPatch(theirs, base);\n\n\t  var ret = {};\n\n\t  // For index we just let it pass through as it doesn't have any necessary meaning.\n\t  // Leaving sanity checks on this to the API consumer that may know more about the\n\t  // meaning in their own context.\n\t  if (mine.index || theirs.index) {\n\t    ret.index = mine.index || theirs.index;\n\t  }\n\n\t  if (mine.newFileName || theirs.newFileName) {\n\t    if (!fileNameChanged(mine)) {\n\t      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n\t      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n\t      ret.newFileName = theirs.newFileName || mine.newFileName;\n\t      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n\t      ret.newHeader = theirs.newHeader || mine.newHeader;\n\t    } else if (!fileNameChanged(theirs)) {\n\t      // No header or no change in theirs, use ours\n\t      ret.oldFileName = mine.oldFileName;\n\t      ret.newFileName = mine.newFileName;\n\t      ret.oldHeader = mine.oldHeader;\n\t      ret.newHeader = mine.newHeader;\n\t    } else {\n\t      // Both changed... figure it out\n\t      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n\t      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n\t      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n\t      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n\t    }\n\t  }\n\n\t  ret.hunks = [];\n\n\t  var mineIndex = 0,\n\t      theirsIndex = 0,\n\t      mineOffset = 0,\n\t      theirsOffset = 0;\n\n\t  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n\t    var mineCurrent = mine.hunks[mineIndex] || { oldStart: Infinity },\n\t        theirsCurrent = theirs.hunks[theirsIndex] || { oldStart: Infinity };\n\n\t    if (hunkBefore(mineCurrent, theirsCurrent)) {\n\t      // This patch does not overlap with any of the others, yay.\n\t      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n\t      mineIndex++;\n\t      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n\t    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n\t      // This patch does not overlap with any of the others, yay.\n\t      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n\t      theirsIndex++;\n\t      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n\t    } else {\n\t      // Overlap, merge as best we can\n\t      var mergedHunk = {\n\t        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n\t        oldLines: 0,\n\t        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n\t        newLines: 0,\n\t        lines: []\n\t      };\n\t      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n\t      theirsIndex++;\n\t      mineIndex++;\n\n\t      ret.hunks.push(mergedHunk);\n\t    }\n\t  }\n\n\t  return ret;\n\t}\n\n\tfunction loadPatch(param, base) {\n\t  if (typeof param === 'string') {\n\t    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n\t      return (/*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(param)[0]\n\t      );\n\t    }\n\n\t    if (!base) {\n\t      throw new Error('Must provide a base reference or pass in a patch');\n\t    }\n\t    return (/*istanbul ignore start*/(0, _create.structuredPatch) /*istanbul ignore end*/(undefined, undefined, base, param)\n\t    );\n\t  }\n\n\t  return param;\n\t}\n\n\tfunction fileNameChanged(patch) {\n\t  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n\t}\n\n\tfunction selectField(index, mine, theirs) {\n\t  if (mine === theirs) {\n\t    return mine;\n\t  } else {\n\t    index.conflict = true;\n\t    return { mine: mine, theirs: theirs };\n\t  }\n\t}\n\n\tfunction hunkBefore(test, check) {\n\t  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n\t}\n\n\tfunction cloneHunk(hunk, offset) {\n\t  return {\n\t    oldStart: hunk.oldStart, oldLines: hunk.oldLines,\n\t    newStart: hunk.newStart + offset, newLines: hunk.newLines,\n\t    lines: hunk.lines\n\t  };\n\t}\n\n\tfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n\t  // This will generally result in a conflicted hunk, but there are cases where the context\n\t  // is the only overlap where we can successfully merge the content here.\n\t  var mine = { offset: mineOffset, lines: mineLines, index: 0 },\n\t      their = { offset: theirOffset, lines: theirLines, index: 0 };\n\n\t  // Handle any leading content\n\t  insertLeading(hunk, mine, their);\n\t  insertLeading(hunk, their, mine);\n\n\t  // Now in the overlap content. Scan through and select the best changes from each.\n\t  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n\t    var mineCurrent = mine.lines[mine.index],\n\t        theirCurrent = their.lines[their.index];\n\n\t    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n\t      // Both modified ...\n\t      mutualChange(hunk, mine, their);\n\t    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n\t      /*istanbul ignore start*/var _hunk$lines;\n\n\t      /*istanbul ignore end*/ // Mine inserted\n\t      /*istanbul ignore start*/(_hunk$lines = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/collectChange(mine)));\n\t    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n\t      /*istanbul ignore start*/var _hunk$lines2;\n\n\t      /*istanbul ignore end*/ // Theirs inserted\n\t      /*istanbul ignore start*/(_hunk$lines2 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/collectChange(their)));\n\t    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n\t      // Mine removed or edited\n\t      removal(hunk, mine, their);\n\t    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n\t      // Their removed or edited\n\t      removal(hunk, their, mine, true);\n\t    } else if (mineCurrent === theirCurrent) {\n\t      // Context identity\n\t      hunk.lines.push(mineCurrent);\n\t      mine.index++;\n\t      their.index++;\n\t    } else {\n\t      // Context mismatch\n\t      conflict(hunk, collectChange(mine), collectChange(their));\n\t    }\n\t  }\n\n\t  // Now push anything that may be remaining\n\t  insertTrailing(hunk, mine);\n\t  insertTrailing(hunk, their);\n\n\t  calcLineCount(hunk);\n\t}\n\n\tfunction mutualChange(hunk, mine, their) {\n\t  var myChanges = collectChange(mine),\n\t      theirChanges = collectChange(their);\n\n\t  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n\t    // Special case for remove changes that are supersets of one another\n\t    if ( /*istanbul ignore start*/(0, _array.arrayStartsWith) /*istanbul ignore end*/(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n\t      /*istanbul ignore start*/var _hunk$lines3;\n\n\t      /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines3 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/myChanges));\n\t      return;\n\t    } else if ( /*istanbul ignore start*/(0, _array.arrayStartsWith) /*istanbul ignore end*/(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n\t      /*istanbul ignore start*/var _hunk$lines4;\n\n\t      /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines4 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines4 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/theirChanges));\n\t      return;\n\t    }\n\t  } else if ( /*istanbul ignore start*/(0, _array.arrayEqual) /*istanbul ignore end*/(myChanges, theirChanges)) {\n\t    /*istanbul ignore start*/var _hunk$lines5;\n\n\t    /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines5 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines5 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/myChanges));\n\t    return;\n\t  }\n\n\t  conflict(hunk, myChanges, theirChanges);\n\t}\n\n\tfunction removal(hunk, mine, their, swap) {\n\t  var myChanges = collectChange(mine),\n\t      theirChanges = collectContext(their, myChanges);\n\t  if (theirChanges.merged) {\n\t    /*istanbul ignore start*/var _hunk$lines6;\n\n\t    /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines6 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines6 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/theirChanges.merged));\n\t  } else {\n\t    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n\t  }\n\t}\n\n\tfunction conflict(hunk, mine, their) {\n\t  hunk.conflict = true;\n\t  hunk.lines.push({\n\t    conflict: true,\n\t    mine: mine,\n\t    theirs: their\n\t  });\n\t}\n\n\tfunction insertLeading(hunk, insert, their) {\n\t  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n\t    var line = insert.lines[insert.index++];\n\t    hunk.lines.push(line);\n\t    insert.offset++;\n\t  }\n\t}\n\tfunction insertTrailing(hunk, insert) {\n\t  while (insert.index < insert.lines.length) {\n\t    var line = insert.lines[insert.index++];\n\t    hunk.lines.push(line);\n\t  }\n\t}\n\n\tfunction collectChange(state) {\n\t  var ret = [],\n\t      operation = state.lines[state.index][0];\n\t  while (state.index < state.lines.length) {\n\t    var line = state.lines[state.index];\n\n\t    // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\t    if (operation === '-' && line[0] === '+') {\n\t      operation = '+';\n\t    }\n\n\t    if (operation === line[0]) {\n\t      ret.push(line);\n\t      state.index++;\n\t    } else {\n\t      break;\n\t    }\n\t  }\n\n\t  return ret;\n\t}\n\tfunction collectContext(state, matchChanges) {\n\t  var changes = [],\n\t      merged = [],\n\t      matchIndex = 0,\n\t      contextChanges = false,\n\t      conflicted = false;\n\t  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n\t    var change = state.lines[state.index],\n\t        match = matchChanges[matchIndex];\n\n\t    // Once we've hit our add, then we are done\n\t    if (match[0] === '+') {\n\t      break;\n\t    }\n\n\t    contextChanges = contextChanges || change[0] !== ' ';\n\n\t    merged.push(match);\n\t    matchIndex++;\n\n\t    // Consume any additions in the other block as a conflict to attempt\n\t    // to pull in the remaining context after this\n\t    if (change[0] === '+') {\n\t      conflicted = true;\n\n\t      while (change[0] === '+') {\n\t        changes.push(change);\n\t        change = state.lines[++state.index];\n\t      }\n\t    }\n\n\t    if (match.substr(1) === change.substr(1)) {\n\t      changes.push(change);\n\t      state.index++;\n\t    } else {\n\t      conflicted = true;\n\t    }\n\t  }\n\n\t  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n\t    conflicted = true;\n\t  }\n\n\t  if (conflicted) {\n\t    return changes;\n\t  }\n\n\t  while (matchIndex < matchChanges.length) {\n\t    merged.push(matchChanges[matchIndex++]);\n\t  }\n\n\t  return {\n\t    merged: merged,\n\t    changes: changes\n\t  };\n\t}\n\n\tfunction allRemoves(changes) {\n\t  return changes.reduce(function (prev, change) {\n\t    return prev && change[0] === '-';\n\t  }, true);\n\t}\n\tfunction skipRemoveSuperset(state, removeChanges, delta) {\n\t  for (var i = 0; i < delta; i++) {\n\t    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\t    if (state.lines[state.index + i] !== ' ' + changeContent) {\n\t      return false;\n\t    }\n\t  }\n\n\t  state.index += delta;\n\t  return true;\n\t}\n\n\tfunction calcOldNewLineCount(lines) {\n\t  var oldLines = 0;\n\t  var newLines = 0;\n\n\t  lines.forEach(function (line) {\n\t    if (typeof line !== 'string') {\n\t      var myCount = calcOldNewLineCount(line.mine);\n\t      var theirCount = calcOldNewLineCount(line.theirs);\n\n\t      if (oldLines !== undefined) {\n\t        if (myCount.oldLines === theirCount.oldLines) {\n\t          oldLines += myCount.oldLines;\n\t        } else {\n\t          oldLines = undefined;\n\t        }\n\t      }\n\n\t      if (newLines !== undefined) {\n\t        if (myCount.newLines === theirCount.newLines) {\n\t          newLines += myCount.newLines;\n\t        } else {\n\t          newLines = undefined;\n\t        }\n\t      }\n\t    } else {\n\t      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n\t        newLines++;\n\t      }\n\t      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n\t        oldLines++;\n\t      }\n\t    }\n\t  });\n\n\t  return { oldLines: oldLines, newLines: newLines };\n\t}\n\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/structuredPatch = structuredPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = createTwoFilesPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = createPatch;\n\n\tvar /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\t/*istanbul ignore end*/function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n\t  if (!options) {\n\t    options = {};\n\t  }\n\t  if (typeof options.context === 'undefined') {\n\t    options.context = 4;\n\t  }\n\n\t  var diff = /*istanbul ignore start*/(0, _line.diffLines) /*istanbul ignore end*/(oldStr, newStr, options);\n\t  diff.push({ value: '', lines: [] }); // Append an empty value to make cleanup easier\n\n\t  function contextLines(lines) {\n\t    return lines.map(function (entry) {\n\t      return ' ' + entry;\n\t    });\n\t  }\n\n\t  var hunks = [];\n\t  var oldRangeStart = 0,\n\t      newRangeStart = 0,\n\t      curRange = [],\n\t      oldLine = 1,\n\t      newLine = 1;\n\n\t  /*istanbul ignore start*/var _loop = function _loop( /*istanbul ignore end*/i) {\n\t    var current = diff[i],\n\t        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n\t    current.lines = lines;\n\n\t    if (current.added || current.removed) {\n\t      /*istanbul ignore start*/var _curRange;\n\n\t      /*istanbul ignore end*/ // If we have previous context, start with that\n\t      if (!oldRangeStart) {\n\t        var prev = diff[i - 1];\n\t        oldRangeStart = oldLine;\n\t        newRangeStart = newLine;\n\n\t        if (prev) {\n\t          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n\t          oldRangeStart -= curRange.length;\n\t          newRangeStart -= curRange.length;\n\t        }\n\t      }\n\n\t      // Output our changes\n\t      /*istanbul ignore start*/(_curRange = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/lines.map(function (entry) {\n\t        return (current.added ? '+' : '-') + entry;\n\t      })));\n\n\t      // Track the updated file position\n\t      if (current.added) {\n\t        newLine += lines.length;\n\t      } else {\n\t        oldLine += lines.length;\n\t      }\n\t    } else {\n\t      // Identical context lines. Track line changes\n\t      if (oldRangeStart) {\n\t        // Close out any changes that have been output (or join overlapping)\n\t        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n\t          /*istanbul ignore start*/var _curRange2;\n\n\t          /*istanbul ignore end*/ // Overlapping\n\t          /*istanbul ignore start*/(_curRange2 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines)));\n\t        } else {\n\t          /*istanbul ignore start*/var _curRange3;\n\n\t          /*istanbul ignore end*/ // end the range and output\n\t          var contextSize = Math.min(lines.length, options.context);\n\t          /*istanbul ignore start*/(_curRange3 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines.slice(0, contextSize))));\n\n\t          var hunk = {\n\t            oldStart: oldRangeStart,\n\t            oldLines: oldLine - oldRangeStart + contextSize,\n\t            newStart: newRangeStart,\n\t            newLines: newLine - newRangeStart + contextSize,\n\t            lines: curRange\n\t          };\n\t          if (i >= diff.length - 2 && lines.length <= options.context) {\n\t            // EOF is inside this hunk\n\t            var oldEOFNewline = /\\n$/.test(oldStr);\n\t            var newEOFNewline = /\\n$/.test(newStr);\n\t            if (lines.length == 0 && !oldEOFNewline) {\n\t              // special case: old has no eol and no trailing context; no-nl can end up before adds\n\t              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n\t            } else if (!oldEOFNewline || !newEOFNewline) {\n\t              curRange.push('\\\\ No newline at end of file');\n\t            }\n\t          }\n\t          hunks.push(hunk);\n\n\t          oldRangeStart = 0;\n\t          newRangeStart = 0;\n\t          curRange = [];\n\t        }\n\t      }\n\t      oldLine += lines.length;\n\t      newLine += lines.length;\n\t    }\n\t  };\n\n\t  for (var i = 0; i < diff.length; i++) {\n\t    /*istanbul ignore start*/_loop( /*istanbul ignore end*/i);\n\t  }\n\n\t  return {\n\t    oldFileName: oldFileName, newFileName: newFileName,\n\t    oldHeader: oldHeader, newHeader: newHeader,\n\t    hunks: hunks\n\t  };\n\t}\n\n\tfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n\t  var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);\n\n\t  var ret = [];\n\t  if (oldFileName == newFileName) {\n\t    ret.push('Index: ' + oldFileName);\n\t  }\n\t  ret.push('===================================================================');\n\t  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n\t  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n\t  for (var i = 0; i < diff.hunks.length; i++) {\n\t    var hunk = diff.hunks[i];\n\t    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n\t    ret.push.apply(ret, hunk.lines);\n\t  }\n\n\t  return ret.join('\\n') + '\\n';\n\t}\n\n\tfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n\t  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n\t}\n\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/\"use strict\";\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/arrayEqual = arrayEqual;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/arrayStartsWith = arrayStartsWith;\n\tfunction arrayEqual(a, b) {\n\t  if (a.length !== b.length) {\n\t    return false;\n\t  }\n\n\t  return arrayStartsWith(a, b);\n\t}\n\n\tfunction arrayStartsWith(array, start) {\n\t  if (start.length > array.length) {\n\t    return false;\n\t  }\n\n\t  for (var i = 0; i < start.length; i++) {\n\t    if (start[i] !== array[i]) {\n\t      return false;\n\t    }\n\t  }\n\n\t  return true;\n\t}\n\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/\"use strict\";\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/convertChangesToDMP = convertChangesToDMP;\n\t// See: http://code.google.com/p/google-diff-match-patch/wiki/API\n\tfunction convertChangesToDMP(changes) {\n\t  var ret = [],\n\t      change = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,\n\t      operation = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\t  for (var i = 0; i < changes.length; i++) {\n\t    change = changes[i];\n\t    if (change.added) {\n\t      operation = 1;\n\t    } else if (change.removed) {\n\t      operation = -1;\n\t    } else {\n\t      operation = 0;\n\t    }\n\n\t    ret.push([operation, change.value]);\n\t  }\n\t  return ret;\n\t}\n\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/convertChangesToXML = convertChangesToXML;\n\tfunction convertChangesToXML(changes) {\n\t  var ret = [];\n\t  for (var i = 0; i < changes.length; i++) {\n\t    var change = changes[i];\n\t    if (change.added) {\n\t      ret.push('<ins>');\n\t    } else if (change.removed) {\n\t      ret.push('<del>');\n\t    }\n\n\t    ret.push(escapeHTML(change.value));\n\n\t    if (change.added) {\n\t      ret.push('</ins>');\n\t    } else if (change.removed) {\n\t      ret.push('</del>');\n\t    }\n\t  }\n\t  return ret.join('');\n\t}\n\n\tfunction escapeHTML(s) {\n\t  var n = s;\n\t  n = n.replace(/&/g, '&amp;');\n\t  n = n.replace(/</g, '&lt;');\n\t  n = n.replace(/>/g, '&gt;');\n\t  n = n.replace(/\"/g, '&quot;');\n\n\t  return n;\n\t}\n\n\n\n/***/ })\n/******/ ])\n});\n;\n},{}],46:[function(require,module,exports){\n'use strict';\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(matchOperatorsRe, '\\\\$&');\n};\n\n},{}],47:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],48:[function(require,module,exports){\n(function (global){\n/*! https://mths.be/he v1.1.1 by @mathias | MIT license */\n;(function(root) {\n\n\t// Detect free variables `exports`.\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`.\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`.\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t// All astral symbols.\n\tvar regexAstralSymbols = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\t// All ASCII symbols (not just printable ASCII) except those listed in the\n\t// first column of the overrides table.\n\t// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides\n\tvar regexAsciiWhitelist = /[\\x01-\\x7F]/g;\n\t// All BMP symbols that are not ASCII newlines, printable ASCII symbols, or\n\t// code points listed in the first column of the overrides table on\n\t// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.\n\tvar regexBmpWhitelist = /[\\x01-\\t\\x0B\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g;\n\n\tvar regexEncodeNonAscii = /<\\u20D2|=\\u20E5|>\\u20D2|\\u205F\\u200A|\\u219D\\u0338|\\u2202\\u0338|\\u2220\\u20D2|\\u2229\\uFE00|\\u222A\\uFE00|\\u223C\\u20D2|\\u223D\\u0331|\\u223E\\u0333|\\u2242\\u0338|\\u224B\\u0338|\\u224D\\u20D2|\\u224E\\u0338|\\u224F\\u0338|\\u2250\\u0338|\\u2261\\u20E5|\\u2264\\u20D2|\\u2265\\u20D2|\\u2266\\u0338|\\u2267\\u0338|\\u2268\\uFE00|\\u2269\\uFE00|\\u226A\\u0338|\\u226A\\u20D2|\\u226B\\u0338|\\u226B\\u20D2|\\u227F\\u0338|\\u2282\\u20D2|\\u2283\\u20D2|\\u228A\\uFE00|\\u228B\\uFE00|\\u228F\\u0338|\\u2290\\u0338|\\u2293\\uFE00|\\u2294\\uFE00|\\u22B4\\u20D2|\\u22B5\\u20D2|\\u22D8\\u0338|\\u22D9\\u0338|\\u22DA\\uFE00|\\u22DB\\uFE00|\\u22F5\\u0338|\\u22F9\\u0338|\\u2933\\u0338|\\u29CF\\u0338|\\u29D0\\u0338|\\u2A6D\\u0338|\\u2A70\\u0338|\\u2A7D\\u0338|\\u2A7E\\u0338|\\u2AA1\\u0338|\\u2AA2\\u0338|\\u2AAC\\uFE00|\\u2AAD\\uFE00|\\u2AAF\\u0338|\\u2AB0\\u0338|\\u2AC5\\u0338|\\u2AC6\\u0338|\\u2ACB\\uFE00|\\u2ACC\\uFE00|\\u2AFD\\u20E5|[\\xA0-\\u0113\\u0116-\\u0122\\u0124-\\u012B\\u012E-\\u014D\\u0150-\\u017E\\u0192\\u01B5\\u01F5\\u0237\\u02C6\\u02C7\\u02D8-\\u02DD\\u0311\\u0391-\\u03A1\\u03A3-\\u03A9\\u03B1-\\u03C9\\u03D1\\u03D2\\u03D5\\u03D6\\u03DC\\u03DD\\u03F0\\u03F1\\u03F5\\u03F6\\u0401-\\u040C\\u040E-\\u044F\\u0451-\\u045C\\u045E\\u045F\\u2002-\\u2005\\u2007-\\u2010\\u2013-\\u2016\\u2018-\\u201A\\u201C-\\u201E\\u2020-\\u2022\\u2025\\u2026\\u2030-\\u2035\\u2039\\u203A\\u203E\\u2041\\u2043\\u2044\\u204F\\u2057\\u205F-\\u2063\\u20AC\\u20DB\\u20DC\\u2102\\u2105\\u210A-\\u2113\\u2115-\\u211E\\u2122\\u2124\\u2127-\\u2129\\u212C\\u212D\\u212F-\\u2131\\u2133-\\u2138\\u2145-\\u2148\\u2153-\\u215E\\u2190-\\u219B\\u219D-\\u21A7\\u21A9-\\u21AE\\u21B0-\\u21B3\\u21B5-\\u21B7\\u21BA-\\u21DB\\u21DD\\u21E4\\u21E5\\u21F5\\u21FD-\\u2205\\u2207-\\u2209\\u220B\\u220C\\u220F-\\u2214\\u2216-\\u2218\\u221A\\u221D-\\u2238\\u223A-\\u2257\\u2259\\u225A\\u225C\\u225F-\\u2262\\u2264-\\u228B\\u228D-\\u229B\\u229D-\\u22A5\\u22A7-\\u22B0\\u22B2-\\u22BB\\u22BD-\\u22DB\\u22DE-\\u22E3\\u22E6-\\u22F7\\u22F9-\\u22FE\\u2305\\u2306\\u2308-\\u2310\\u2312\\u2313\\u2315\\u2316\\u231C-\\u231F\\u2322\\u2323\\u232D\\u232E\\u2336\\u233D\\u233F\\u237C\\u23B0\\u23B1\\u23B4-\\u23B6\\u23DC-\\u23DF\\u23E2\\u23E7\\u2423\\u24C8\\u2500\\u2502\\u250C\\u2510\\u2514\\u2518\\u251C\\u2524\\u252C\\u2534\\u253C\\u2550-\\u256C\\u2580\\u2584\\u2588\\u2591-\\u2593\\u25A1\\u25AA\\u25AB\\u25AD\\u25AE\\u25B1\\u25B3-\\u25B5\\u25B8\\u25B9\\u25BD-\\u25BF\\u25C2\\u25C3\\u25CA\\u25CB\\u25EC\\u25EF\\u25F8-\\u25FC\\u2605\\u2606\\u260E\\u2640\\u2642\\u2660\\u2663\\u2665\\u2666\\u266A\\u266D-\\u266F\\u2713\\u2717\\u2720\\u2736\\u2758\\u2772\\u2773\\u27C8\\u27C9\\u27E6-\\u27ED\\u27F5-\\u27FA\\u27FC\\u27FF\\u2902-\\u2905\\u290C-\\u2913\\u2916\\u2919-\\u2920\\u2923-\\u292A\\u2933\\u2935-\\u2939\\u293C\\u293D\\u2945\\u2948-\\u294B\\u294E-\\u2976\\u2978\\u2979\\u297B-\\u297F\\u2985\\u2986\\u298B-\\u2996\\u299A\\u299C\\u299D\\u29A4-\\u29B7\\u29B9\\u29BB\\u29BC\\u29BE-\\u29C5\\u29C9\\u29CD-\\u29D0\\u29DC-\\u29DE\\u29E3-\\u29E5\\u29EB\\u29F4\\u29F6\\u2A00-\\u2A02\\u2A04\\u2A06\\u2A0C\\u2A0D\\u2A10-\\u2A17\\u2A22-\\u2A27\\u2A29\\u2A2A\\u2A2D-\\u2A31\\u2A33-\\u2A3C\\u2A3F\\u2A40\\u2A42-\\u2A4D\\u2A50\\u2A53-\\u2A58\\u2A5A-\\u2A5D\\u2A5F\\u2A66\\u2A6A\\u2A6D-\\u2A75\\u2A77-\\u2A9A\\u2A9D-\\u2AA2\\u2AA4-\\u2AB0\\u2AB3-\\u2AC8\\u2ACB\\u2ACC\\u2ACF-\\u2ADB\\u2AE4\\u2AE6-\\u2AE9\\u2AEB-\\u2AF3\\u2AFD\\uFB00-\\uFB04]|\\uD835[\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDCCF\\uDD04\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDD6B]/g;\n\tvar encodeMap = {'\\xAD':'shy','\\u200C':'zwnj','\\u200D':'zwj','\\u200E':'lrm','\\u2063':'ic','\\u2062':'it','\\u2061':'af','\\u200F':'rlm','\\u200B':'ZeroWidthSpace','\\u2060':'NoBreak','\\u0311':'DownBreve','\\u20DB':'tdot','\\u20DC':'DotDot','\\t':'Tab','\\n':'NewLine','\\u2008':'puncsp','\\u205F':'MediumSpace','\\u2009':'thinsp','\\u200A':'hairsp','\\u2004':'emsp13','\\u2002':'ensp','\\u2005':'emsp14','\\u2003':'emsp','\\u2007':'numsp','\\xA0':'nbsp','\\u205F\\u200A':'ThickSpace','\\u203E':'oline','_':'lowbar','\\u2010':'dash','\\u2013':'ndash','\\u2014':'mdash','\\u2015':'horbar',',':'comma',';':'semi','\\u204F':'bsemi',':':'colon','\\u2A74':'Colone','!':'excl','\\xA1':'iexcl','?':'quest','\\xBF':'iquest','.':'period','\\u2025':'nldr','\\u2026':'mldr','\\xB7':'middot','\\'':'apos','\\u2018':'lsquo','\\u2019':'rsquo','\\u201A':'sbquo','\\u2039':'lsaquo','\\u203A':'rsaquo','\"':'quot','\\u201C':'ldquo','\\u201D':'rdquo','\\u201E':'bdquo','\\xAB':'laquo','\\xBB':'raquo','(':'lpar',')':'rpar','[':'lsqb',']':'rsqb','{':'lcub','}':'rcub','\\u2308':'lceil','\\u2309':'rceil','\\u230A':'lfloor','\\u230B':'rfloor','\\u2985':'lopar','\\u2986':'ropar','\\u298B':'lbrke','\\u298C':'rbrke','\\u298D':'lbrkslu','\\u298E':'rbrksld','\\u298F':'lbrksld','\\u2990':'rbrkslu','\\u2991':'langd','\\u2992':'rangd','\\u2993':'lparlt','\\u2994':'rpargt','\\u2995':'gtlPar','\\u2996':'ltrPar','\\u27E6':'lobrk','\\u27E7':'robrk','\\u27E8':'lang','\\u27E9':'rang','\\u27EA':'Lang','\\u27EB':'Rang','\\u27EC':'loang','\\u27ED':'roang','\\u2772':'lbbrk','\\u2773':'rbbrk','\\u2016':'Vert','\\xA7':'sect','\\xB6':'para','@':'commat','*':'ast','/':'sol','undefined':null,'&':'amp','#':'num','%':'percnt','\\u2030':'permil','\\u2031':'pertenk','\\u2020':'dagger','\\u2021':'Dagger','\\u2022':'bull','\\u2043':'hybull','\\u2032':'prime','\\u2033':'Prime','\\u2034':'tprime','\\u2057':'qprime','\\u2035':'bprime','\\u2041':'caret','`':'grave','\\xB4':'acute','\\u02DC':'tilde','^':'Hat','\\xAF':'macr','\\u02D8':'breve','\\u02D9':'dot','\\xA8':'die','\\u02DA':'ring','\\u02DD':'dblac','\\xB8':'cedil','\\u02DB':'ogon','\\u02C6':'circ','\\u02C7':'caron','\\xB0':'deg','\\xA9':'copy','\\xAE':'reg','\\u2117':'copysr','\\u2118':'wp','\\u211E':'rx','\\u2127':'mho','\\u2129':'iiota','\\u2190':'larr','\\u219A':'nlarr','\\u2192':'rarr','\\u219B':'nrarr','\\u2191':'uarr','\\u2193':'darr','\\u2194':'harr','\\u21AE':'nharr','\\u2195':'varr','\\u2196':'nwarr','\\u2197':'nearr','\\u2198':'searr','\\u2199':'swarr','\\u219D':'rarrw','\\u219D\\u0338':'nrarrw','\\u219E':'Larr','\\u219F':'Uarr','\\u21A0':'Rarr','\\u21A1':'Darr','\\u21A2':'larrtl','\\u21A3':'rarrtl','\\u21A4':'mapstoleft','\\u21A5':'mapstoup','\\u21A6':'map','\\u21A7':'mapstodown','\\u21A9':'larrhk','\\u21AA':'rarrhk','\\u21AB':'larrlp','\\u21AC':'rarrlp','\\u21AD':'harrw','\\u21B0':'lsh','\\u21B1':'rsh','\\u21B2':'ldsh','\\u21B3':'rdsh','\\u21B5':'crarr','\\u21B6':'cularr','\\u21B7':'curarr','\\u21BA':'olarr','\\u21BB':'orarr','\\u21BC':'lharu','\\u21BD':'lhard','\\u21BE':'uharr','\\u21BF':'uharl','\\u21C0':'rharu','\\u21C1':'rhard','\\u21C2':'dharr','\\u21C3':'dharl','\\u21C4':'rlarr','\\u21C5':'udarr','\\u21C6':'lrarr','\\u21C7':'llarr','\\u21C8':'uuarr','\\u21C9':'rrarr','\\u21CA':'ddarr','\\u21CB':'lrhar','\\u21CC':'rlhar','\\u21D0':'lArr','\\u21CD':'nlArr','\\u21D1':'uArr','\\u21D2':'rArr','\\u21CF':'nrArr','\\u21D3':'dArr','\\u21D4':'iff','\\u21CE':'nhArr','\\u21D5':'vArr','\\u21D6':'nwArr','\\u21D7':'neArr','\\u21D8':'seArr','\\u21D9':'swArr','\\u21DA':'lAarr','\\u21DB':'rAarr','\\u21DD':'zigrarr','\\u21E4':'larrb','\\u21E5':'rarrb','\\u21F5':'duarr','\\u21FD':'loarr','\\u21FE':'roarr','\\u21FF':'hoarr','\\u2200':'forall','\\u2201':'comp','\\u2202':'part','\\u2202\\u0338':'npart','\\u2203':'exist','\\u2204':'nexist','\\u2205':'empty','\\u2207':'Del','\\u2208':'in','\\u2209':'notin','\\u220B':'ni','\\u220C':'notni','\\u03F6':'bepsi','\\u220F':'prod','\\u2210':'coprod','\\u2211':'sum','+':'plus','\\xB1':'pm','\\xF7':'div','\\xD7':'times','<':'lt','\\u226E':'nlt','<\\u20D2':'nvlt','=':'equals','\\u2260':'ne','=\\u20E5':'bne','\\u2A75':'Equal','>':'gt','\\u226F':'ngt','>\\u20D2':'nvgt','\\xAC':'not','|':'vert','\\xA6':'brvbar','\\u2212':'minus','\\u2213':'mp','\\u2214':'plusdo','\\u2044':'frasl','\\u2216':'setmn','\\u2217':'lowast','\\u2218':'compfn','\\u221A':'Sqrt','\\u221D':'prop','\\u221E':'infin','\\u221F':'angrt','\\u2220':'ang','\\u2220\\u20D2':'nang','\\u2221':'angmsd','\\u2222':'angsph','\\u2223':'mid','\\u2224':'nmid','\\u2225':'par','\\u2226':'npar','\\u2227':'and','\\u2228':'or','\\u2229':'cap','\\u2229\\uFE00':'caps','\\u222A':'cup','\\u222A\\uFE00':'cups','\\u222B':'int','\\u222C':'Int','\\u222D':'tint','\\u2A0C':'qint','\\u222E':'oint','\\u222F':'Conint','\\u2230':'Cconint','\\u2231':'cwint','\\u2232':'cwconint','\\u2233':'awconint','\\u2234':'there4','\\u2235':'becaus','\\u2236':'ratio','\\u2237':'Colon','\\u2238':'minusd','\\u223A':'mDDot','\\u223B':'homtht','\\u223C':'sim','\\u2241':'nsim','\\u223C\\u20D2':'nvsim','\\u223D':'bsim','\\u223D\\u0331':'race','\\u223E':'ac','\\u223E\\u0333':'acE','\\u223F':'acd','\\u2240':'wr','\\u2242':'esim','\\u2242\\u0338':'nesim','\\u2243':'sime','\\u2244':'nsime','\\u2245':'cong','\\u2247':'ncong','\\u2246':'simne','\\u2248':'ap','\\u2249':'nap','\\u224A':'ape','\\u224B':'apid','\\u224B\\u0338':'napid','\\u224C':'bcong','\\u224D':'CupCap','\\u226D':'NotCupCap','\\u224D\\u20D2':'nvap','\\u224E':'bump','\\u224E\\u0338':'nbump','\\u224F':'bumpe','\\u224F\\u0338':'nbumpe','\\u2250':'doteq','\\u2250\\u0338':'nedot','\\u2251':'eDot','\\u2252':'efDot','\\u2253':'erDot','\\u2254':'colone','\\u2255':'ecolon','\\u2256':'ecir','\\u2257':'cire','\\u2259':'wedgeq','\\u225A':'veeeq','\\u225C':'trie','\\u225F':'equest','\\u2261':'equiv','\\u2262':'nequiv','\\u2261\\u20E5':'bnequiv','\\u2264':'le','\\u2270':'nle','\\u2264\\u20D2':'nvle','\\u2265':'ge','\\u2271':'nge','\\u2265\\u20D2':'nvge','\\u2266':'lE','\\u2266\\u0338':'nlE','\\u2267':'gE','\\u2267\\u0338':'ngE','\\u2268\\uFE00':'lvnE','\\u2268':'lnE','\\u2269':'gnE','\\u2269\\uFE00':'gvnE','\\u226A':'ll','\\u226A\\u0338':'nLtv','\\u226A\\u20D2':'nLt','\\u226B':'gg','\\u226B\\u0338':'nGtv','\\u226B\\u20D2':'nGt','\\u226C':'twixt','\\u2272':'lsim','\\u2274':'nlsim','\\u2273':'gsim','\\u2275':'ngsim','\\u2276':'lg','\\u2278':'ntlg','\\u2277':'gl','\\u2279':'ntgl','\\u227A':'pr','\\u2280':'npr','\\u227B':'sc','\\u2281':'nsc','\\u227C':'prcue','\\u22E0':'nprcue','\\u227D':'sccue','\\u22E1':'nsccue','\\u227E':'prsim','\\u227F':'scsim','\\u227F\\u0338':'NotSucceedsTilde','\\u2282':'sub','\\u2284':'nsub','\\u2282\\u20D2':'vnsub','\\u2283':'sup','\\u2285':'nsup','\\u2283\\u20D2':'vnsup','\\u2286':'sube','\\u2288':'nsube','\\u2287':'supe','\\u2289':'nsupe','\\u228A\\uFE00':'vsubne','\\u228A':'subne','\\u228B\\uFE00':'vsupne','\\u228B':'supne','\\u228D':'cupdot','\\u228E':'uplus','\\u228F':'sqsub','\\u228F\\u0338':'NotSquareSubset','\\u2290':'sqsup','\\u2290\\u0338':'NotSquareSuperset','\\u2291':'sqsube','\\u22E2':'nsqsube','\\u2292':'sqsupe','\\u22E3':'nsqsupe','\\u2293':'sqcap','\\u2293\\uFE00':'sqcaps','\\u2294':'sqcup','\\u2294\\uFE00':'sqcups','\\u2295':'oplus','\\u2296':'ominus','\\u2297':'otimes','\\u2298':'osol','\\u2299':'odot','\\u229A':'ocir','\\u229B':'oast','\\u229D':'odash','\\u229E':'plusb','\\u229F':'minusb','\\u22A0':'timesb','\\u22A1':'sdotb','\\u22A2':'vdash','\\u22AC':'nvdash','\\u22A3':'dashv','\\u22A4':'top','\\u22A5':'bot','\\u22A7':'models','\\u22A8':'vDash','\\u22AD':'nvDash','\\u22A9':'Vdash','\\u22AE':'nVdash','\\u22AA':'Vvdash','\\u22AB':'VDash','\\u22AF':'nVDash','\\u22B0':'prurel','\\u22B2':'vltri','\\u22EA':'nltri','\\u22B3':'vrtri','\\u22EB':'nrtri','\\u22B4':'ltrie','\\u22EC':'nltrie','\\u22B4\\u20D2':'nvltrie','\\u22B5':'rtrie','\\u22ED':'nrtrie','\\u22B5\\u20D2':'nvrtrie','\\u22B6':'origof','\\u22B7':'imof','\\u22B8':'mumap','\\u22B9':'hercon','\\u22BA':'intcal','\\u22BB':'veebar','\\u22BD':'barvee','\\u22BE':'angrtvb','\\u22BF':'lrtri','\\u22C0':'Wedge','\\u22C1':'Vee','\\u22C2':'xcap','\\u22C3':'xcup','\\u22C4':'diam','\\u22C5':'sdot','\\u22C6':'Star','\\u22C7':'divonx','\\u22C8':'bowtie','\\u22C9':'ltimes','\\u22CA':'rtimes','\\u22CB':'lthree','\\u22CC':'rthree','\\u22CD':'bsime','\\u22CE':'cuvee','\\u22CF':'cuwed','\\u22D0':'Sub','\\u22D1':'Sup','\\u22D2':'Cap','\\u22D3':'Cup','\\u22D4':'fork','\\u22D5':'epar','\\u22D6':'ltdot','\\u22D7':'gtdot','\\u22D8':'Ll','\\u22D8\\u0338':'nLl','\\u22D9':'Gg','\\u22D9\\u0338':'nGg','\\u22DA\\uFE00':'lesg','\\u22DA':'leg','\\u22DB':'gel','\\u22DB\\uFE00':'gesl','\\u22DE':'cuepr','\\u22DF':'cuesc','\\u22E6':'lnsim','\\u22E7':'gnsim','\\u22E8':'prnsim','\\u22E9':'scnsim','\\u22EE':'vellip','\\u22EF':'ctdot','\\u22F0':'utdot','\\u22F1':'dtdot','\\u22F2':'disin','\\u22F3':'isinsv','\\u22F4':'isins','\\u22F5':'isindot','\\u22F5\\u0338':'notindot','\\u22F6':'notinvc','\\u22F7':'notinvb','\\u22F9':'isinE','\\u22F9\\u0338':'notinE','\\u22FA':'nisd','\\u22FB':'xnis','\\u22FC':'nis','\\u22FD':'notnivc','\\u22FE':'notnivb','\\u2305':'barwed','\\u2306':'Barwed','\\u230C':'drcrop','\\u230D':'dlcrop','\\u230E':'urcrop','\\u230F':'ulcrop','\\u2310':'bnot','\\u2312':'profline','\\u2313':'profsurf','\\u2315':'telrec','\\u2316':'target','\\u231C':'ulcorn','\\u231D':'urcorn','\\u231E':'dlcorn','\\u231F':'drcorn','\\u2322':'frown','\\u2323':'smile','\\u232D':'cylcty','\\u232E':'profalar','\\u2336':'topbot','\\u233D':'ovbar','\\u233F':'solbar','\\u237C':'angzarr','\\u23B0':'lmoust','\\u23B1':'rmoust','\\u23B4':'tbrk','\\u23B5':'bbrk','\\u23B6':'bbrktbrk','\\u23DC':'OverParenthesis','\\u23DD':'UnderParenthesis','\\u23DE':'OverBrace','\\u23DF':'UnderBrace','\\u23E2':'trpezium','\\u23E7':'elinters','\\u2423':'blank','\\u2500':'boxh','\\u2502':'boxv','\\u250C':'boxdr','\\u2510':'boxdl','\\u2514':'boxur','\\u2518':'boxul','\\u251C':'boxvr','\\u2524':'boxvl','\\u252C':'boxhd','\\u2534':'boxhu','\\u253C':'boxvh','\\u2550':'boxH','\\u2551':'boxV','\\u2552':'boxdR','\\u2553':'boxDr','\\u2554':'boxDR','\\u2555':'boxdL','\\u2556':'boxDl','\\u2557':'boxDL','\\u2558':'boxuR','\\u2559':'boxUr','\\u255A':'boxUR','\\u255B':'boxuL','\\u255C':'boxUl','\\u255D':'boxUL','\\u255E':'boxvR','\\u255F':'boxVr','\\u2560':'boxVR','\\u2561':'boxvL','\\u2562':'boxVl','\\u2563':'boxVL','\\u2564':'boxHd','\\u2565':'boxhD','\\u2566':'boxHD','\\u2567':'boxHu','\\u2568':'boxhU','\\u2569':'boxHU','\\u256A':'boxvH','\\u256B':'boxVh','\\u256C':'boxVH','\\u2580':'uhblk','\\u2584':'lhblk','\\u2588':'block','\\u2591':'blk14','\\u2592':'blk12','\\u2593':'blk34','\\u25A1':'squ','\\u25AA':'squf','\\u25AB':'EmptyVerySmallSquare','\\u25AD':'rect','\\u25AE':'marker','\\u25B1':'fltns','\\u25B3':'xutri','\\u25B4':'utrif','\\u25B5':'utri','\\u25B8':'rtrif','\\u25B9':'rtri','\\u25BD':'xdtri','\\u25BE':'dtrif','\\u25BF':'dtri','\\u25C2':'ltrif','\\u25C3':'ltri','\\u25CA':'loz','\\u25CB':'cir','\\u25EC':'tridot','\\u25EF':'xcirc','\\u25F8':'ultri','\\u25F9':'urtri','\\u25FA':'lltri','\\u25FB':'EmptySmallSquare','\\u25FC':'FilledSmallSquare','\\u2605':'starf','\\u2606':'star','\\u260E':'phone','\\u2640':'female','\\u2642':'male','\\u2660':'spades','\\u2663':'clubs','\\u2665':'hearts','\\u2666':'diams','\\u266A':'sung','\\u2713':'check','\\u2717':'cross','\\u2720':'malt','\\u2736':'sext','\\u2758':'VerticalSeparator','\\u27C8':'bsolhsub','\\u27C9':'suphsol','\\u27F5':'xlarr','\\u27F6':'xrarr','\\u27F7':'xharr','\\u27F8':'xlArr','\\u27F9':'xrArr','\\u27FA':'xhArr','\\u27FC':'xmap','\\u27FF':'dzigrarr','\\u2902':'nvlArr','\\u2903':'nvrArr','\\u2904':'nvHarr','\\u2905':'Map','\\u290C':'lbarr','\\u290D':'rbarr','\\u290E':'lBarr','\\u290F':'rBarr','\\u2910':'RBarr','\\u2911':'DDotrahd','\\u2912':'UpArrowBar','\\u2913':'DownArrowBar','\\u2916':'Rarrtl','\\u2919':'latail','\\u291A':'ratail','\\u291B':'lAtail','\\u291C':'rAtail','\\u291D':'larrfs','\\u291E':'rarrfs','\\u291F':'larrbfs','\\u2920':'rarrbfs','\\u2923':'nwarhk','\\u2924':'nearhk','\\u2925':'searhk','\\u2926':'swarhk','\\u2927':'nwnear','\\u2928':'toea','\\u2929':'tosa','\\u292A':'swnwar','\\u2933':'rarrc','\\u2933\\u0338':'nrarrc','\\u2935':'cudarrr','\\u2936':'ldca','\\u2937':'rdca','\\u2938':'cudarrl','\\u2939':'larrpl','\\u293C':'curarrm','\\u293D':'cularrp','\\u2945':'rarrpl','\\u2948':'harrcir','\\u2949':'Uarrocir','\\u294A':'lurdshar','\\u294B':'ldrushar','\\u294E':'LeftRightVector','\\u294F':'RightUpDownVector','\\u2950':'DownLeftRightVector','\\u2951':'LeftUpDownVector','\\u2952':'LeftVectorBar','\\u2953':'RightVectorBar','\\u2954':'RightUpVectorBar','\\u2955':'RightDownVectorBar','\\u2956':'DownLeftVectorBar','\\u2957':'DownRightVectorBar','\\u2958':'LeftUpVectorBar','\\u2959':'LeftDownVectorBar','\\u295A':'LeftTeeVector','\\u295B':'RightTeeVector','\\u295C':'RightUpTeeVector','\\u295D':'RightDownTeeVector','\\u295E':'DownLeftTeeVector','\\u295F':'DownRightTeeVector','\\u2960':'LeftUpTeeVector','\\u2961':'LeftDownTeeVector','\\u2962':'lHar','\\u2963':'uHar','\\u2964':'rHar','\\u2965':'dHar','\\u2966':'luruhar','\\u2967':'ldrdhar','\\u2968':'ruluhar','\\u2969':'rdldhar','\\u296A':'lharul','\\u296B':'llhard','\\u296C':'rharul','\\u296D':'lrhard','\\u296E':'udhar','\\u296F':'duhar','\\u2970':'RoundImplies','\\u2971':'erarr','\\u2972':'simrarr','\\u2973':'larrsim','\\u2974':'rarrsim','\\u2975':'rarrap','\\u2976':'ltlarr','\\u2978':'gtrarr','\\u2979':'subrarr','\\u297B':'suplarr','\\u297C':'lfisht','\\u297D':'rfisht','\\u297E':'ufisht','\\u297F':'dfisht','\\u299A':'vzigzag','\\u299C':'vangrt','\\u299D':'angrtvbd','\\u29A4':'ange','\\u29A5':'range','\\u29A6':'dwangle','\\u29A7':'uwangle','\\u29A8':'angmsdaa','\\u29A9':'angmsdab','\\u29AA':'angmsdac','\\u29AB':'angmsdad','\\u29AC':'angmsdae','\\u29AD':'angmsdaf','\\u29AE':'angmsdag','\\u29AF':'angmsdah','\\u29B0':'bemptyv','\\u29B1':'demptyv','\\u29B2':'cemptyv','\\u29B3':'raemptyv','\\u29B4':'laemptyv','\\u29B5':'ohbar','\\u29B6':'omid','\\u29B7':'opar','\\u29B9':'operp','\\u29BB':'olcross','\\u29BC':'odsold','\\u29BE':'olcir','\\u29BF':'ofcir','\\u29C0':'olt','\\u29C1':'ogt','\\u29C2':'cirscir','\\u29C3':'cirE','\\u29C4':'solb','\\u29C5':'bsolb','\\u29C9':'boxbox','\\u29CD':'trisb','\\u29CE':'rtriltri','\\u29CF':'LeftTriangleBar','\\u29CF\\u0338':'NotLeftTriangleBar','\\u29D0':'RightTriangleBar','\\u29D0\\u0338':'NotRightTriangleBar','\\u29DC':'iinfin','\\u29DD':'infintie','\\u29DE':'nvinfin','\\u29E3':'eparsl','\\u29E4':'smeparsl','\\u29E5':'eqvparsl','\\u29EB':'lozf','\\u29F4':'RuleDelayed','\\u29F6':'dsol','\\u2A00':'xodot','\\u2A01':'xoplus','\\u2A02':'xotime','\\u2A04':'xuplus','\\u2A06':'xsqcup','\\u2A0D':'fpartint','\\u2A10':'cirfnint','\\u2A11':'awint','\\u2A12':'rppolint','\\u2A13':'scpolint','\\u2A14':'npolint','\\u2A15':'pointint','\\u2A16':'quatint','\\u2A17':'intlarhk','\\u2A22':'pluscir','\\u2A23':'plusacir','\\u2A24':'simplus','\\u2A25':'plusdu','\\u2A26':'plussim','\\u2A27':'plustwo','\\u2A29':'mcomma','\\u2A2A':'minusdu','\\u2A2D':'loplus','\\u2A2E':'roplus','\\u2A2F':'Cross','\\u2A30':'timesd','\\u2A31':'timesbar','\\u2A33':'smashp','\\u2A34':'lotimes','\\u2A35':'rotimes','\\u2A36':'otimesas','\\u2A37':'Otimes','\\u2A38':'odiv','\\u2A39':'triplus','\\u2A3A':'triminus','\\u2A3B':'tritime','\\u2A3C':'iprod','\\u2A3F':'amalg','\\u2A40':'capdot','\\u2A42':'ncup','\\u2A43':'ncap','\\u2A44':'capand','\\u2A45':'cupor','\\u2A46':'cupcap','\\u2A47':'capcup','\\u2A48':'cupbrcap','\\u2A49':'capbrcup','\\u2A4A':'cupcup','\\u2A4B':'capcap','\\u2A4C':'ccups','\\u2A4D':'ccaps','\\u2A50':'ccupssm','\\u2A53':'And','\\u2A54':'Or','\\u2A55':'andand','\\u2A56':'oror','\\u2A57':'orslope','\\u2A58':'andslope','\\u2A5A':'andv','\\u2A5B':'orv','\\u2A5C':'andd','\\u2A5D':'ord','\\u2A5F':'wedbar','\\u2A66':'sdote','\\u2A6A':'simdot','\\u2A6D':'congdot','\\u2A6D\\u0338':'ncongdot','\\u2A6E':'easter','\\u2A6F':'apacir','\\u2A70':'apE','\\u2A70\\u0338':'napE','\\u2A71':'eplus','\\u2A72':'pluse','\\u2A73':'Esim','\\u2A77':'eDDot','\\u2A78':'equivDD','\\u2A79':'ltcir','\\u2A7A':'gtcir','\\u2A7B':'ltquest','\\u2A7C':'gtquest','\\u2A7D':'les','\\u2A7D\\u0338':'nles','\\u2A7E':'ges','\\u2A7E\\u0338':'nges','\\u2A7F':'lesdot','\\u2A80':'gesdot','\\u2A81':'lesdoto','\\u2A82':'gesdoto','\\u2A83':'lesdotor','\\u2A84':'gesdotol','\\u2A85':'lap','\\u2A86':'gap','\\u2A87':'lne','\\u2A88':'gne','\\u2A89':'lnap','\\u2A8A':'gnap','\\u2A8B':'lEg','\\u2A8C':'gEl','\\u2A8D':'lsime','\\u2A8E':'gsime','\\u2A8F':'lsimg','\\u2A90':'gsiml','\\u2A91':'lgE','\\u2A92':'glE','\\u2A93':'lesges','\\u2A94':'gesles','\\u2A95':'els','\\u2A96':'egs','\\u2A97':'elsdot','\\u2A98':'egsdot','\\u2A99':'el','\\u2A9A':'eg','\\u2A9D':'siml','\\u2A9E':'simg','\\u2A9F':'simlE','\\u2AA0':'simgE','\\u2AA1':'LessLess','\\u2AA1\\u0338':'NotNestedLessLess','\\u2AA2':'GreaterGreater','\\u2AA2\\u0338':'NotNestedGreaterGreater','\\u2AA4':'glj','\\u2AA5':'gla','\\u2AA6':'ltcc','\\u2AA7':'gtcc','\\u2AA8':'lescc','\\u2AA9':'gescc','\\u2AAA':'smt','\\u2AAB':'lat','\\u2AAC':'smte','\\u2AAC\\uFE00':'smtes','\\u2AAD':'late','\\u2AAD\\uFE00':'lates','\\u2AAE':'bumpE','\\u2AAF':'pre','\\u2AAF\\u0338':'npre','\\u2AB0':'sce','\\u2AB0\\u0338':'nsce','\\u2AB3':'prE','\\u2AB4':'scE','\\u2AB5':'prnE','\\u2AB6':'scnE','\\u2AB7':'prap','\\u2AB8':'scap','\\u2AB9':'prnap','\\u2ABA':'scnap','\\u2ABB':'Pr','\\u2ABC':'Sc','\\u2ABD':'subdot','\\u2ABE':'supdot','\\u2ABF':'subplus','\\u2AC0':'supplus','\\u2AC1':'submult','\\u2AC2':'supmult','\\u2AC3':'subedot','\\u2AC4':'supedot','\\u2AC5':'subE','\\u2AC5\\u0338':'nsubE','\\u2AC6':'supE','\\u2AC6\\u0338':'nsupE','\\u2AC7':'subsim','\\u2AC8':'supsim','\\u2ACB\\uFE00':'vsubnE','\\u2ACB':'subnE','\\u2ACC\\uFE00':'vsupnE','\\u2ACC':'supnE','\\u2ACF':'csub','\\u2AD0':'csup','\\u2AD1':'csube','\\u2AD2':'csupe','\\u2AD3':'subsup','\\u2AD4':'supsub','\\u2AD5':'subsub','\\u2AD6':'supsup','\\u2AD7':'suphsub','\\u2AD8':'supdsub','\\u2AD9':'forkv','\\u2ADA':'topfork','\\u2ADB':'mlcp','\\u2AE4':'Dashv','\\u2AE6':'Vdashl','\\u2AE7':'Barv','\\u2AE8':'vBar','\\u2AE9':'vBarv','\\u2AEB':'Vbar','\\u2AEC':'Not','\\u2AED':'bNot','\\u2AEE':'rnmid','\\u2AEF':'cirmid','\\u2AF0':'midcir','\\u2AF1':'topcir','\\u2AF2':'nhpar','\\u2AF3':'parsim','\\u2AFD':'parsl','\\u2AFD\\u20E5':'nparsl','\\u266D':'flat','\\u266E':'natur','\\u266F':'sharp','\\xA4':'curren','\\xA2':'cent','$':'dollar','\\xA3':'pound','\\xA5':'yen','\\u20AC':'euro','\\xB9':'sup1','\\xBD':'half','\\u2153':'frac13','\\xBC':'frac14','\\u2155':'frac15','\\u2159':'frac16','\\u215B':'frac18','\\xB2':'sup2','\\u2154':'frac23','\\u2156':'frac25','\\xB3':'sup3','\\xBE':'frac34','\\u2157':'frac35','\\u215C':'frac38','\\u2158':'frac45','\\u215A':'frac56','\\u215D':'frac58','\\u215E':'frac78','\\uD835\\uDCB6':'ascr','\\uD835\\uDD52':'aopf','\\uD835\\uDD1E':'afr','\\uD835\\uDD38':'Aopf','\\uD835\\uDD04':'Afr','\\uD835\\uDC9C':'Ascr','\\xAA':'ordf','\\xE1':'aacute','\\xC1':'Aacute','\\xE0':'agrave','\\xC0':'Agrave','\\u0103':'abreve','\\u0102':'Abreve','\\xE2':'acirc','\\xC2':'Acirc','\\xE5':'aring','\\xC5':'angst','\\xE4':'auml','\\xC4':'Auml','\\xE3':'atilde','\\xC3':'Atilde','\\u0105':'aogon','\\u0104':'Aogon','\\u0101':'amacr','\\u0100':'Amacr','\\xE6':'aelig','\\xC6':'AElig','\\uD835\\uDCB7':'bscr','\\uD835\\uDD53':'bopf','\\uD835\\uDD1F':'bfr','\\uD835\\uDD39':'Bopf','\\u212C':'Bscr','\\uD835\\uDD05':'Bfr','\\uD835\\uDD20':'cfr','\\uD835\\uDCB8':'cscr','\\uD835\\uDD54':'copf','\\u212D':'Cfr','\\uD835\\uDC9E':'Cscr','\\u2102':'Copf','\\u0107':'cacute','\\u0106':'Cacute','\\u0109':'ccirc','\\u0108':'Ccirc','\\u010D':'ccaron','\\u010C':'Ccaron','\\u010B':'cdot','\\u010A':'Cdot','\\xE7':'ccedil','\\xC7':'Ccedil','\\u2105':'incare','\\uD835\\uDD21':'dfr','\\u2146':'dd','\\uD835\\uDD55':'dopf','\\uD835\\uDCB9':'dscr','\\uD835\\uDC9F':'Dscr','\\uD835\\uDD07':'Dfr','\\u2145':'DD','\\uD835\\uDD3B':'Dopf','\\u010F':'dcaron','\\u010E':'Dcaron','\\u0111':'dstrok','\\u0110':'Dstrok','\\xF0':'eth','\\xD0':'ETH','\\u2147':'ee','\\u212F':'escr','\\uD835\\uDD22':'efr','\\uD835\\uDD56':'eopf','\\u2130':'Escr','\\uD835\\uDD08':'Efr','\\uD835\\uDD3C':'Eopf','\\xE9':'eacute','\\xC9':'Eacute','\\xE8':'egrave','\\xC8':'Egrave','\\xEA':'ecirc','\\xCA':'Ecirc','\\u011B':'ecaron','\\u011A':'Ecaron','\\xEB':'euml','\\xCB':'Euml','\\u0117':'edot','\\u0116':'Edot','\\u0119':'eogon','\\u0118':'Eogon','\\u0113':'emacr','\\u0112':'Emacr','\\uD835\\uDD23':'ffr','\\uD835\\uDD57':'fopf','\\uD835\\uDCBB':'fscr','\\uD835\\uDD09':'Ffr','\\uD835\\uDD3D':'Fopf','\\u2131':'Fscr','\\uFB00':'fflig','\\uFB03':'ffilig','\\uFB04':'ffllig','\\uFB01':'filig','fj':'fjlig','\\uFB02':'fllig','\\u0192':'fnof','\\u210A':'gscr','\\uD835\\uDD58':'gopf','\\uD835\\uDD24':'gfr','\\uD835\\uDCA2':'Gscr','\\uD835\\uDD3E':'Gopf','\\uD835\\uDD0A':'Gfr','\\u01F5':'gacute','\\u011F':'gbreve','\\u011E':'Gbreve','\\u011D':'gcirc','\\u011C':'Gcirc','\\u0121':'gdot','\\u0120':'Gdot','\\u0122':'Gcedil','\\uD835\\uDD25':'hfr','\\u210E':'planckh','\\uD835\\uDCBD':'hscr','\\uD835\\uDD59':'hopf','\\u210B':'Hscr','\\u210C':'Hfr','\\u210D':'Hopf','\\u0125':'hcirc','\\u0124':'Hcirc','\\u210F':'hbar','\\u0127':'hstrok','\\u0126':'Hstrok','\\uD835\\uDD5A':'iopf','\\uD835\\uDD26':'ifr','\\uD835\\uDCBE':'iscr','\\u2148':'ii','\\uD835\\uDD40':'Iopf','\\u2110':'Iscr','\\u2111':'Im','\\xED':'iacute','\\xCD':'Iacute','\\xEC':'igrave','\\xCC':'Igrave','\\xEE':'icirc','\\xCE':'Icirc','\\xEF':'iuml','\\xCF':'Iuml','\\u0129':'itilde','\\u0128':'Itilde','\\u0130':'Idot','\\u012F':'iogon','\\u012E':'Iogon','\\u012B':'imacr','\\u012A':'Imacr','\\u0133':'ijlig','\\u0132':'IJlig','\\u0131':'imath','\\uD835\\uDCBF':'jscr','\\uD835\\uDD5B':'jopf','\\uD835\\uDD27':'jfr','\\uD835\\uDCA5':'Jscr','\\uD835\\uDD0D':'Jfr','\\uD835\\uDD41':'Jopf','\\u0135':'jcirc','\\u0134':'Jcirc','\\u0237':'jmath','\\uD835\\uDD5C':'kopf','\\uD835\\uDCC0':'kscr','\\uD835\\uDD28':'kfr','\\uD835\\uDCA6':'Kscr','\\uD835\\uDD42':'Kopf','\\uD835\\uDD0E':'Kfr','\\u0137':'kcedil','\\u0136':'Kcedil','\\uD835\\uDD29':'lfr','\\uD835\\uDCC1':'lscr','\\u2113':'ell','\\uD835\\uDD5D':'lopf','\\u2112':'Lscr','\\uD835\\uDD0F':'Lfr','\\uD835\\uDD43':'Lopf','\\u013A':'lacute','\\u0139':'Lacute','\\u013E':'lcaron','\\u013D':'Lcaron','\\u013C':'lcedil','\\u013B':'Lcedil','\\u0142':'lstrok','\\u0141':'Lstrok','\\u0140':'lmidot','\\u013F':'Lmidot','\\uD835\\uDD2A':'mfr','\\uD835\\uDD5E':'mopf','\\uD835\\uDCC2':'mscr','\\uD835\\uDD10':'Mfr','\\uD835\\uDD44':'Mopf','\\u2133':'Mscr','\\uD835\\uDD2B':'nfr','\\uD835\\uDD5F':'nopf','\\uD835\\uDCC3':'nscr','\\u2115':'Nopf','\\uD835\\uDCA9':'Nscr','\\uD835\\uDD11':'Nfr','\\u0144':'nacute','\\u0143':'Nacute','\\u0148':'ncaron','\\u0147':'Ncaron','\\xF1':'ntilde','\\xD1':'Ntilde','\\u0146':'ncedil','\\u0145':'Ncedil','\\u2116':'numero','\\u014B':'eng','\\u014A':'ENG','\\uD835\\uDD60':'oopf','\\uD835\\uDD2C':'ofr','\\u2134':'oscr','\\uD835\\uDCAA':'Oscr','\\uD835\\uDD12':'Ofr','\\uD835\\uDD46':'Oopf','\\xBA':'ordm','\\xF3':'oacute','\\xD3':'Oacute','\\xF2':'ograve','\\xD2':'Ograve','\\xF4':'ocirc','\\xD4':'Ocirc','\\xF6':'ouml','\\xD6':'Ouml','\\u0151':'odblac','\\u0150':'Odblac','\\xF5':'otilde','\\xD5':'Otilde','\\xF8':'oslash','\\xD8':'Oslash','\\u014D':'omacr','\\u014C':'Omacr','\\u0153':'oelig','\\u0152':'OElig','\\uD835\\uDD2D':'pfr','\\uD835\\uDCC5':'pscr','\\uD835\\uDD61':'popf','\\u2119':'Popf','\\uD835\\uDD13':'Pfr','\\uD835\\uDCAB':'Pscr','\\uD835\\uDD62':'qopf','\\uD835\\uDD2E':'qfr','\\uD835\\uDCC6':'qscr','\\uD835\\uDCAC':'Qscr','\\uD835\\uDD14':'Qfr','\\u211A':'Qopf','\\u0138':'kgreen','\\uD835\\uDD2F':'rfr','\\uD835\\uDD63':'ropf','\\uD835\\uDCC7':'rscr','\\u211B':'Rscr','\\u211C':'Re','\\u211D':'Ropf','\\u0155':'racute','\\u0154':'Racute','\\u0159':'rcaron','\\u0158':'Rcaron','\\u0157':'rcedil','\\u0156':'Rcedil','\\uD835\\uDD64':'sopf','\\uD835\\uDCC8':'sscr','\\uD835\\uDD30':'sfr','\\uD835\\uDD4A':'Sopf','\\uD835\\uDD16':'Sfr','\\uD835\\uDCAE':'Sscr','\\u24C8':'oS','\\u015B':'sacute','\\u015A':'Sacute','\\u015D':'scirc','\\u015C':'Scirc','\\u0161':'scaron','\\u0160':'Scaron','\\u015F':'scedil','\\u015E':'Scedil','\\xDF':'szlig','\\uD835\\uDD31':'tfr','\\uD835\\uDCC9':'tscr','\\uD835\\uDD65':'topf','\\uD835\\uDCAF':'Tscr','\\uD835\\uDD17':'Tfr','\\uD835\\uDD4B':'Topf','\\u0165':'tcaron','\\u0164':'Tcaron','\\u0163':'tcedil','\\u0162':'Tcedil','\\u2122':'trade','\\u0167':'tstrok','\\u0166':'Tstrok','\\uD835\\uDCCA':'uscr','\\uD835\\uDD66':'uopf','\\uD835\\uDD32':'ufr','\\uD835\\uDD4C':'Uopf','\\uD835\\uDD18':'Ufr','\\uD835\\uDCB0':'Uscr','\\xFA':'uacute','\\xDA':'Uacute','\\xF9':'ugrave','\\xD9':'Ugrave','\\u016D':'ubreve','\\u016C':'Ubreve','\\xFB':'ucirc','\\xDB':'Ucirc','\\u016F':'uring','\\u016E':'Uring','\\xFC':'uuml','\\xDC':'Uuml','\\u0171':'udblac','\\u0170':'Udblac','\\u0169':'utilde','\\u0168':'Utilde','\\u0173':'uogon','\\u0172':'Uogon','\\u016B':'umacr','\\u016A':'Umacr','\\uD835\\uDD33':'vfr','\\uD835\\uDD67':'vopf','\\uD835\\uDCCB':'vscr','\\uD835\\uDD19':'Vfr','\\uD835\\uDD4D':'Vopf','\\uD835\\uDCB1':'Vscr','\\uD835\\uDD68':'wopf','\\uD835\\uDCCC':'wscr','\\uD835\\uDD34':'wfr','\\uD835\\uDCB2':'Wscr','\\uD835\\uDD4E':'Wopf','\\uD835\\uDD1A':'Wfr','\\u0175':'wcirc','\\u0174':'Wcirc','\\uD835\\uDD35':'xfr','\\uD835\\uDCCD':'xscr','\\uD835\\uDD69':'xopf','\\uD835\\uDD4F':'Xopf','\\uD835\\uDD1B':'Xfr','\\uD835\\uDCB3':'Xscr','\\uD835\\uDD36':'yfr','\\uD835\\uDCCE':'yscr','\\uD835\\uDD6A':'yopf','\\uD835\\uDCB4':'Yscr','\\uD835\\uDD1C':'Yfr','\\uD835\\uDD50':'Yopf','\\xFD':'yacute','\\xDD':'Yacute','\\u0177':'ycirc','\\u0176':'Ycirc','\\xFF':'yuml','\\u0178':'Yuml','\\uD835\\uDCCF':'zscr','\\uD835\\uDD37':'zfr','\\uD835\\uDD6B':'zopf','\\u2128':'Zfr','\\u2124':'Zopf','\\uD835\\uDCB5':'Zscr','\\u017A':'zacute','\\u0179':'Zacute','\\u017E':'zcaron','\\u017D':'Zcaron','\\u017C':'zdot','\\u017B':'Zdot','\\u01B5':'imped','\\xFE':'thorn','\\xDE':'THORN','\\u0149':'napos','\\u03B1':'alpha','\\u0391':'Alpha','\\u03B2':'beta','\\u0392':'Beta','\\u03B3':'gamma','\\u0393':'Gamma','\\u03B4':'delta','\\u0394':'Delta','\\u03B5':'epsi','\\u03F5':'epsiv','\\u0395':'Epsilon','\\u03DD':'gammad','\\u03DC':'Gammad','\\u03B6':'zeta','\\u0396':'Zeta','\\u03B7':'eta','\\u0397':'Eta','\\u03B8':'theta','\\u03D1':'thetav','\\u0398':'Theta','\\u03B9':'iota','\\u0399':'Iota','\\u03BA':'kappa','\\u03F0':'kappav','\\u039A':'Kappa','\\u03BB':'lambda','\\u039B':'Lambda','\\u03BC':'mu','\\xB5':'micro','\\u039C':'Mu','\\u03BD':'nu','\\u039D':'Nu','\\u03BE':'xi','\\u039E':'Xi','\\u03BF':'omicron','\\u039F':'Omicron','\\u03C0':'pi','\\u03D6':'piv','\\u03A0':'Pi','\\u03C1':'rho','\\u03F1':'rhov','\\u03A1':'Rho','\\u03C3':'sigma','\\u03A3':'Sigma','\\u03C2':'sigmaf','\\u03C4':'tau','\\u03A4':'Tau','\\u03C5':'upsi','\\u03A5':'Upsilon','\\u03D2':'Upsi','\\u03C6':'phi','\\u03D5':'phiv','\\u03A6':'Phi','\\u03C7':'chi','\\u03A7':'Chi','\\u03C8':'psi','\\u03A8':'Psi','\\u03C9':'omega','\\u03A9':'ohm','\\u0430':'acy','\\u0410':'Acy','\\u0431':'bcy','\\u0411':'Bcy','\\u0432':'vcy','\\u0412':'Vcy','\\u0433':'gcy','\\u0413':'Gcy','\\u0453':'gjcy','\\u0403':'GJcy','\\u0434':'dcy','\\u0414':'Dcy','\\u0452':'djcy','\\u0402':'DJcy','\\u0435':'iecy','\\u0415':'IEcy','\\u0451':'iocy','\\u0401':'IOcy','\\u0454':'jukcy','\\u0404':'Jukcy','\\u0436':'zhcy','\\u0416':'ZHcy','\\u0437':'zcy','\\u0417':'Zcy','\\u0455':'dscy','\\u0405':'DScy','\\u0438':'icy','\\u0418':'Icy','\\u0456':'iukcy','\\u0406':'Iukcy','\\u0457':'yicy','\\u0407':'YIcy','\\u0439':'jcy','\\u0419':'Jcy','\\u0458':'jsercy','\\u0408':'Jsercy','\\u043A':'kcy','\\u041A':'Kcy','\\u045C':'kjcy','\\u040C':'KJcy','\\u043B':'lcy','\\u041B':'Lcy','\\u0459':'ljcy','\\u0409':'LJcy','\\u043C':'mcy','\\u041C':'Mcy','\\u043D':'ncy','\\u041D':'Ncy','\\u045A':'njcy','\\u040A':'NJcy','\\u043E':'ocy','\\u041E':'Ocy','\\u043F':'pcy','\\u041F':'Pcy','\\u0440':'rcy','\\u0420':'Rcy','\\u0441':'scy','\\u0421':'Scy','\\u0442':'tcy','\\u0422':'Tcy','\\u045B':'tshcy','\\u040B':'TSHcy','\\u0443':'ucy','\\u0423':'Ucy','\\u045E':'ubrcy','\\u040E':'Ubrcy','\\u0444':'fcy','\\u0424':'Fcy','\\u0445':'khcy','\\u0425':'KHcy','\\u0446':'tscy','\\u0426':'TScy','\\u0447':'chcy','\\u0427':'CHcy','\\u045F':'dzcy','\\u040F':'DZcy','\\u0448':'shcy','\\u0428':'SHcy','\\u0449':'shchcy','\\u0429':'SHCHcy','\\u044A':'hardcy','\\u042A':'HARDcy','\\u044B':'ycy','\\u042B':'Ycy','\\u044C':'softcy','\\u042C':'SOFTcy','\\u044D':'ecy','\\u042D':'Ecy','\\u044E':'yucy','\\u042E':'YUcy','\\u044F':'yacy','\\u042F':'YAcy','\\u2135':'aleph','\\u2136':'beth','\\u2137':'gimel','\\u2138':'daleth'};\n\n\tvar regexEscape = /[\"&'<>`]/g;\n\tvar escapeMap = {\n\t\t'\"': '&quot;',\n\t\t'&': '&amp;',\n\t\t'\\'': '&#x27;',\n\t\t'<': '&lt;',\n\t\t// See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the\n\t\t// following is not strictly necessary unless it’s part of a tag or an\n\t\t// unquoted attribute value. We’re only escaping it to support those\n\t\t// situations, and for XML support.\n\t\t'>': '&gt;',\n\t\t// In Internet Explorer ≤ 8, the backtick character can be used\n\t\t// to break out of (un)quoted attribute values or HTML comments.\n\t\t// See http://html5sec.org/#102, http://html5sec.org/#108, and\n\t\t// http://html5sec.org/#133.\n\t\t'`': '&#x60;'\n\t};\n\n\tvar regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;\n\tvar regexInvalidRawCodePoint = /[\\0-\\x08\\x0B\\x0E-\\x1F\\x7F-\\x9F\\uFDD0-\\uFDEF\\uFFFE\\uFFFF]|[\\uD83F\\uD87F\\uD8BF\\uD8FF\\uD93F\\uD97F\\uD9BF\\uD9FF\\uDA3F\\uDA7F\\uDABF\\uDAFF\\uDB3F\\uDB7F\\uDBBF\\uDBFF][\\uDFFE\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n\tvar regexDecode = /&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)([=a-zA-Z0-9])?/g;\n\tvar decodeMap = {'aacute':'\\xE1','Aacute':'\\xC1','abreve':'\\u0103','Abreve':'\\u0102','ac':'\\u223E','acd':'\\u223F','acE':'\\u223E\\u0333','acirc':'\\xE2','Acirc':'\\xC2','acute':'\\xB4','acy':'\\u0430','Acy':'\\u0410','aelig':'\\xE6','AElig':'\\xC6','af':'\\u2061','afr':'\\uD835\\uDD1E','Afr':'\\uD835\\uDD04','agrave':'\\xE0','Agrave':'\\xC0','alefsym':'\\u2135','aleph':'\\u2135','alpha':'\\u03B1','Alpha':'\\u0391','amacr':'\\u0101','Amacr':'\\u0100','amalg':'\\u2A3F','amp':'&','AMP':'&','and':'\\u2227','And':'\\u2A53','andand':'\\u2A55','andd':'\\u2A5C','andslope':'\\u2A58','andv':'\\u2A5A','ang':'\\u2220','ange':'\\u29A4','angle':'\\u2220','angmsd':'\\u2221','angmsdaa':'\\u29A8','angmsdab':'\\u29A9','angmsdac':'\\u29AA','angmsdad':'\\u29AB','angmsdae':'\\u29AC','angmsdaf':'\\u29AD','angmsdag':'\\u29AE','angmsdah':'\\u29AF','angrt':'\\u221F','angrtvb':'\\u22BE','angrtvbd':'\\u299D','angsph':'\\u2222','angst':'\\xC5','angzarr':'\\u237C','aogon':'\\u0105','Aogon':'\\u0104','aopf':'\\uD835\\uDD52','Aopf':'\\uD835\\uDD38','ap':'\\u2248','apacir':'\\u2A6F','ape':'\\u224A','apE':'\\u2A70','apid':'\\u224B','apos':'\\'','ApplyFunction':'\\u2061','approx':'\\u2248','approxeq':'\\u224A','aring':'\\xE5','Aring':'\\xC5','ascr':'\\uD835\\uDCB6','Ascr':'\\uD835\\uDC9C','Assign':'\\u2254','ast':'*','asymp':'\\u2248','asympeq':'\\u224D','atilde':'\\xE3','Atilde':'\\xC3','auml':'\\xE4','Auml':'\\xC4','awconint':'\\u2233','awint':'\\u2A11','backcong':'\\u224C','backepsilon':'\\u03F6','backprime':'\\u2035','backsim':'\\u223D','backsimeq':'\\u22CD','Backslash':'\\u2216','Barv':'\\u2AE7','barvee':'\\u22BD','barwed':'\\u2305','Barwed':'\\u2306','barwedge':'\\u2305','bbrk':'\\u23B5','bbrktbrk':'\\u23B6','bcong':'\\u224C','bcy':'\\u0431','Bcy':'\\u0411','bdquo':'\\u201E','becaus':'\\u2235','because':'\\u2235','Because':'\\u2235','bemptyv':'\\u29B0','bepsi':'\\u03F6','bernou':'\\u212C','Bernoullis':'\\u212C','beta':'\\u03B2','Beta':'\\u0392','beth':'\\u2136','between':'\\u226C','bfr':'\\uD835\\uDD1F','Bfr':'\\uD835\\uDD05','bigcap':'\\u22C2','bigcirc':'\\u25EF','bigcup':'\\u22C3','bigodot':'\\u2A00','bigoplus':'\\u2A01','bigotimes':'\\u2A02','bigsqcup':'\\u2A06','bigstar':'\\u2605','bigtriangledown':'\\u25BD','bigtriangleup':'\\u25B3','biguplus':'\\u2A04','bigvee':'\\u22C1','bigwedge':'\\u22C0','bkarow':'\\u290D','blacklozenge':'\\u29EB','blacksquare':'\\u25AA','blacktriangle':'\\u25B4','blacktriangledown':'\\u25BE','blacktriangleleft':'\\u25C2','blacktriangleright':'\\u25B8','blank':'\\u2423','blk12':'\\u2592','blk14':'\\u2591','blk34':'\\u2593','block':'\\u2588','bne':'=\\u20E5','bnequiv':'\\u2261\\u20E5','bnot':'\\u2310','bNot':'\\u2AED','bopf':'\\uD835\\uDD53','Bopf':'\\uD835\\uDD39','bot':'\\u22A5','bottom':'\\u22A5','bowtie':'\\u22C8','boxbox':'\\u29C9','boxdl':'\\u2510','boxdL':'\\u2555','boxDl':'\\u2556','boxDL':'\\u2557','boxdr':'\\u250C','boxdR':'\\u2552','boxDr':'\\u2553','boxDR':'\\u2554','boxh':'\\u2500','boxH':'\\u2550','boxhd':'\\u252C','boxhD':'\\u2565','boxHd':'\\u2564','boxHD':'\\u2566','boxhu':'\\u2534','boxhU':'\\u2568','boxHu':'\\u2567','boxHU':'\\u2569','boxminus':'\\u229F','boxplus':'\\u229E','boxtimes':'\\u22A0','boxul':'\\u2518','boxuL':'\\u255B','boxUl':'\\u255C','boxUL':'\\u255D','boxur':'\\u2514','boxuR':'\\u2558','boxUr':'\\u2559','boxUR':'\\u255A','boxv':'\\u2502','boxV':'\\u2551','boxvh':'\\u253C','boxvH':'\\u256A','boxVh':'\\u256B','boxVH':'\\u256C','boxvl':'\\u2524','boxvL':'\\u2561','boxVl':'\\u2562','boxVL':'\\u2563','boxvr':'\\u251C','boxvR':'\\u255E','boxVr':'\\u255F','boxVR':'\\u2560','bprime':'\\u2035','breve':'\\u02D8','Breve':'\\u02D8','brvbar':'\\xA6','bscr':'\\uD835\\uDCB7','Bscr':'\\u212C','bsemi':'\\u204F','bsim':'\\u223D','bsime':'\\u22CD','bsol':'\\\\','bsolb':'\\u29C5','bsolhsub':'\\u27C8','bull':'\\u2022','bullet':'\\u2022','bump':'\\u224E','bumpe':'\\u224F','bumpE':'\\u2AAE','bumpeq':'\\u224F','Bumpeq':'\\u224E','cacute':'\\u0107','Cacute':'\\u0106','cap':'\\u2229','Cap':'\\u22D2','capand':'\\u2A44','capbrcup':'\\u2A49','capcap':'\\u2A4B','capcup':'\\u2A47','capdot':'\\u2A40','CapitalDifferentialD':'\\u2145','caps':'\\u2229\\uFE00','caret':'\\u2041','caron':'\\u02C7','Cayleys':'\\u212D','ccaps':'\\u2A4D','ccaron':'\\u010D','Ccaron':'\\u010C','ccedil':'\\xE7','Ccedil':'\\xC7','ccirc':'\\u0109','Ccirc':'\\u0108','Cconint':'\\u2230','ccups':'\\u2A4C','ccupssm':'\\u2A50','cdot':'\\u010B','Cdot':'\\u010A','cedil':'\\xB8','Cedilla':'\\xB8','cemptyv':'\\u29B2','cent':'\\xA2','centerdot':'\\xB7','CenterDot':'\\xB7','cfr':'\\uD835\\uDD20','Cfr':'\\u212D','chcy':'\\u0447','CHcy':'\\u0427','check':'\\u2713','checkmark':'\\u2713','chi':'\\u03C7','Chi':'\\u03A7','cir':'\\u25CB','circ':'\\u02C6','circeq':'\\u2257','circlearrowleft':'\\u21BA','circlearrowright':'\\u21BB','circledast':'\\u229B','circledcirc':'\\u229A','circleddash':'\\u229D','CircleDot':'\\u2299','circledR':'\\xAE','circledS':'\\u24C8','CircleMinus':'\\u2296','CirclePlus':'\\u2295','CircleTimes':'\\u2297','cire':'\\u2257','cirE':'\\u29C3','cirfnint':'\\u2A10','cirmid':'\\u2AEF','cirscir':'\\u29C2','ClockwiseContourIntegral':'\\u2232','CloseCurlyDoubleQuote':'\\u201D','CloseCurlyQuote':'\\u2019','clubs':'\\u2663','clubsuit':'\\u2663','colon':':','Colon':'\\u2237','colone':'\\u2254','Colone':'\\u2A74','coloneq':'\\u2254','comma':',','commat':'@','comp':'\\u2201','compfn':'\\u2218','complement':'\\u2201','complexes':'\\u2102','cong':'\\u2245','congdot':'\\u2A6D','Congruent':'\\u2261','conint':'\\u222E','Conint':'\\u222F','ContourIntegral':'\\u222E','copf':'\\uD835\\uDD54','Copf':'\\u2102','coprod':'\\u2210','Coproduct':'\\u2210','copy':'\\xA9','COPY':'\\xA9','copysr':'\\u2117','CounterClockwiseContourIntegral':'\\u2233','crarr':'\\u21B5','cross':'\\u2717','Cross':'\\u2A2F','cscr':'\\uD835\\uDCB8','Cscr':'\\uD835\\uDC9E','csub':'\\u2ACF','csube':'\\u2AD1','csup':'\\u2AD0','csupe':'\\u2AD2','ctdot':'\\u22EF','cudarrl':'\\u2938','cudarrr':'\\u2935','cuepr':'\\u22DE','cuesc':'\\u22DF','cularr':'\\u21B6','cularrp':'\\u293D','cup':'\\u222A','Cup':'\\u22D3','cupbrcap':'\\u2A48','cupcap':'\\u2A46','CupCap':'\\u224D','cupcup':'\\u2A4A','cupdot':'\\u228D','cupor':'\\u2A45','cups':'\\u222A\\uFE00','curarr':'\\u21B7','curarrm':'\\u293C','curlyeqprec':'\\u22DE','curlyeqsucc':'\\u22DF','curlyvee':'\\u22CE','curlywedge':'\\u22CF','curren':'\\xA4','curvearrowleft':'\\u21B6','curvearrowright':'\\u21B7','cuvee':'\\u22CE','cuwed':'\\u22CF','cwconint':'\\u2232','cwint':'\\u2231','cylcty':'\\u232D','dagger':'\\u2020','Dagger':'\\u2021','daleth':'\\u2138','darr':'\\u2193','dArr':'\\u21D3','Darr':'\\u21A1','dash':'\\u2010','dashv':'\\u22A3','Dashv':'\\u2AE4','dbkarow':'\\u290F','dblac':'\\u02DD','dcaron':'\\u010F','Dcaron':'\\u010E','dcy':'\\u0434','Dcy':'\\u0414','dd':'\\u2146','DD':'\\u2145','ddagger':'\\u2021','ddarr':'\\u21CA','DDotrahd':'\\u2911','ddotseq':'\\u2A77','deg':'\\xB0','Del':'\\u2207','delta':'\\u03B4','Delta':'\\u0394','demptyv':'\\u29B1','dfisht':'\\u297F','dfr':'\\uD835\\uDD21','Dfr':'\\uD835\\uDD07','dHar':'\\u2965','dharl':'\\u21C3','dharr':'\\u21C2','DiacriticalAcute':'\\xB4','DiacriticalDot':'\\u02D9','DiacriticalDoubleAcute':'\\u02DD','DiacriticalGrave':'`','DiacriticalTilde':'\\u02DC','diam':'\\u22C4','diamond':'\\u22C4','Diamond':'\\u22C4','diamondsuit':'\\u2666','diams':'\\u2666','die':'\\xA8','DifferentialD':'\\u2146','digamma':'\\u03DD','disin':'\\u22F2','div':'\\xF7','divide':'\\xF7','divideontimes':'\\u22C7','divonx':'\\u22C7','djcy':'\\u0452','DJcy':'\\u0402','dlcorn':'\\u231E','dlcrop':'\\u230D','dollar':'$','dopf':'\\uD835\\uDD55','Dopf':'\\uD835\\uDD3B','dot':'\\u02D9','Dot':'\\xA8','DotDot':'\\u20DC','doteq':'\\u2250','doteqdot':'\\u2251','DotEqual':'\\u2250','dotminus':'\\u2238','dotplus':'\\u2214','dotsquare':'\\u22A1','doublebarwedge':'\\u2306','DoubleContourIntegral':'\\u222F','DoubleDot':'\\xA8','DoubleDownArrow':'\\u21D3','DoubleLeftArrow':'\\u21D0','DoubleLeftRightArrow':'\\u21D4','DoubleLeftTee':'\\u2AE4','DoubleLongLeftArrow':'\\u27F8','DoubleLongLeftRightArrow':'\\u27FA','DoubleLongRightArrow':'\\u27F9','DoubleRightArrow':'\\u21D2','DoubleRightTee':'\\u22A8','DoubleUpArrow':'\\u21D1','DoubleUpDownArrow':'\\u21D5','DoubleVerticalBar':'\\u2225','downarrow':'\\u2193','Downarrow':'\\u21D3','DownArrow':'\\u2193','DownArrowBar':'\\u2913','DownArrowUpArrow':'\\u21F5','DownBreve':'\\u0311','downdownarrows':'\\u21CA','downharpoonleft':'\\u21C3','downharpoonright':'\\u21C2','DownLeftRightVector':'\\u2950','DownLeftTeeVector':'\\u295E','DownLeftVector':'\\u21BD','DownLeftVectorBar':'\\u2956','DownRightTeeVector':'\\u295F','DownRightVector':'\\u21C1','DownRightVectorBar':'\\u2957','DownTee':'\\u22A4','DownTeeArrow':'\\u21A7','drbkarow':'\\u2910','drcorn':'\\u231F','drcrop':'\\u230C','dscr':'\\uD835\\uDCB9','Dscr':'\\uD835\\uDC9F','dscy':'\\u0455','DScy':'\\u0405','dsol':'\\u29F6','dstrok':'\\u0111','Dstrok':'\\u0110','dtdot':'\\u22F1','dtri':'\\u25BF','dtrif':'\\u25BE','duarr':'\\u21F5','duhar':'\\u296F','dwangle':'\\u29A6','dzcy':'\\u045F','DZcy':'\\u040F','dzigrarr':'\\u27FF','eacute':'\\xE9','Eacute':'\\xC9','easter':'\\u2A6E','ecaron':'\\u011B','Ecaron':'\\u011A','ecir':'\\u2256','ecirc':'\\xEA','Ecirc':'\\xCA','ecolon':'\\u2255','ecy':'\\u044D','Ecy':'\\u042D','eDDot':'\\u2A77','edot':'\\u0117','eDot':'\\u2251','Edot':'\\u0116','ee':'\\u2147','efDot':'\\u2252','efr':'\\uD835\\uDD22','Efr':'\\uD835\\uDD08','eg':'\\u2A9A','egrave':'\\xE8','Egrave':'\\xC8','egs':'\\u2A96','egsdot':'\\u2A98','el':'\\u2A99','Element':'\\u2208','elinters':'\\u23E7','ell':'\\u2113','els':'\\u2A95','elsdot':'\\u2A97','emacr':'\\u0113','Emacr':'\\u0112','empty':'\\u2205','emptyset':'\\u2205','EmptySmallSquare':'\\u25FB','emptyv':'\\u2205','EmptyVerySmallSquare':'\\u25AB','emsp':'\\u2003','emsp13':'\\u2004','emsp14':'\\u2005','eng':'\\u014B','ENG':'\\u014A','ensp':'\\u2002','eogon':'\\u0119','Eogon':'\\u0118','eopf':'\\uD835\\uDD56','Eopf':'\\uD835\\uDD3C','epar':'\\u22D5','eparsl':'\\u29E3','eplus':'\\u2A71','epsi':'\\u03B5','epsilon':'\\u03B5','Epsilon':'\\u0395','epsiv':'\\u03F5','eqcirc':'\\u2256','eqcolon':'\\u2255','eqsim':'\\u2242','eqslantgtr':'\\u2A96','eqslantless':'\\u2A95','Equal':'\\u2A75','equals':'=','EqualTilde':'\\u2242','equest':'\\u225F','Equilibrium':'\\u21CC','equiv':'\\u2261','equivDD':'\\u2A78','eqvparsl':'\\u29E5','erarr':'\\u2971','erDot':'\\u2253','escr':'\\u212F','Escr':'\\u2130','esdot':'\\u2250','esim':'\\u2242','Esim':'\\u2A73','eta':'\\u03B7','Eta':'\\u0397','eth':'\\xF0','ETH':'\\xD0','euml':'\\xEB','Euml':'\\xCB','euro':'\\u20AC','excl':'!','exist':'\\u2203','Exists':'\\u2203','expectation':'\\u2130','exponentiale':'\\u2147','ExponentialE':'\\u2147','fallingdotseq':'\\u2252','fcy':'\\u0444','Fcy':'\\u0424','female':'\\u2640','ffilig':'\\uFB03','fflig':'\\uFB00','ffllig':'\\uFB04','ffr':'\\uD835\\uDD23','Ffr':'\\uD835\\uDD09','filig':'\\uFB01','FilledSmallSquare':'\\u25FC','FilledVerySmallSquare':'\\u25AA','fjlig':'fj','flat':'\\u266D','fllig':'\\uFB02','fltns':'\\u25B1','fnof':'\\u0192','fopf':'\\uD835\\uDD57','Fopf':'\\uD835\\uDD3D','forall':'\\u2200','ForAll':'\\u2200','fork':'\\u22D4','forkv':'\\u2AD9','Fouriertrf':'\\u2131','fpartint':'\\u2A0D','frac12':'\\xBD','frac13':'\\u2153','frac14':'\\xBC','frac15':'\\u2155','frac16':'\\u2159','frac18':'\\u215B','frac23':'\\u2154','frac25':'\\u2156','frac34':'\\xBE','frac35':'\\u2157','frac38':'\\u215C','frac45':'\\u2158','frac56':'\\u215A','frac58':'\\u215D','frac78':'\\u215E','frasl':'\\u2044','frown':'\\u2322','fscr':'\\uD835\\uDCBB','Fscr':'\\u2131','gacute':'\\u01F5','gamma':'\\u03B3','Gamma':'\\u0393','gammad':'\\u03DD','Gammad':'\\u03DC','gap':'\\u2A86','gbreve':'\\u011F','Gbreve':'\\u011E','Gcedil':'\\u0122','gcirc':'\\u011D','Gcirc':'\\u011C','gcy':'\\u0433','Gcy':'\\u0413','gdot':'\\u0121','Gdot':'\\u0120','ge':'\\u2265','gE':'\\u2267','gel':'\\u22DB','gEl':'\\u2A8C','geq':'\\u2265','geqq':'\\u2267','geqslant':'\\u2A7E','ges':'\\u2A7E','gescc':'\\u2AA9','gesdot':'\\u2A80','gesdoto':'\\u2A82','gesdotol':'\\u2A84','gesl':'\\u22DB\\uFE00','gesles':'\\u2A94','gfr':'\\uD835\\uDD24','Gfr':'\\uD835\\uDD0A','gg':'\\u226B','Gg':'\\u22D9','ggg':'\\u22D9','gimel':'\\u2137','gjcy':'\\u0453','GJcy':'\\u0403','gl':'\\u2277','gla':'\\u2AA5','glE':'\\u2A92','glj':'\\u2AA4','gnap':'\\u2A8A','gnapprox':'\\u2A8A','gne':'\\u2A88','gnE':'\\u2269','gneq':'\\u2A88','gneqq':'\\u2269','gnsim':'\\u22E7','gopf':'\\uD835\\uDD58','Gopf':'\\uD835\\uDD3E','grave':'`','GreaterEqual':'\\u2265','GreaterEqualLess':'\\u22DB','GreaterFullEqual':'\\u2267','GreaterGreater':'\\u2AA2','GreaterLess':'\\u2277','GreaterSlantEqual':'\\u2A7E','GreaterTilde':'\\u2273','gscr':'\\u210A','Gscr':'\\uD835\\uDCA2','gsim':'\\u2273','gsime':'\\u2A8E','gsiml':'\\u2A90','gt':'>','Gt':'\\u226B','GT':'>','gtcc':'\\u2AA7','gtcir':'\\u2A7A','gtdot':'\\u22D7','gtlPar':'\\u2995','gtquest':'\\u2A7C','gtrapprox':'\\u2A86','gtrarr':'\\u2978','gtrdot':'\\u22D7','gtreqless':'\\u22DB','gtreqqless':'\\u2A8C','gtrless':'\\u2277','gtrsim':'\\u2273','gvertneqq':'\\u2269\\uFE00','gvnE':'\\u2269\\uFE00','Hacek':'\\u02C7','hairsp':'\\u200A','half':'\\xBD','hamilt':'\\u210B','hardcy':'\\u044A','HARDcy':'\\u042A','harr':'\\u2194','hArr':'\\u21D4','harrcir':'\\u2948','harrw':'\\u21AD','Hat':'^','hbar':'\\u210F','hcirc':'\\u0125','Hcirc':'\\u0124','hearts':'\\u2665','heartsuit':'\\u2665','hellip':'\\u2026','hercon':'\\u22B9','hfr':'\\uD835\\uDD25','Hfr':'\\u210C','HilbertSpace':'\\u210B','hksearow':'\\u2925','hkswarow':'\\u2926','hoarr':'\\u21FF','homtht':'\\u223B','hookleftarrow':'\\u21A9','hookrightarrow':'\\u21AA','hopf':'\\uD835\\uDD59','Hopf':'\\u210D','horbar':'\\u2015','HorizontalLine':'\\u2500','hscr':'\\uD835\\uDCBD','Hscr':'\\u210B','hslash':'\\u210F','hstrok':'\\u0127','Hstrok':'\\u0126','HumpDownHump':'\\u224E','HumpEqual':'\\u224F','hybull':'\\u2043','hyphen':'\\u2010','iacute':'\\xED','Iacute':'\\xCD','ic':'\\u2063','icirc':'\\xEE','Icirc':'\\xCE','icy':'\\u0438','Icy':'\\u0418','Idot':'\\u0130','iecy':'\\u0435','IEcy':'\\u0415','iexcl':'\\xA1','iff':'\\u21D4','ifr':'\\uD835\\uDD26','Ifr':'\\u2111','igrave':'\\xEC','Igrave':'\\xCC','ii':'\\u2148','iiiint':'\\u2A0C','iiint':'\\u222D','iinfin':'\\u29DC','iiota':'\\u2129','ijlig':'\\u0133','IJlig':'\\u0132','Im':'\\u2111','imacr':'\\u012B','Imacr':'\\u012A','image':'\\u2111','ImaginaryI':'\\u2148','imagline':'\\u2110','imagpart':'\\u2111','imath':'\\u0131','imof':'\\u22B7','imped':'\\u01B5','Implies':'\\u21D2','in':'\\u2208','incare':'\\u2105','infin':'\\u221E','infintie':'\\u29DD','inodot':'\\u0131','int':'\\u222B','Int':'\\u222C','intcal':'\\u22BA','integers':'\\u2124','Integral':'\\u222B','intercal':'\\u22BA','Intersection':'\\u22C2','intlarhk':'\\u2A17','intprod':'\\u2A3C','InvisibleComma':'\\u2063','InvisibleTimes':'\\u2062','iocy':'\\u0451','IOcy':'\\u0401','iogon':'\\u012F','Iogon':'\\u012E','iopf':'\\uD835\\uDD5A','Iopf':'\\uD835\\uDD40','iota':'\\u03B9','Iota':'\\u0399','iprod':'\\u2A3C','iquest':'\\xBF','iscr':'\\uD835\\uDCBE','Iscr':'\\u2110','isin':'\\u2208','isindot':'\\u22F5','isinE':'\\u22F9','isins':'\\u22F4','isinsv':'\\u22F3','isinv':'\\u2208','it':'\\u2062','itilde':'\\u0129','Itilde':'\\u0128','iukcy':'\\u0456','Iukcy':'\\u0406','iuml':'\\xEF','Iuml':'\\xCF','jcirc':'\\u0135','Jcirc':'\\u0134','jcy':'\\u0439','Jcy':'\\u0419','jfr':'\\uD835\\uDD27','Jfr':'\\uD835\\uDD0D','jmath':'\\u0237','jopf':'\\uD835\\uDD5B','Jopf':'\\uD835\\uDD41','jscr':'\\uD835\\uDCBF','Jscr':'\\uD835\\uDCA5','jsercy':'\\u0458','Jsercy':'\\u0408','jukcy':'\\u0454','Jukcy':'\\u0404','kappa':'\\u03BA','Kappa':'\\u039A','kappav':'\\u03F0','kcedil':'\\u0137','Kcedil':'\\u0136','kcy':'\\u043A','Kcy':'\\u041A','kfr':'\\uD835\\uDD28','Kfr':'\\uD835\\uDD0E','kgreen':'\\u0138','khcy':'\\u0445','KHcy':'\\u0425','kjcy':'\\u045C','KJcy':'\\u040C','kopf':'\\uD835\\uDD5C','Kopf':'\\uD835\\uDD42','kscr':'\\uD835\\uDCC0','Kscr':'\\uD835\\uDCA6','lAarr':'\\u21DA','lacute':'\\u013A','Lacute':'\\u0139','laemptyv':'\\u29B4','lagran':'\\u2112','lambda':'\\u03BB','Lambda':'\\u039B','lang':'\\u27E8','Lang':'\\u27EA','langd':'\\u2991','langle':'\\u27E8','lap':'\\u2A85','Laplacetrf':'\\u2112','laquo':'\\xAB','larr':'\\u2190','lArr':'\\u21D0','Larr':'\\u219E','larrb':'\\u21E4','larrbfs':'\\u291F','larrfs':'\\u291D','larrhk':'\\u21A9','larrlp':'\\u21AB','larrpl':'\\u2939','larrsim':'\\u2973','larrtl':'\\u21A2','lat':'\\u2AAB','latail':'\\u2919','lAtail':'\\u291B','late':'\\u2AAD','lates':'\\u2AAD\\uFE00','lbarr':'\\u290C','lBarr':'\\u290E','lbbrk':'\\u2772','lbrace':'{','lbrack':'[','lbrke':'\\u298B','lbrksld':'\\u298F','lbrkslu':'\\u298D','lcaron':'\\u013E','Lcaron':'\\u013D','lcedil':'\\u013C','Lcedil':'\\u013B','lceil':'\\u2308','lcub':'{','lcy':'\\u043B','Lcy':'\\u041B','ldca':'\\u2936','ldquo':'\\u201C','ldquor':'\\u201E','ldrdhar':'\\u2967','ldrushar':'\\u294B','ldsh':'\\u21B2','le':'\\u2264','lE':'\\u2266','LeftAngleBracket':'\\u27E8','leftarrow':'\\u2190','Leftarrow':'\\u21D0','LeftArrow':'\\u2190','LeftArrowBar':'\\u21E4','LeftArrowRightArrow':'\\u21C6','leftarrowtail':'\\u21A2','LeftCeiling':'\\u2308','LeftDoubleBracket':'\\u27E6','LeftDownTeeVector':'\\u2961','LeftDownVector':'\\u21C3','LeftDownVectorBar':'\\u2959','LeftFloor':'\\u230A','leftharpoondown':'\\u21BD','leftharpoonup':'\\u21BC','leftleftarrows':'\\u21C7','leftrightarrow':'\\u2194','Leftrightarrow':'\\u21D4','LeftRightArrow':'\\u2194','leftrightarrows':'\\u21C6','leftrightharpoons':'\\u21CB','leftrightsquigarrow':'\\u21AD','LeftRightVector':'\\u294E','LeftTee':'\\u22A3','LeftTeeArrow':'\\u21A4','LeftTeeVector':'\\u295A','leftthreetimes':'\\u22CB','LeftTriangle':'\\u22B2','LeftTriangleBar':'\\u29CF','LeftTriangleEqual':'\\u22B4','LeftUpDownVector':'\\u2951','LeftUpTeeVector':'\\u2960','LeftUpVector':'\\u21BF','LeftUpVectorBar':'\\u2958','LeftVector':'\\u21BC','LeftVectorBar':'\\u2952','leg':'\\u22DA','lEg':'\\u2A8B','leq':'\\u2264','leqq':'\\u2266','leqslant':'\\u2A7D','les':'\\u2A7D','lescc':'\\u2AA8','lesdot':'\\u2A7F','lesdoto':'\\u2A81','lesdotor':'\\u2A83','lesg':'\\u22DA\\uFE00','lesges':'\\u2A93','lessapprox':'\\u2A85','lessdot':'\\u22D6','lesseqgtr':'\\u22DA','lesseqqgtr':'\\u2A8B','LessEqualGreater':'\\u22DA','LessFullEqual':'\\u2266','LessGreater':'\\u2276','lessgtr':'\\u2276','LessLess':'\\u2AA1','lesssim':'\\u2272','LessSlantEqual':'\\u2A7D','LessTilde':'\\u2272','lfisht':'\\u297C','lfloor':'\\u230A','lfr':'\\uD835\\uDD29','Lfr':'\\uD835\\uDD0F','lg':'\\u2276','lgE':'\\u2A91','lHar':'\\u2962','lhard':'\\u21BD','lharu':'\\u21BC','lharul':'\\u296A','lhblk':'\\u2584','ljcy':'\\u0459','LJcy':'\\u0409','ll':'\\u226A','Ll':'\\u22D8','llarr':'\\u21C7','llcorner':'\\u231E','Lleftarrow':'\\u21DA','llhard':'\\u296B','lltri':'\\u25FA','lmidot':'\\u0140','Lmidot':'\\u013F','lmoust':'\\u23B0','lmoustache':'\\u23B0','lnap':'\\u2A89','lnapprox':'\\u2A89','lne':'\\u2A87','lnE':'\\u2268','lneq':'\\u2A87','lneqq':'\\u2268','lnsim':'\\u22E6','loang':'\\u27EC','loarr':'\\u21FD','lobrk':'\\u27E6','longleftarrow':'\\u27F5','Longleftarrow':'\\u27F8','LongLeftArrow':'\\u27F5','longleftrightarrow':'\\u27F7','Longleftrightarrow':'\\u27FA','LongLeftRightArrow':'\\u27F7','longmapsto':'\\u27FC','longrightarrow':'\\u27F6','Longrightarrow':'\\u27F9','LongRightArrow':'\\u27F6','looparrowleft':'\\u21AB','looparrowright':'\\u21AC','lopar':'\\u2985','lopf':'\\uD835\\uDD5D','Lopf':'\\uD835\\uDD43','loplus':'\\u2A2D','lotimes':'\\u2A34','lowast':'\\u2217','lowbar':'_','LowerLeftArrow':'\\u2199','LowerRightArrow':'\\u2198','loz':'\\u25CA','lozenge':'\\u25CA','lozf':'\\u29EB','lpar':'(','lparlt':'\\u2993','lrarr':'\\u21C6','lrcorner':'\\u231F','lrhar':'\\u21CB','lrhard':'\\u296D','lrm':'\\u200E','lrtri':'\\u22BF','lsaquo':'\\u2039','lscr':'\\uD835\\uDCC1','Lscr':'\\u2112','lsh':'\\u21B0','Lsh':'\\u21B0','lsim':'\\u2272','lsime':'\\u2A8D','lsimg':'\\u2A8F','lsqb':'[','lsquo':'\\u2018','lsquor':'\\u201A','lstrok':'\\u0142','Lstrok':'\\u0141','lt':'<','Lt':'\\u226A','LT':'<','ltcc':'\\u2AA6','ltcir':'\\u2A79','ltdot':'\\u22D6','lthree':'\\u22CB','ltimes':'\\u22C9','ltlarr':'\\u2976','ltquest':'\\u2A7B','ltri':'\\u25C3','ltrie':'\\u22B4','ltrif':'\\u25C2','ltrPar':'\\u2996','lurdshar':'\\u294A','luruhar':'\\u2966','lvertneqq':'\\u2268\\uFE00','lvnE':'\\u2268\\uFE00','macr':'\\xAF','male':'\\u2642','malt':'\\u2720','maltese':'\\u2720','map':'\\u21A6','Map':'\\u2905','mapsto':'\\u21A6','mapstodown':'\\u21A7','mapstoleft':'\\u21A4','mapstoup':'\\u21A5','marker':'\\u25AE','mcomma':'\\u2A29','mcy':'\\u043C','Mcy':'\\u041C','mdash':'\\u2014','mDDot':'\\u223A','measuredangle':'\\u2221','MediumSpace':'\\u205F','Mellintrf':'\\u2133','mfr':'\\uD835\\uDD2A','Mfr':'\\uD835\\uDD10','mho':'\\u2127','micro':'\\xB5','mid':'\\u2223','midast':'*','midcir':'\\u2AF0','middot':'\\xB7','minus':'\\u2212','minusb':'\\u229F','minusd':'\\u2238','minusdu':'\\u2A2A','MinusPlus':'\\u2213','mlcp':'\\u2ADB','mldr':'\\u2026','mnplus':'\\u2213','models':'\\u22A7','mopf':'\\uD835\\uDD5E','Mopf':'\\uD835\\uDD44','mp':'\\u2213','mscr':'\\uD835\\uDCC2','Mscr':'\\u2133','mstpos':'\\u223E','mu':'\\u03BC','Mu':'\\u039C','multimap':'\\u22B8','mumap':'\\u22B8','nabla':'\\u2207','nacute':'\\u0144','Nacute':'\\u0143','nang':'\\u2220\\u20D2','nap':'\\u2249','napE':'\\u2A70\\u0338','napid':'\\u224B\\u0338','napos':'\\u0149','napprox':'\\u2249','natur':'\\u266E','natural':'\\u266E','naturals':'\\u2115','nbsp':'\\xA0','nbump':'\\u224E\\u0338','nbumpe':'\\u224F\\u0338','ncap':'\\u2A43','ncaron':'\\u0148','Ncaron':'\\u0147','ncedil':'\\u0146','Ncedil':'\\u0145','ncong':'\\u2247','ncongdot':'\\u2A6D\\u0338','ncup':'\\u2A42','ncy':'\\u043D','Ncy':'\\u041D','ndash':'\\u2013','ne':'\\u2260','nearhk':'\\u2924','nearr':'\\u2197','neArr':'\\u21D7','nearrow':'\\u2197','nedot':'\\u2250\\u0338','NegativeMediumSpace':'\\u200B','NegativeThickSpace':'\\u200B','NegativeThinSpace':'\\u200B','NegativeVeryThinSpace':'\\u200B','nequiv':'\\u2262','nesear':'\\u2928','nesim':'\\u2242\\u0338','NestedGreaterGreater':'\\u226B','NestedLessLess':'\\u226A','NewLine':'\\n','nexist':'\\u2204','nexists':'\\u2204','nfr':'\\uD835\\uDD2B','Nfr':'\\uD835\\uDD11','nge':'\\u2271','ngE':'\\u2267\\u0338','ngeq':'\\u2271','ngeqq':'\\u2267\\u0338','ngeqslant':'\\u2A7E\\u0338','nges':'\\u2A7E\\u0338','nGg':'\\u22D9\\u0338','ngsim':'\\u2275','ngt':'\\u226F','nGt':'\\u226B\\u20D2','ngtr':'\\u226F','nGtv':'\\u226B\\u0338','nharr':'\\u21AE','nhArr':'\\u21CE','nhpar':'\\u2AF2','ni':'\\u220B','nis':'\\u22FC','nisd':'\\u22FA','niv':'\\u220B','njcy':'\\u045A','NJcy':'\\u040A','nlarr':'\\u219A','nlArr':'\\u21CD','nldr':'\\u2025','nle':'\\u2270','nlE':'\\u2266\\u0338','nleftarrow':'\\u219A','nLeftarrow':'\\u21CD','nleftrightarrow':'\\u21AE','nLeftrightarrow':'\\u21CE','nleq':'\\u2270','nleqq':'\\u2266\\u0338','nleqslant':'\\u2A7D\\u0338','nles':'\\u2A7D\\u0338','nless':'\\u226E','nLl':'\\u22D8\\u0338','nlsim':'\\u2274','nlt':'\\u226E','nLt':'\\u226A\\u20D2','nltri':'\\u22EA','nltrie':'\\u22EC','nLtv':'\\u226A\\u0338','nmid':'\\u2224','NoBreak':'\\u2060','NonBreakingSpace':'\\xA0','nopf':'\\uD835\\uDD5F','Nopf':'\\u2115','not':'\\xAC','Not':'\\u2AEC','NotCongruent':'\\u2262','NotCupCap':'\\u226D','NotDoubleVerticalBar':'\\u2226','NotElement':'\\u2209','NotEqual':'\\u2260','NotEqualTilde':'\\u2242\\u0338','NotExists':'\\u2204','NotGreater':'\\u226F','NotGreaterEqual':'\\u2271','NotGreaterFullEqual':'\\u2267\\u0338','NotGreaterGreater':'\\u226B\\u0338','NotGreaterLess':'\\u2279','NotGreaterSlantEqual':'\\u2A7E\\u0338','NotGreaterTilde':'\\u2275','NotHumpDownHump':'\\u224E\\u0338','NotHumpEqual':'\\u224F\\u0338','notin':'\\u2209','notindot':'\\u22F5\\u0338','notinE':'\\u22F9\\u0338','notinva':'\\u2209','notinvb':'\\u22F7','notinvc':'\\u22F6','NotLeftTriangle':'\\u22EA','NotLeftTriangleBar':'\\u29CF\\u0338','NotLeftTriangleEqual':'\\u22EC','NotLess':'\\u226E','NotLessEqual':'\\u2270','NotLessGreater':'\\u2278','NotLessLess':'\\u226A\\u0338','NotLessSlantEqual':'\\u2A7D\\u0338','NotLessTilde':'\\u2274','NotNestedGreaterGreater':'\\u2AA2\\u0338','NotNestedLessLess':'\\u2AA1\\u0338','notni':'\\u220C','notniva':'\\u220C','notnivb':'\\u22FE','notnivc':'\\u22FD','NotPrecedes':'\\u2280','NotPrecedesEqual':'\\u2AAF\\u0338','NotPrecedesSlantEqual':'\\u22E0','NotReverseElement':'\\u220C','NotRightTriangle':'\\u22EB','NotRightTriangleBar':'\\u29D0\\u0338','NotRightTriangleEqual':'\\u22ED','NotSquareSubset':'\\u228F\\u0338','NotSquareSubsetEqual':'\\u22E2','NotSquareSuperset':'\\u2290\\u0338','NotSquareSupersetEqual':'\\u22E3','NotSubset':'\\u2282\\u20D2','NotSubsetEqual':'\\u2288','NotSucceeds':'\\u2281','NotSucceedsEqual':'\\u2AB0\\u0338','NotSucceedsSlantEqual':'\\u22E1','NotSucceedsTilde':'\\u227F\\u0338','NotSuperset':'\\u2283\\u20D2','NotSupersetEqual':'\\u2289','NotTilde':'\\u2241','NotTildeEqual':'\\u2244','NotTildeFullEqual':'\\u2247','NotTildeTilde':'\\u2249','NotVerticalBar':'\\u2224','npar':'\\u2226','nparallel':'\\u2226','nparsl':'\\u2AFD\\u20E5','npart':'\\u2202\\u0338','npolint':'\\u2A14','npr':'\\u2280','nprcue':'\\u22E0','npre':'\\u2AAF\\u0338','nprec':'\\u2280','npreceq':'\\u2AAF\\u0338','nrarr':'\\u219B','nrArr':'\\u21CF','nrarrc':'\\u2933\\u0338','nrarrw':'\\u219D\\u0338','nrightarrow':'\\u219B','nRightarrow':'\\u21CF','nrtri':'\\u22EB','nrtrie':'\\u22ED','nsc':'\\u2281','nsccue':'\\u22E1','nsce':'\\u2AB0\\u0338','nscr':'\\uD835\\uDCC3','Nscr':'\\uD835\\uDCA9','nshortmid':'\\u2224','nshortparallel':'\\u2226','nsim':'\\u2241','nsime':'\\u2244','nsimeq':'\\u2244','nsmid':'\\u2224','nspar':'\\u2226','nsqsube':'\\u22E2','nsqsupe':'\\u22E3','nsub':'\\u2284','nsube':'\\u2288','nsubE':'\\u2AC5\\u0338','nsubset':'\\u2282\\u20D2','nsubseteq':'\\u2288','nsubseteqq':'\\u2AC5\\u0338','nsucc':'\\u2281','nsucceq':'\\u2AB0\\u0338','nsup':'\\u2285','nsupe':'\\u2289','nsupE':'\\u2AC6\\u0338','nsupset':'\\u2283\\u20D2','nsupseteq':'\\u2289','nsupseteqq':'\\u2AC6\\u0338','ntgl':'\\u2279','ntilde':'\\xF1','Ntilde':'\\xD1','ntlg':'\\u2278','ntriangleleft':'\\u22EA','ntrianglelefteq':'\\u22EC','ntriangleright':'\\u22EB','ntrianglerighteq':'\\u22ED','nu':'\\u03BD','Nu':'\\u039D','num':'#','numero':'\\u2116','numsp':'\\u2007','nvap':'\\u224D\\u20D2','nvdash':'\\u22AC','nvDash':'\\u22AD','nVdash':'\\u22AE','nVDash':'\\u22AF','nvge':'\\u2265\\u20D2','nvgt':'>\\u20D2','nvHarr':'\\u2904','nvinfin':'\\u29DE','nvlArr':'\\u2902','nvle':'\\u2264\\u20D2','nvlt':'<\\u20D2','nvltrie':'\\u22B4\\u20D2','nvrArr':'\\u2903','nvrtrie':'\\u22B5\\u20D2','nvsim':'\\u223C\\u20D2','nwarhk':'\\u2923','nwarr':'\\u2196','nwArr':'\\u21D6','nwarrow':'\\u2196','nwnear':'\\u2927','oacute':'\\xF3','Oacute':'\\xD3','oast':'\\u229B','ocir':'\\u229A','ocirc':'\\xF4','Ocirc':'\\xD4','ocy':'\\u043E','Ocy':'\\u041E','odash':'\\u229D','odblac':'\\u0151','Odblac':'\\u0150','odiv':'\\u2A38','odot':'\\u2299','odsold':'\\u29BC','oelig':'\\u0153','OElig':'\\u0152','ofcir':'\\u29BF','ofr':'\\uD835\\uDD2C','Ofr':'\\uD835\\uDD12','ogon':'\\u02DB','ograve':'\\xF2','Ograve':'\\xD2','ogt':'\\u29C1','ohbar':'\\u29B5','ohm':'\\u03A9','oint':'\\u222E','olarr':'\\u21BA','olcir':'\\u29BE','olcross':'\\u29BB','oline':'\\u203E','olt':'\\u29C0','omacr':'\\u014D','Omacr':'\\u014C','omega':'\\u03C9','Omega':'\\u03A9','omicron':'\\u03BF','Omicron':'\\u039F','omid':'\\u29B6','ominus':'\\u2296','oopf':'\\uD835\\uDD60','Oopf':'\\uD835\\uDD46','opar':'\\u29B7','OpenCurlyDoubleQuote':'\\u201C','OpenCurlyQuote':'\\u2018','operp':'\\u29B9','oplus':'\\u2295','or':'\\u2228','Or':'\\u2A54','orarr':'\\u21BB','ord':'\\u2A5D','order':'\\u2134','orderof':'\\u2134','ordf':'\\xAA','ordm':'\\xBA','origof':'\\u22B6','oror':'\\u2A56','orslope':'\\u2A57','orv':'\\u2A5B','oS':'\\u24C8','oscr':'\\u2134','Oscr':'\\uD835\\uDCAA','oslash':'\\xF8','Oslash':'\\xD8','osol':'\\u2298','otilde':'\\xF5','Otilde':'\\xD5','otimes':'\\u2297','Otimes':'\\u2A37','otimesas':'\\u2A36','ouml':'\\xF6','Ouml':'\\xD6','ovbar':'\\u233D','OverBar':'\\u203E','OverBrace':'\\u23DE','OverBracket':'\\u23B4','OverParenthesis':'\\u23DC','par':'\\u2225','para':'\\xB6','parallel':'\\u2225','parsim':'\\u2AF3','parsl':'\\u2AFD','part':'\\u2202','PartialD':'\\u2202','pcy':'\\u043F','Pcy':'\\u041F','percnt':'%','period':'.','permil':'\\u2030','perp':'\\u22A5','pertenk':'\\u2031','pfr':'\\uD835\\uDD2D','Pfr':'\\uD835\\uDD13','phi':'\\u03C6','Phi':'\\u03A6','phiv':'\\u03D5','phmmat':'\\u2133','phone':'\\u260E','pi':'\\u03C0','Pi':'\\u03A0','pitchfork':'\\u22D4','piv':'\\u03D6','planck':'\\u210F','planckh':'\\u210E','plankv':'\\u210F','plus':'+','plusacir':'\\u2A23','plusb':'\\u229E','pluscir':'\\u2A22','plusdo':'\\u2214','plusdu':'\\u2A25','pluse':'\\u2A72','PlusMinus':'\\xB1','plusmn':'\\xB1','plussim':'\\u2A26','plustwo':'\\u2A27','pm':'\\xB1','Poincareplane':'\\u210C','pointint':'\\u2A15','popf':'\\uD835\\uDD61','Popf':'\\u2119','pound':'\\xA3','pr':'\\u227A','Pr':'\\u2ABB','prap':'\\u2AB7','prcue':'\\u227C','pre':'\\u2AAF','prE':'\\u2AB3','prec':'\\u227A','precapprox':'\\u2AB7','preccurlyeq':'\\u227C','Precedes':'\\u227A','PrecedesEqual':'\\u2AAF','PrecedesSlantEqual':'\\u227C','PrecedesTilde':'\\u227E','preceq':'\\u2AAF','precnapprox':'\\u2AB9','precneqq':'\\u2AB5','precnsim':'\\u22E8','precsim':'\\u227E','prime':'\\u2032','Prime':'\\u2033','primes':'\\u2119','prnap':'\\u2AB9','prnE':'\\u2AB5','prnsim':'\\u22E8','prod':'\\u220F','Product':'\\u220F','profalar':'\\u232E','profline':'\\u2312','profsurf':'\\u2313','prop':'\\u221D','Proportion':'\\u2237','Proportional':'\\u221D','propto':'\\u221D','prsim':'\\u227E','prurel':'\\u22B0','pscr':'\\uD835\\uDCC5','Pscr':'\\uD835\\uDCAB','psi':'\\u03C8','Psi':'\\u03A8','puncsp':'\\u2008','qfr':'\\uD835\\uDD2E','Qfr':'\\uD835\\uDD14','qint':'\\u2A0C','qopf':'\\uD835\\uDD62','Qopf':'\\u211A','qprime':'\\u2057','qscr':'\\uD835\\uDCC6','Qscr':'\\uD835\\uDCAC','quaternions':'\\u210D','quatint':'\\u2A16','quest':'?','questeq':'\\u225F','quot':'\"','QUOT':'\"','rAarr':'\\u21DB','race':'\\u223D\\u0331','racute':'\\u0155','Racute':'\\u0154','radic':'\\u221A','raemptyv':'\\u29B3','rang':'\\u27E9','Rang':'\\u27EB','rangd':'\\u2992','range':'\\u29A5','rangle':'\\u27E9','raquo':'\\xBB','rarr':'\\u2192','rArr':'\\u21D2','Rarr':'\\u21A0','rarrap':'\\u2975','rarrb':'\\u21E5','rarrbfs':'\\u2920','rarrc':'\\u2933','rarrfs':'\\u291E','rarrhk':'\\u21AA','rarrlp':'\\u21AC','rarrpl':'\\u2945','rarrsim':'\\u2974','rarrtl':'\\u21A3','Rarrtl':'\\u2916','rarrw':'\\u219D','ratail':'\\u291A','rAtail':'\\u291C','ratio':'\\u2236','rationals':'\\u211A','rbarr':'\\u290D','rBarr':'\\u290F','RBarr':'\\u2910','rbbrk':'\\u2773','rbrace':'}','rbrack':']','rbrke':'\\u298C','rbrksld':'\\u298E','rbrkslu':'\\u2990','rcaron':'\\u0159','Rcaron':'\\u0158','rcedil':'\\u0157','Rcedil':'\\u0156','rceil':'\\u2309','rcub':'}','rcy':'\\u0440','Rcy':'\\u0420','rdca':'\\u2937','rdldhar':'\\u2969','rdquo':'\\u201D','rdquor':'\\u201D','rdsh':'\\u21B3','Re':'\\u211C','real':'\\u211C','realine':'\\u211B','realpart':'\\u211C','reals':'\\u211D','rect':'\\u25AD','reg':'\\xAE','REG':'\\xAE','ReverseElement':'\\u220B','ReverseEquilibrium':'\\u21CB','ReverseUpEquilibrium':'\\u296F','rfisht':'\\u297D','rfloor':'\\u230B','rfr':'\\uD835\\uDD2F','Rfr':'\\u211C','rHar':'\\u2964','rhard':'\\u21C1','rharu':'\\u21C0','rharul':'\\u296C','rho':'\\u03C1','Rho':'\\u03A1','rhov':'\\u03F1','RightAngleBracket':'\\u27E9','rightarrow':'\\u2192','Rightarrow':'\\u21D2','RightArrow':'\\u2192','RightArrowBar':'\\u21E5','RightArrowLeftArrow':'\\u21C4','rightarrowtail':'\\u21A3','RightCeiling':'\\u2309','RightDoubleBracket':'\\u27E7','RightDownTeeVector':'\\u295D','RightDownVector':'\\u21C2','RightDownVectorBar':'\\u2955','RightFloor':'\\u230B','rightharpoondown':'\\u21C1','rightharpoonup':'\\u21C0','rightleftarrows':'\\u21C4','rightleftharpoons':'\\u21CC','rightrightarrows':'\\u21C9','rightsquigarrow':'\\u219D','RightTee':'\\u22A2','RightTeeArrow':'\\u21A6','RightTeeVector':'\\u295B','rightthreetimes':'\\u22CC','RightTriangle':'\\u22B3','RightTriangleBar':'\\u29D0','RightTriangleEqual':'\\u22B5','RightUpDownVector':'\\u294F','RightUpTeeVector':'\\u295C','RightUpVector':'\\u21BE','RightUpVectorBar':'\\u2954','RightVector':'\\u21C0','RightVectorBar':'\\u2953','ring':'\\u02DA','risingdotseq':'\\u2253','rlarr':'\\u21C4','rlhar':'\\u21CC','rlm':'\\u200F','rmoust':'\\u23B1','rmoustache':'\\u23B1','rnmid':'\\u2AEE','roang':'\\u27ED','roarr':'\\u21FE','robrk':'\\u27E7','ropar':'\\u2986','ropf':'\\uD835\\uDD63','Ropf':'\\u211D','roplus':'\\u2A2E','rotimes':'\\u2A35','RoundImplies':'\\u2970','rpar':')','rpargt':'\\u2994','rppolint':'\\u2A12','rrarr':'\\u21C9','Rrightarrow':'\\u21DB','rsaquo':'\\u203A','rscr':'\\uD835\\uDCC7','Rscr':'\\u211B','rsh':'\\u21B1','Rsh':'\\u21B1','rsqb':']','rsquo':'\\u2019','rsquor':'\\u2019','rthree':'\\u22CC','rtimes':'\\u22CA','rtri':'\\u25B9','rtrie':'\\u22B5','rtrif':'\\u25B8','rtriltri':'\\u29CE','RuleDelayed':'\\u29F4','ruluhar':'\\u2968','rx':'\\u211E','sacute':'\\u015B','Sacute':'\\u015A','sbquo':'\\u201A','sc':'\\u227B','Sc':'\\u2ABC','scap':'\\u2AB8','scaron':'\\u0161','Scaron':'\\u0160','sccue':'\\u227D','sce':'\\u2AB0','scE':'\\u2AB4','scedil':'\\u015F','Scedil':'\\u015E','scirc':'\\u015D','Scirc':'\\u015C','scnap':'\\u2ABA','scnE':'\\u2AB6','scnsim':'\\u22E9','scpolint':'\\u2A13','scsim':'\\u227F','scy':'\\u0441','Scy':'\\u0421','sdot':'\\u22C5','sdotb':'\\u22A1','sdote':'\\u2A66','searhk':'\\u2925','searr':'\\u2198','seArr':'\\u21D8','searrow':'\\u2198','sect':'\\xA7','semi':';','seswar':'\\u2929','setminus':'\\u2216','setmn':'\\u2216','sext':'\\u2736','sfr':'\\uD835\\uDD30','Sfr':'\\uD835\\uDD16','sfrown':'\\u2322','sharp':'\\u266F','shchcy':'\\u0449','SHCHcy':'\\u0429','shcy':'\\u0448','SHcy':'\\u0428','ShortDownArrow':'\\u2193','ShortLeftArrow':'\\u2190','shortmid':'\\u2223','shortparallel':'\\u2225','ShortRightArrow':'\\u2192','ShortUpArrow':'\\u2191','shy':'\\xAD','sigma':'\\u03C3','Sigma':'\\u03A3','sigmaf':'\\u03C2','sigmav':'\\u03C2','sim':'\\u223C','simdot':'\\u2A6A','sime':'\\u2243','simeq':'\\u2243','simg':'\\u2A9E','simgE':'\\u2AA0','siml':'\\u2A9D','simlE':'\\u2A9F','simne':'\\u2246','simplus':'\\u2A24','simrarr':'\\u2972','slarr':'\\u2190','SmallCircle':'\\u2218','smallsetminus':'\\u2216','smashp':'\\u2A33','smeparsl':'\\u29E4','smid':'\\u2223','smile':'\\u2323','smt':'\\u2AAA','smte':'\\u2AAC','smtes':'\\u2AAC\\uFE00','softcy':'\\u044C','SOFTcy':'\\u042C','sol':'/','solb':'\\u29C4','solbar':'\\u233F','sopf':'\\uD835\\uDD64','Sopf':'\\uD835\\uDD4A','spades':'\\u2660','spadesuit':'\\u2660','spar':'\\u2225','sqcap':'\\u2293','sqcaps':'\\u2293\\uFE00','sqcup':'\\u2294','sqcups':'\\u2294\\uFE00','Sqrt':'\\u221A','sqsub':'\\u228F','sqsube':'\\u2291','sqsubset':'\\u228F','sqsubseteq':'\\u2291','sqsup':'\\u2290','sqsupe':'\\u2292','sqsupset':'\\u2290','sqsupseteq':'\\u2292','squ':'\\u25A1','square':'\\u25A1','Square':'\\u25A1','SquareIntersection':'\\u2293','SquareSubset':'\\u228F','SquareSubsetEqual':'\\u2291','SquareSuperset':'\\u2290','SquareSupersetEqual':'\\u2292','SquareUnion':'\\u2294','squarf':'\\u25AA','squf':'\\u25AA','srarr':'\\u2192','sscr':'\\uD835\\uDCC8','Sscr':'\\uD835\\uDCAE','ssetmn':'\\u2216','ssmile':'\\u2323','sstarf':'\\u22C6','star':'\\u2606','Star':'\\u22C6','starf':'\\u2605','straightepsilon':'\\u03F5','straightphi':'\\u03D5','strns':'\\xAF','sub':'\\u2282','Sub':'\\u22D0','subdot':'\\u2ABD','sube':'\\u2286','subE':'\\u2AC5','subedot':'\\u2AC3','submult':'\\u2AC1','subne':'\\u228A','subnE':'\\u2ACB','subplus':'\\u2ABF','subrarr':'\\u2979','subset':'\\u2282','Subset':'\\u22D0','subseteq':'\\u2286','subseteqq':'\\u2AC5','SubsetEqual':'\\u2286','subsetneq':'\\u228A','subsetneqq':'\\u2ACB','subsim':'\\u2AC7','subsub':'\\u2AD5','subsup':'\\u2AD3','succ':'\\u227B','succapprox':'\\u2AB8','succcurlyeq':'\\u227D','Succeeds':'\\u227B','SucceedsEqual':'\\u2AB0','SucceedsSlantEqual':'\\u227D','SucceedsTilde':'\\u227F','succeq':'\\u2AB0','succnapprox':'\\u2ABA','succneqq':'\\u2AB6','succnsim':'\\u22E9','succsim':'\\u227F','SuchThat':'\\u220B','sum':'\\u2211','Sum':'\\u2211','sung':'\\u266A','sup':'\\u2283','Sup':'\\u22D1','sup1':'\\xB9','sup2':'\\xB2','sup3':'\\xB3','supdot':'\\u2ABE','supdsub':'\\u2AD8','supe':'\\u2287','supE':'\\u2AC6','supedot':'\\u2AC4','Superset':'\\u2283','SupersetEqual':'\\u2287','suphsol':'\\u27C9','suphsub':'\\u2AD7','suplarr':'\\u297B','supmult':'\\u2AC2','supne':'\\u228B','supnE':'\\u2ACC','supplus':'\\u2AC0','supset':'\\u2283','Supset':'\\u22D1','supseteq':'\\u2287','supseteqq':'\\u2AC6','supsetneq':'\\u228B','supsetneqq':'\\u2ACC','supsim':'\\u2AC8','supsub':'\\u2AD4','supsup':'\\u2AD6','swarhk':'\\u2926','swarr':'\\u2199','swArr':'\\u21D9','swarrow':'\\u2199','swnwar':'\\u292A','szlig':'\\xDF','Tab':'\\t','target':'\\u2316','tau':'\\u03C4','Tau':'\\u03A4','tbrk':'\\u23B4','tcaron':'\\u0165','Tcaron':'\\u0164','tcedil':'\\u0163','Tcedil':'\\u0162','tcy':'\\u0442','Tcy':'\\u0422','tdot':'\\u20DB','telrec':'\\u2315','tfr':'\\uD835\\uDD31','Tfr':'\\uD835\\uDD17','there4':'\\u2234','therefore':'\\u2234','Therefore':'\\u2234','theta':'\\u03B8','Theta':'\\u0398','thetasym':'\\u03D1','thetav':'\\u03D1','thickapprox':'\\u2248','thicksim':'\\u223C','ThickSpace':'\\u205F\\u200A','thinsp':'\\u2009','ThinSpace':'\\u2009','thkap':'\\u2248','thksim':'\\u223C','thorn':'\\xFE','THORN':'\\xDE','tilde':'\\u02DC','Tilde':'\\u223C','TildeEqual':'\\u2243','TildeFullEqual':'\\u2245','TildeTilde':'\\u2248','times':'\\xD7','timesb':'\\u22A0','timesbar':'\\u2A31','timesd':'\\u2A30','tint':'\\u222D','toea':'\\u2928','top':'\\u22A4','topbot':'\\u2336','topcir':'\\u2AF1','topf':'\\uD835\\uDD65','Topf':'\\uD835\\uDD4B','topfork':'\\u2ADA','tosa':'\\u2929','tprime':'\\u2034','trade':'\\u2122','TRADE':'\\u2122','triangle':'\\u25B5','triangledown':'\\u25BF','triangleleft':'\\u25C3','trianglelefteq':'\\u22B4','triangleq':'\\u225C','triangleright':'\\u25B9','trianglerighteq':'\\u22B5','tridot':'\\u25EC','trie':'\\u225C','triminus':'\\u2A3A','TripleDot':'\\u20DB','triplus':'\\u2A39','trisb':'\\u29CD','tritime':'\\u2A3B','trpezium':'\\u23E2','tscr':'\\uD835\\uDCC9','Tscr':'\\uD835\\uDCAF','tscy':'\\u0446','TScy':'\\u0426','tshcy':'\\u045B','TSHcy':'\\u040B','tstrok':'\\u0167','Tstrok':'\\u0166','twixt':'\\u226C','twoheadleftarrow':'\\u219E','twoheadrightarrow':'\\u21A0','uacute':'\\xFA','Uacute':'\\xDA','uarr':'\\u2191','uArr':'\\u21D1','Uarr':'\\u219F','Uarrocir':'\\u2949','ubrcy':'\\u045E','Ubrcy':'\\u040E','ubreve':'\\u016D','Ubreve':'\\u016C','ucirc':'\\xFB','Ucirc':'\\xDB','ucy':'\\u0443','Ucy':'\\u0423','udarr':'\\u21C5','udblac':'\\u0171','Udblac':'\\u0170','udhar':'\\u296E','ufisht':'\\u297E','ufr':'\\uD835\\uDD32','Ufr':'\\uD835\\uDD18','ugrave':'\\xF9','Ugrave':'\\xD9','uHar':'\\u2963','uharl':'\\u21BF','uharr':'\\u21BE','uhblk':'\\u2580','ulcorn':'\\u231C','ulcorner':'\\u231C','ulcrop':'\\u230F','ultri':'\\u25F8','umacr':'\\u016B','Umacr':'\\u016A','uml':'\\xA8','UnderBar':'_','UnderBrace':'\\u23DF','UnderBracket':'\\u23B5','UnderParenthesis':'\\u23DD','Union':'\\u22C3','UnionPlus':'\\u228E','uogon':'\\u0173','Uogon':'\\u0172','uopf':'\\uD835\\uDD66','Uopf':'\\uD835\\uDD4C','uparrow':'\\u2191','Uparrow':'\\u21D1','UpArrow':'\\u2191','UpArrowBar':'\\u2912','UpArrowDownArrow':'\\u21C5','updownarrow':'\\u2195','Updownarrow':'\\u21D5','UpDownArrow':'\\u2195','UpEquilibrium':'\\u296E','upharpoonleft':'\\u21BF','upharpoonright':'\\u21BE','uplus':'\\u228E','UpperLeftArrow':'\\u2196','UpperRightArrow':'\\u2197','upsi':'\\u03C5','Upsi':'\\u03D2','upsih':'\\u03D2','upsilon':'\\u03C5','Upsilon':'\\u03A5','UpTee':'\\u22A5','UpTeeArrow':'\\u21A5','upuparrows':'\\u21C8','urcorn':'\\u231D','urcorner':'\\u231D','urcrop':'\\u230E','uring':'\\u016F','Uring':'\\u016E','urtri':'\\u25F9','uscr':'\\uD835\\uDCCA','Uscr':'\\uD835\\uDCB0','utdot':'\\u22F0','utilde':'\\u0169','Utilde':'\\u0168','utri':'\\u25B5','utrif':'\\u25B4','uuarr':'\\u21C8','uuml':'\\xFC','Uuml':'\\xDC','uwangle':'\\u29A7','vangrt':'\\u299C','varepsilon':'\\u03F5','varkappa':'\\u03F0','varnothing':'\\u2205','varphi':'\\u03D5','varpi':'\\u03D6','varpropto':'\\u221D','varr':'\\u2195','vArr':'\\u21D5','varrho':'\\u03F1','varsigma':'\\u03C2','varsubsetneq':'\\u228A\\uFE00','varsubsetneqq':'\\u2ACB\\uFE00','varsupsetneq':'\\u228B\\uFE00','varsupsetneqq':'\\u2ACC\\uFE00','vartheta':'\\u03D1','vartriangleleft':'\\u22B2','vartriangleright':'\\u22B3','vBar':'\\u2AE8','Vbar':'\\u2AEB','vBarv':'\\u2AE9','vcy':'\\u0432','Vcy':'\\u0412','vdash':'\\u22A2','vDash':'\\u22A8','Vdash':'\\u22A9','VDash':'\\u22AB','Vdashl':'\\u2AE6','vee':'\\u2228','Vee':'\\u22C1','veebar':'\\u22BB','veeeq':'\\u225A','vellip':'\\u22EE','verbar':'|','Verbar':'\\u2016','vert':'|','Vert':'\\u2016','VerticalBar':'\\u2223','VerticalLine':'|','VerticalSeparator':'\\u2758','VerticalTilde':'\\u2240','VeryThinSpace':'\\u200A','vfr':'\\uD835\\uDD33','Vfr':'\\uD835\\uDD19','vltri':'\\u22B2','vnsub':'\\u2282\\u20D2','vnsup':'\\u2283\\u20D2','vopf':'\\uD835\\uDD67','Vopf':'\\uD835\\uDD4D','vprop':'\\u221D','vrtri':'\\u22B3','vscr':'\\uD835\\uDCCB','Vscr':'\\uD835\\uDCB1','vsubne':'\\u228A\\uFE00','vsubnE':'\\u2ACB\\uFE00','vsupne':'\\u228B\\uFE00','vsupnE':'\\u2ACC\\uFE00','Vvdash':'\\u22AA','vzigzag':'\\u299A','wcirc':'\\u0175','Wcirc':'\\u0174','wedbar':'\\u2A5F','wedge':'\\u2227','Wedge':'\\u22C0','wedgeq':'\\u2259','weierp':'\\u2118','wfr':'\\uD835\\uDD34','Wfr':'\\uD835\\uDD1A','wopf':'\\uD835\\uDD68','Wopf':'\\uD835\\uDD4E','wp':'\\u2118','wr':'\\u2240','wreath':'\\u2240','wscr':'\\uD835\\uDCCC','Wscr':'\\uD835\\uDCB2','xcap':'\\u22C2','xcirc':'\\u25EF','xcup':'\\u22C3','xdtri':'\\u25BD','xfr':'\\uD835\\uDD35','Xfr':'\\uD835\\uDD1B','xharr':'\\u27F7','xhArr':'\\u27FA','xi':'\\u03BE','Xi':'\\u039E','xlarr':'\\u27F5','xlArr':'\\u27F8','xmap':'\\u27FC','xnis':'\\u22FB','xodot':'\\u2A00','xopf':'\\uD835\\uDD69','Xopf':'\\uD835\\uDD4F','xoplus':'\\u2A01','xotime':'\\u2A02','xrarr':'\\u27F6','xrArr':'\\u27F9','xscr':'\\uD835\\uDCCD','Xscr':'\\uD835\\uDCB3','xsqcup':'\\u2A06','xuplus':'\\u2A04','xutri':'\\u25B3','xvee':'\\u22C1','xwedge':'\\u22C0','yacute':'\\xFD','Yacute':'\\xDD','yacy':'\\u044F','YAcy':'\\u042F','ycirc':'\\u0177','Ycirc':'\\u0176','ycy':'\\u044B','Ycy':'\\u042B','yen':'\\xA5','yfr':'\\uD835\\uDD36','Yfr':'\\uD835\\uDD1C','yicy':'\\u0457','YIcy':'\\u0407','yopf':'\\uD835\\uDD6A','Yopf':'\\uD835\\uDD50','yscr':'\\uD835\\uDCCE','Yscr':'\\uD835\\uDCB4','yucy':'\\u044E','YUcy':'\\u042E','yuml':'\\xFF','Yuml':'\\u0178','zacute':'\\u017A','Zacute':'\\u0179','zcaron':'\\u017E','Zcaron':'\\u017D','zcy':'\\u0437','Zcy':'\\u0417','zdot':'\\u017C','Zdot':'\\u017B','zeetrf':'\\u2128','ZeroWidthSpace':'\\u200B','zeta':'\\u03B6','Zeta':'\\u0396','zfr':'\\uD835\\uDD37','Zfr':'\\u2128','zhcy':'\\u0436','ZHcy':'\\u0416','zigrarr':'\\u21DD','zopf':'\\uD835\\uDD6B','Zopf':'\\u2124','zscr':'\\uD835\\uDCCF','Zscr':'\\uD835\\uDCB5','zwj':'\\u200D','zwnj':'\\u200C'};\n\tvar decodeMapLegacy = {'aacute':'\\xE1','Aacute':'\\xC1','acirc':'\\xE2','Acirc':'\\xC2','acute':'\\xB4','aelig':'\\xE6','AElig':'\\xC6','agrave':'\\xE0','Agrave':'\\xC0','amp':'&','AMP':'&','aring':'\\xE5','Aring':'\\xC5','atilde':'\\xE3','Atilde':'\\xC3','auml':'\\xE4','Auml':'\\xC4','brvbar':'\\xA6','ccedil':'\\xE7','Ccedil':'\\xC7','cedil':'\\xB8','cent':'\\xA2','copy':'\\xA9','COPY':'\\xA9','curren':'\\xA4','deg':'\\xB0','divide':'\\xF7','eacute':'\\xE9','Eacute':'\\xC9','ecirc':'\\xEA','Ecirc':'\\xCA','egrave':'\\xE8','Egrave':'\\xC8','eth':'\\xF0','ETH':'\\xD0','euml':'\\xEB','Euml':'\\xCB','frac12':'\\xBD','frac14':'\\xBC','frac34':'\\xBE','gt':'>','GT':'>','iacute':'\\xED','Iacute':'\\xCD','icirc':'\\xEE','Icirc':'\\xCE','iexcl':'\\xA1','igrave':'\\xEC','Igrave':'\\xCC','iquest':'\\xBF','iuml':'\\xEF','Iuml':'\\xCF','laquo':'\\xAB','lt':'<','LT':'<','macr':'\\xAF','micro':'\\xB5','middot':'\\xB7','nbsp':'\\xA0','not':'\\xAC','ntilde':'\\xF1','Ntilde':'\\xD1','oacute':'\\xF3','Oacute':'\\xD3','ocirc':'\\xF4','Ocirc':'\\xD4','ograve':'\\xF2','Ograve':'\\xD2','ordf':'\\xAA','ordm':'\\xBA','oslash':'\\xF8','Oslash':'\\xD8','otilde':'\\xF5','Otilde':'\\xD5','ouml':'\\xF6','Ouml':'\\xD6','para':'\\xB6','plusmn':'\\xB1','pound':'\\xA3','quot':'\"','QUOT':'\"','raquo':'\\xBB','reg':'\\xAE','REG':'\\xAE','sect':'\\xA7','shy':'\\xAD','sup1':'\\xB9','sup2':'\\xB2','sup3':'\\xB3','szlig':'\\xDF','thorn':'\\xFE','THORN':'\\xDE','times':'\\xD7','uacute':'\\xFA','Uacute':'\\xDA','ucirc':'\\xFB','Ucirc':'\\xDB','ugrave':'\\xF9','Ugrave':'\\xD9','uml':'\\xA8','uuml':'\\xFC','Uuml':'\\xDC','yacute':'\\xFD','Yacute':'\\xDD','yen':'\\xA5','yuml':'\\xFF'};\n\tvar decodeMapNumeric = {'0':'\\uFFFD','128':'\\u20AC','130':'\\u201A','131':'\\u0192','132':'\\u201E','133':'\\u2026','134':'\\u2020','135':'\\u2021','136':'\\u02C6','137':'\\u2030','138':'\\u0160','139':'\\u2039','140':'\\u0152','142':'\\u017D','145':'\\u2018','146':'\\u2019','147':'\\u201C','148':'\\u201D','149':'\\u2022','150':'\\u2013','151':'\\u2014','152':'\\u02DC','153':'\\u2122','154':'\\u0161','155':'\\u203A','156':'\\u0153','158':'\\u017E','159':'\\u0178'};\n\tvar invalidReferenceCodePoints = [1,2,3,4,5,6,7,8,11,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,64976,64977,64978,64979,64980,64981,64982,64983,64984,64985,64986,64987,64988,64989,64990,64991,64992,64993,64994,64995,64996,64997,64998,64999,65000,65001,65002,65003,65004,65005,65006,65007,65534,65535,131070,131071,196606,196607,262142,262143,327678,327679,393214,393215,458750,458751,524286,524287,589822,589823,655358,655359,720894,720895,786430,786431,851966,851967,917502,917503,983038,983039,1048574,1048575,1114110,1114111];\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar stringFromCharCode = String.fromCharCode;\n\n\tvar object = {};\n\tvar hasOwnProperty = object.hasOwnProperty;\n\tvar has = function(object, propertyName) {\n\t\treturn hasOwnProperty.call(object, propertyName);\n\t};\n\n\tvar contains = function(array, value) {\n\t\tvar index = -1;\n\t\tvar length = array.length;\n\t\twhile (++index < length) {\n\t\t\tif (array[index] == value) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\tvar merge = function(options, defaults) {\n\t\tif (!options) {\n\t\t\treturn defaults;\n\t\t}\n\t\tvar result = {};\n\t\tvar key;\n\t\tfor (key in defaults) {\n\t\t\t// A `hasOwnProperty` check is not needed here, since only recognized\n\t\t\t// option names are used anyway. Any others are ignored.\n\t\t\tresult[key] = has(options, key) ? options[key] : defaults[key];\n\t\t}\n\t\treturn result;\n\t};\n\n\t// Modified version of `ucs2encode`; see https://mths.be/punycode.\n\tvar codePointToSymbol = function(codePoint, strict) {\n\t\tvar output = '';\n\t\tif ((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF) {\n\t\t\t// See issue #4:\n\t\t\t// “Otherwise, if the number is in the range 0xD800 to 0xDFFF or is\n\t\t\t// greater than 0x10FFFF, then this is a parse error. Return a U+FFFD\n\t\t\t// REPLACEMENT CHARACTER.”\n\t\t\tif (strict) {\n\t\t\t\tparseError('character reference outside the permissible Unicode range');\n\t\t\t}\n\t\t\treturn '\\uFFFD';\n\t\t}\n\t\tif (has(decodeMapNumeric, codePoint)) {\n\t\t\tif (strict) {\n\t\t\t\tparseError('disallowed character reference');\n\t\t\t}\n\t\t\treturn decodeMapNumeric[codePoint];\n\t\t}\n\t\tif (strict && contains(invalidReferenceCodePoints, codePoint)) {\n\t\t\tparseError('disallowed character reference');\n\t\t}\n\t\tif (codePoint > 0xFFFF) {\n\t\t\tcodePoint -= 0x10000;\n\t\t\toutput += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);\n\t\t\tcodePoint = 0xDC00 | codePoint & 0x3FF;\n\t\t}\n\t\toutput += stringFromCharCode(codePoint);\n\t\treturn output;\n\t};\n\n\tvar hexEscape = function(codePoint) {\n\t\treturn '&#x' + codePoint.toString(16).toUpperCase() + ';';\n\t};\n\n\tvar decEscape = function(codePoint) {\n\t\treturn '&#' + codePoint + ';';\n\t};\n\n\tvar parseError = function(message) {\n\t\tthrow Error('Parse error: ' + message);\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar encode = function(string, options) {\n\t\toptions = merge(options, encode.options);\n\t\tvar strict = options.strict;\n\t\tif (strict && regexInvalidRawCodePoint.test(string)) {\n\t\t\tparseError('forbidden code point');\n\t\t}\n\t\tvar encodeEverything = options.encodeEverything;\n\t\tvar useNamedReferences = options.useNamedReferences;\n\t\tvar allowUnsafeSymbols = options.allowUnsafeSymbols;\n\t\tvar escapeCodePoint = options.decimal ? decEscape : hexEscape;\n\n\t\tvar escapeBmpSymbol = function(symbol) {\n\t\t\treturn escapeCodePoint(symbol.charCodeAt(0));\n\t\t};\n\n\t\tif (encodeEverything) {\n\t\t\t// Encode ASCII symbols.\n\t\t\tstring = string.replace(regexAsciiWhitelist, function(symbol) {\n\t\t\t\t// Use named references if requested & possible.\n\t\t\t\tif (useNamedReferences && has(encodeMap, symbol)) {\n\t\t\t\t\treturn '&' + encodeMap[symbol] + ';';\n\t\t\t\t}\n\t\t\t\treturn escapeBmpSymbol(symbol);\n\t\t\t});\n\t\t\t// Shorten a few escapes that represent two symbols, of which at least one\n\t\t\t// is within the ASCII range.\n\t\t\tif (useNamedReferences) {\n\t\t\t\tstring = string\n\t\t\t\t\t.replace(/&gt;\\u20D2/g, '&nvgt;')\n\t\t\t\t\t.replace(/&lt;\\u20D2/g, '&nvlt;')\n\t\t\t\t\t.replace(/&#x66;&#x6A;/g, '&fjlig;');\n\t\t\t}\n\t\t\t// Encode non-ASCII symbols.\n\t\t\tif (useNamedReferences) {\n\t\t\t\t// Encode non-ASCII symbols that can be replaced with a named reference.\n\t\t\t\tstring = string.replace(regexEncodeNonAscii, function(string) {\n\t\t\t\t\t// Note: there is no need to check `has(encodeMap, string)` here.\n\t\t\t\t\treturn '&' + encodeMap[string] + ';';\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Note: any remaining non-ASCII symbols are handled outside of the `if`.\n\t\t} else if (useNamedReferences) {\n\t\t\t// Apply named character references.\n\t\t\t// Encode `<>\"'&` using named character references.\n\t\t\tif (!allowUnsafeSymbols) {\n\t\t\t\tstring = string.replace(regexEscape, function(string) {\n\t\t\t\t\treturn '&' + encodeMap[string] + ';'; // no need to check `has()` here\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Shorten escapes that represent two symbols, of which at least one is\n\t\t\t// `<>\"'&`.\n\t\t\tstring = string\n\t\t\t\t.replace(/&gt;\\u20D2/g, '&nvgt;')\n\t\t\t\t.replace(/&lt;\\u20D2/g, '&nvlt;');\n\t\t\t// Encode non-ASCII symbols that can be replaced with a named reference.\n\t\t\tstring = string.replace(regexEncodeNonAscii, function(string) {\n\t\t\t\t// Note: there is no need to check `has(encodeMap, string)` here.\n\t\t\t\treturn '&' + encodeMap[string] + ';';\n\t\t\t});\n\t\t} else if (!allowUnsafeSymbols) {\n\t\t\t// Encode `<>\"'&` using hexadecimal escapes, now that they’re not handled\n\t\t\t// using named character references.\n\t\t\tstring = string.replace(regexEscape, escapeBmpSymbol);\n\t\t}\n\t\treturn string\n\t\t\t// Encode astral symbols.\n\t\t\t.replace(regexAstralSymbols, function($0) {\n\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\tvar high = $0.charCodeAt(0);\n\t\t\t\tvar low = $0.charCodeAt(1);\n\t\t\t\tvar codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;\n\t\t\t\treturn escapeCodePoint(codePoint);\n\t\t\t})\n\t\t\t// Encode any remaining BMP symbols that are not printable ASCII symbols\n\t\t\t// using a hexadecimal escape.\n\t\t\t.replace(regexBmpWhitelist, escapeBmpSymbol);\n\t};\n\t// Expose default options (so they can be overridden globally).\n\tencode.options = {\n\t\t'allowUnsafeSymbols': false,\n\t\t'encodeEverything': false,\n\t\t'strict': false,\n\t\t'useNamedReferences': false,\n\t\t'decimal' : false\n\t};\n\n\tvar decode = function(html, options) {\n\t\toptions = merge(options, decode.options);\n\t\tvar strict = options.strict;\n\t\tif (strict && regexInvalidEntity.test(html)) {\n\t\t\tparseError('malformed character reference');\n\t\t}\n\t\treturn html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7) {\n\t\t\tvar codePoint;\n\t\t\tvar semicolon;\n\t\t\tvar decDigits;\n\t\t\tvar hexDigits;\n\t\t\tvar reference;\n\t\t\tvar next;\n\t\t\tif ($1) {\n\t\t\t\t// Decode decimal escapes, e.g. `&#119558;`.\n\t\t\t\tdecDigits = $1;\n\t\t\t\tsemicolon = $2;\n\t\t\t\tif (strict && !semicolon) {\n\t\t\t\t\tparseError('character reference was not terminated by a semicolon');\n\t\t\t\t}\n\t\t\t\tcodePoint = parseInt(decDigits, 10);\n\t\t\t\treturn codePointToSymbol(codePoint, strict);\n\t\t\t}\n\t\t\tif ($3) {\n\t\t\t\t// Decode hexadecimal escapes, e.g. `&#x1D306;`.\n\t\t\t\thexDigits = $3;\n\t\t\t\tsemicolon = $4;\n\t\t\t\tif (strict && !semicolon) {\n\t\t\t\t\tparseError('character reference was not terminated by a semicolon');\n\t\t\t\t}\n\t\t\t\tcodePoint = parseInt(hexDigits, 16);\n\t\t\t\treturn codePointToSymbol(codePoint, strict);\n\t\t\t}\n\t\t\tif ($5) {\n\t\t\t\t// Decode named character references with trailing `;`, e.g. `&copy;`.\n\t\t\t\treference = $5;\n\t\t\t\tif (has(decodeMap, reference)) {\n\t\t\t\t\treturn decodeMap[reference];\n\t\t\t\t} else {\n\t\t\t\t\t// Ambiguous ampersand. https://mths.be/notes/ambiguous-ampersands\n\t\t\t\t\tif (strict) {\n\t\t\t\t\t\tparseError(\n\t\t\t\t\t\t\t'named character reference was not terminated by a semicolon'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn $0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If we’re still here, it’s a legacy reference for sure. No need for an\n\t\t\t// extra `if` check.\n\t\t\t// Decode named character references without trailing `;`, e.g. `&amp`\n\t\t\t// This is only a parse error if it gets converted to `&`, or if it is\n\t\t\t// followed by `=` in an attribute context.\n\t\t\treference = $6;\n\t\t\tnext = $7;\n\t\t\tif (next && options.isAttributeValue) {\n\t\t\t\tif (strict && next == '=') {\n\t\t\t\t\tparseError('`&` did not start a character reference');\n\t\t\t\t}\n\t\t\t\treturn $0;\n\t\t\t} else {\n\t\t\t\tif (strict) {\n\t\t\t\t\tparseError(\n\t\t\t\t\t\t'named character reference was not terminated by a semicolon'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t// Note: there is no need to check `has(decodeMapLegacy, reference)`.\n\t\t\t\treturn decodeMapLegacy[reference] + (next || '');\n\t\t\t}\n\t\t});\n\t};\n\t// Expose default options (so they can be overridden globally).\n\tdecode.options = {\n\t\t'isAttributeValue': false,\n\t\t'strict': false\n\t};\n\n\tvar escape = function(string) {\n\t\treturn string.replace(regexEscape, function($0) {\n\t\t\t// Note: there is no need to check `has(escapeMap, $0)` here.\n\t\t\treturn escapeMap[$0];\n\t\t});\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar he = {\n\t\t'version': '1.1.1',\n\t\t'encode': encode,\n\t\t'decode': decode,\n\t\t'escape': escape,\n\t\t'unescape': decode\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\tfalse\n\t) {\n\t\tdefine(function() {\n\t\t\treturn he;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = he;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (var key in he) {\n\t\t\t\thas(he, key) && (freeExports[key] = he[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.he = he;\n\t}\n\n}(this));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],49:[function(require,module,exports){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}],50:[function(require,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n},{}],51:[function(require,module,exports){\n/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n},{}],52:[function(require,module,exports){\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n},{}],53:[function(require,module,exports){\n(function (process){\nvar path = require('path');\nvar fs = require('fs');\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n\n}).call(this,require('_process'))\n},{\"_process\":56,\"fs\":40,\"path\":40}],54:[function(require,module,exports){\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n},{}],55:[function(require,module,exports){\n(function (process){\n'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = nextTick;\n} else {\n  module.exports = process.nextTick;\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n}).call(this,require('_process'))\n},{\"_process\":56}],56:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],57:[function(require,module,exports){\nmodule.exports = require('./lib/_stream_duplex.js');\n\n},{\"./lib/_stream_duplex.js\":58}],58:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nvar keys = objectKeys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  processNextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  processNextTick(cb, err);\n};\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n},{\"./_stream_readable\":60,\"./_stream_writable\":62,\"core-util-is\":42,\"inherits\":50,\"process-nextick-args\":55}],59:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n},{\"./_stream_transform\":61,\"core-util-is\":42,\"inherits\":50}],60:[function(require,module,exports){\n(function (process,global){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n// TODO(bmeurer): Change this back to const once hole checks are\n// properly optimized away early in Ignition+TurboFan.\n/*<replacement>*/\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') {\n    return emitter.prependListener(event, fn);\n  } else {\n    // This is a hack to make sure that our error handler is attached before any\n    // userland ones.  NEVER DO THIS. This is here only because this code needs\n    // to continue to work with older versions of Node.js that do not include\n    // the prependListener() method. The goal is to eventually remove this hack.\n    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n  }\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    processNextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        processNextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    processNextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    processNextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./_stream_duplex\":58,\"./internal/streams/BufferList\":63,\"./internal/streams/destroy\":64,\"./internal/streams/stream\":65,\"_process\":56,\"core-util-is\":42,\"events\":47,\"inherits\":50,\"isarray\":52,\"process-nextick-args\":55,\"safe-buffer\":70,\"string_decoder/\":72,\"util\":38}],61:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction TransformState(stream) {\n  this.afterTransform = function (er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n  this.writeencoding = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return stream.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.once('prefinish', function () {\n    if (typeof this._flush === 'function') this._flush(function (er, data) {\n      done(stream, er, data);\n    });else done(stream);\n  });\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (ts.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n},{\"./_stream_duplex\":58,\"core-util-is\":42,\"inherits\":50}],62:[function(require,module,exports){\n(function (process,global){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\n/*<replacement>*/\n\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*</replacement>*/\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  processNextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = _isUint8Array(chunk) && !state.objectMode;\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    processNextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    processNextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      processNextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) processNextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./_stream_duplex\":58,\"./internal/streams/destroy\":64,\"./internal/streams/stream\":65,\"_process\":56,\"core-util-is\":42,\"inherits\":50,\"process-nextick-args\":55,\"safe-buffer\":70,\"util-deprecate\":73}],63:[function(require,module,exports){\n'use strict';\n\n/*<replacement>*/\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n},{\"safe-buffer\":70}],64:[function(require,module,exports){\n'use strict';\n\n/*<replacement>*/\n\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      processNextTick(emitErrorNT, this, err);\n    }\n    return;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      processNextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};\n},{\"process-nextick-args\":55}],65:[function(require,module,exports){\nmodule.exports = require('events').EventEmitter;\n\n},{\"events\":47}],66:[function(require,module,exports){\nmodule.exports = require('./readable').PassThrough\n\n},{\"./readable\":67}],67:[function(require,module,exports){\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\n},{\"./lib/_stream_duplex.js\":58,\"./lib/_stream_passthrough.js\":59,\"./lib/_stream_readable.js\":60,\"./lib/_stream_transform.js\":61,\"./lib/_stream_writable.js\":62}],68:[function(require,module,exports){\nmodule.exports = require('./readable').Transform\n\n},{\"./readable\":67}],69:[function(require,module,exports){\nmodule.exports = require('./lib/_stream_writable.js');\n\n},{\"./lib/_stream_writable.js\":62}],70:[function(require,module,exports){\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n},{\"buffer\":41}],71:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n},{\"events\":47,\"inherits\":50,\"readable-stream/duplex.js\":57,\"readable-stream/passthrough.js\":66,\"readable-stream/readable.js\":67,\"readable-stream/transform.js\":68,\"readable-stream/writable.js\":69}],72:[function(require,module,exports){\n'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return -1;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// UTF-8 replacement characters ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd'.repeat(p);\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd'.repeat(p + 1);\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd'.repeat(p + 2);\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character for each buffered byte of a (partial)\n// character needs to be added to the output.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd'.repeat(this.lastTotal - this.lastNeed);\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n},{\"safe-buffer\":70}],73:[function(require,module,exports){\n(function (global){\n\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],74:[function(require,module,exports){\narguments[4][50][0].apply(exports,arguments)\n},{\"dup\":50}],75:[function(require,module,exports){\nmodule.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n},{}],76:[function(require,module,exports){\n(function (process,global){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./support/isBuffer\":75,\"_process\":56,\"inherits\":74}]},{},[1]);\n"

/***/ }),

/***/ "./node_modules/script-loader/addScript.js":
/*!*************************************************!*\
  !*** ./node_modules/script-loader/addScript.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	function log(error) {
		(typeof console !== "undefined")
		&& (console.error || console.log)("[Script Loader]", error);
	}

	// Check for IE =< 8
	function isIE() {
		return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
	}

	try {
		if (typeof execScript !== "undefined" && isIE()) {
			execScript(src);
		} else if (typeof eval !== "undefined") {
			eval.call(null, src);
		} else {
			log("EvalError: No eval function available");
		}
	} catch (error) {
		log(error);
	}
}


/***/ }),

/***/ "./node_modules/script-loader/index.js!./node_modules/mocha/mocha.js":
/*!******************************************************************!*\
  !*** ./node_modules/script-loader!./node_modules/mocha/mocha.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/mocha/mocha.js */ "./node_modules/raw-loader/index.js!./node_modules/mocha/mocha.js"))

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEvbW9jaGEuY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS1sb2FkZXIvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS9tb2NoYS5jc3M/ZDZlNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhLWxvYWRlci9zdGFydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL3dlYi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS9tb2NoYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL21vY2hhLmpzPzNmNjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQSw2QkFBNkIsbUJBQW1COztBQUVoRDs7QUFFQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7QUNORCx5Q0FBeUMsNENBQTRDOztBQUVyRjtBQUNBOzs7Ozs7Ozs7Ozs7QUNIQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7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aGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL2luZGV4LmpzIS4vdGVzdC9pbmRleC5qc1wiKTtcbiIsInJlcXVpcmUoXCIhIS9Vc2Vycy9hcnJhbS90dXJpbmcvcHJvamVjdHMvZ2FtZS10aW1lL25vZGVfbW9kdWxlcy9tb2NoYS1sb2FkZXIvd2ViLmpzXCIpO1xuaWYodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmluaXRNb2NoYVBoYW50b21KUykgeyB3aW5kb3cuaW5pdE1vY2hhUGhhbnRvbUpTKCk7IH1cbm1vY2hhLnNldHVwKHtcInVpXCI6XCJiZGRcIn0pO1xucmVxdWlyZShcIiEhL1VzZXJzL2FycmFtL3R1cmluZy9wcm9qZWN0cy9nYW1lLXRpbWUvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhL1VzZXJzL2FycmFtL3R1cmluZy9wcm9qZWN0cy9nYW1lLXRpbWUvdGVzdC9pbmRleC5qc1wiKVxucmVxdWlyZShcIiEhL1VzZXJzL2FycmFtL3R1cmluZy9wcm9qZWN0cy9nYW1lLXRpbWUvbm9kZV9tb2R1bGVzL21vY2hhLWxvYWRlci9zdGFydC5qc1wiKTtcbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoKTtcblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuXHRcdG1vY2hhLnN1aXRlLnN1aXRlcy5sZW5ndGggPSAwO1xuXHRcdHZhciBzdGF0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2NoYS1zdGF0cycpO1xuXHRcdHZhciByZXBvcnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9jaGEtcmVwb3J0Jyk7XG5cdFx0c3RhdHMgJiYgc3RhdHMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdGF0cyk7XG5cdFx0cmVwb3J0ICYmIHJlcG9ydC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHJlcG9ydCk7XG5cdH0pO1xufSIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi9tb2NoYS1sb2FkZXIvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBjaGFyc2V0IFxcXCJ1dGYtOFxcXCI7XFxuXFxuYm9keSB7XFxuICBtYXJnaW46MDtcXG59XFxuXFxuI21vY2hhIHtcXG4gIGZvbnQ6IDIwcHgvMS41IFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsIEhlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWY7XFxuICBtYXJnaW46IDYwcHggNTBweDtcXG59XFxuXFxuI21vY2hhIHVsLFxcbiNtb2NoYSBsaSB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG4jbW9jaGEgdWwge1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG59XFxuXFxuI21vY2hhIGgxLFxcbiNtb2NoYSBoMiB7XFxuICBtYXJnaW46IDA7XFxufVxcblxcbiNtb2NoYSBoMSB7XFxuICBtYXJnaW4tdG9wOiAxNXB4O1xcbiAgZm9udC1zaXplOiAxZW07XFxuICBmb250LXdlaWdodDogMjAwO1xcbn1cXG5cXG4jbW9jaGEgaDEgYSB7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICBjb2xvcjogaW5oZXJpdDtcXG59XFxuXFxuI21vY2hhIGgxIGE6aG92ZXIge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxufVxcblxcbiNtb2NoYSAuc3VpdGUgLnN1aXRlIGgxIHtcXG4gIG1hcmdpbi10b3A6IDA7XFxuICBmb250LXNpemU6IC44ZW07XFxufVxcblxcbiNtb2NoYSAuaGlkZGVuIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbiNtb2NoYSBoMiB7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4jbW9jaGEgLnN1aXRlIHtcXG4gIG1hcmdpbi1sZWZ0OiAxNXB4O1xcbn1cXG5cXG4jbW9jaGEgLnRlc3Qge1xcbiAgbWFyZ2luLWxlZnQ6IDE1cHg7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGVuZGluZzpob3ZlciBoMjo6YWZ0ZXIge1xcbiAgY29udGVudDogJyhwZW5kaW5nKSc7XFxuICBmb250LWZhbWlseTogYXJpYWwsIHNhbnMtc2VyaWY7XFxufVxcblxcbiNtb2NoYSAudGVzdC5wYXNzLm1lZGl1bSAuZHVyYXRpb24ge1xcbiAgYmFja2dyb3VuZDogI2MwOTg1MztcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBhc3Muc2xvdyAuZHVyYXRpb24ge1xcbiAgYmFja2dyb3VuZDogI2I5NGE0ODtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBhc3M6OmJlZm9yZSB7XFxuICBjb250ZW50OiAnXFxcXDI3MTMnO1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmbG9hdDogbGVmdDtcXG4gIG1hcmdpbi1yaWdodDogNXB4O1xcbiAgY29sb3I6ICMwMGQ2YjI7XFxufVxcblxcbiNtb2NoYSAudGVzdC5wYXNzIC5kdXJhdGlvbiB7XFxuICBmb250LXNpemU6IDlweDtcXG4gIG1hcmdpbi1sZWZ0OiA1cHg7XFxuICBwYWRkaW5nOiAycHggNXB4O1xcbiAgY29sb3I6ICNmZmY7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDFweCByZ2JhKDAsMCwwLC4yKTtcXG4gIC1tb3otYm94LXNoYWRvdzogaW5zZXQgMCAxcHggMXB4IHJnYmEoMCwwLDAsLjIpO1xcbiAgYm94LXNoYWRvdzogaW5zZXQgMCAxcHggMXB4IHJnYmEoMCwwLDAsLjIpO1xcbiAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiA1cHg7XFxuICAtbW96LWJvcmRlci1yYWRpdXM6IDVweDtcXG4gIC1tcy1ib3JkZXItcmFkaXVzOiA1cHg7XFxuICAtby1ib3JkZXItcmFkaXVzOiA1cHg7XFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxufVxcblxcbiNtb2NoYSAudGVzdC5wYXNzLmZhc3QgLmR1cmF0aW9uIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbiNtb2NoYSAudGVzdC5wZW5kaW5nIHtcXG4gIGNvbG9yOiAjMGI5N2M0O1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGVuZGluZzo6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6ICdcXFxcMjVFNic7XFxuICBjb2xvcjogIzBiOTdjNDtcXG59XFxuXFxuI21vY2hhIC50ZXN0LmZhaWwge1xcbiAgY29sb3I6ICNjMDA7XFxufVxcblxcbiNtb2NoYSAudGVzdC5mYWlsIHByZSB7XFxuICBjb2xvcjogYmxhY2s7XFxufVxcblxcbiNtb2NoYSAudGVzdC5mYWlsOjpiZWZvcmUge1xcbiAgY29udGVudDogJ1xcXFwyNzE2JztcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gIGNvbG9yOiAjYzAwO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QgcHJlLmVycm9yIHtcXG4gIGNvbG9yOiAjYzAwO1xcbiAgbWF4LWhlaWdodDogMzAwcHg7XFxuICBvdmVyZmxvdzogYXV0bztcXG59XFxuXFxuI21vY2hhIC50ZXN0IC5odG1sLWVycm9yIHtcXG4gIG92ZXJmbG93OiBhdXRvO1xcbiAgY29sb3I6IGJsYWNrO1xcbiAgbGluZS1oZWlnaHQ6IDEuNTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBjbGVhcjogbGVmdDtcXG4gIGZvbnQ6IDEycHgvMS41IG1vbmFjbywgbW9ub3NwYWNlO1xcbiAgbWFyZ2luOiA1cHg7XFxuICBwYWRkaW5nOiAxNXB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2VlZTtcXG4gIG1heC13aWR0aDogODUlOyAvKigxKSovXFxuICBtYXgtd2lkdGg6IC13ZWJraXQtY2FsYygxMDAlIC0gNDJweCk7XFxuICBtYXgtd2lkdGg6IC1tb3otY2FsYygxMDAlIC0gNDJweCk7XFxuICBtYXgtd2lkdGg6IGNhbGMoMTAwJSAtIDQycHgpOyAvKigyKSovXFxuICBtYXgtaGVpZ2h0OiAzMDBweDtcXG4gIHdvcmQtd3JhcDogYnJlYWstd29yZDtcXG4gIGJvcmRlci1ib3R0b20tY29sb3I6ICNkZGQ7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IDAgMXB4IDNweCAjZWVlO1xcbiAgLW1vei1ib3gtc2hhZG93OiAwIDFweCAzcHggI2VlZTtcXG4gIGJveC1zaGFkb3c6IDAgMXB4IDNweCAjZWVlO1xcbiAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiAzcHg7XFxuICAtbW96LWJvcmRlci1yYWRpdXM6IDNweDtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG59XFxuXFxuI21vY2hhIC50ZXN0IC5odG1sLWVycm9yIHByZS5lcnJvciB7XFxuICBib3JkZXI6IG5vbmU7XFxuICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDA7XFxuICAtbW96LWJvcmRlci1yYWRpdXM6IDA7XFxuICBib3JkZXItcmFkaXVzOiAwO1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiAwO1xcbiAgLW1vei1ib3gtc2hhZG93OiAwO1xcbiAgYm94LXNoYWRvdzogMDtcXG4gIHBhZGRpbmc6IDA7XFxuICBtYXJnaW46IDA7XFxuICBtYXJnaW4tdG9wOiAxOHB4O1xcbiAgbWF4LWhlaWdodDogbm9uZTtcXG59XFxuXFxuLyoqXFxuICogKDEpOiBhcHByb3hpbWF0ZSBmb3IgYnJvd3NlcnMgbm90IHN1cHBvcnRpbmcgY2FsY1xcbiAqICgyKTogNDIgPSAyKjE1ICsgMioxMCArIDIqMSAocGFkZGluZyArIG1hcmdpbiArIGJvcmRlcilcXG4gKiAgICAgIF5eIHNlcmlvdXNseVxcbiAqL1xcbiNtb2NoYSAudGVzdCBwcmUge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmbG9hdDogbGVmdDtcXG4gIGNsZWFyOiBsZWZ0O1xcbiAgZm9udDogMTJweC8xLjUgbW9uYWNvLCBtb25vc3BhY2U7XFxuICBtYXJnaW46IDVweDtcXG4gIHBhZGRpbmc6IDE1cHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZWVlO1xcbiAgbWF4LXdpZHRoOiA4NSU7IC8qKDEpKi9cXG4gIG1heC13aWR0aDogLXdlYmtpdC1jYWxjKDEwMCUgLSA0MnB4KTtcXG4gIG1heC13aWR0aDogLW1vei1jYWxjKDEwMCUgLSA0MnB4KTtcXG4gIG1heC13aWR0aDogY2FsYygxMDAlIC0gNDJweCk7IC8qKDIpKi9cXG4gIHdvcmQtd3JhcDogYnJlYWstd29yZDtcXG4gIGJvcmRlci1ib3R0b20tY29sb3I6ICNkZGQ7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IDAgMXB4IDNweCAjZWVlO1xcbiAgLW1vei1ib3gtc2hhZG93OiAwIDFweCAzcHggI2VlZTtcXG4gIGJveC1zaGFkb3c6IDAgMXB4IDNweCAjZWVlO1xcbiAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiAzcHg7XFxuICAtbW96LWJvcmRlci1yYWRpdXM6IDNweDtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG59XFxuXFxuI21vY2hhIC50ZXN0IGgyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuXFxuI21vY2hhIC50ZXN0IGEucmVwbGF5IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogM3B4O1xcbiAgcmlnaHQ6IDA7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB3aWR0aDogMTVweDtcXG4gIGhlaWdodDogMTVweDtcXG4gIGxpbmUtaGVpZ2h0OiAxNXB4O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgYmFja2dyb3VuZDogI2VlZTtcXG4gIGZvbnQtc2l6ZTogMTVweDtcXG4gIC13ZWJraXQtYm9yZGVyLXJhZGl1czogMTVweDtcXG4gIC1tb3otYm9yZGVyLXJhZGl1czogMTVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICAtd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAyMDBtcztcXG4gIC1tb3otdHJhbnNpdGlvbjpvcGFjaXR5IDIwMG1zO1xcbiAgLW8tdHJhbnNpdGlvbjpvcGFjaXR5IDIwMG1zO1xcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAyMDBtcztcXG4gIG9wYWNpdHk6IDAuMztcXG4gIGNvbG9yOiAjODg4O1xcbn1cXG5cXG4jbW9jaGEgLnRlc3Q6aG92ZXIgYS5yZXBsYXkge1xcbiAgb3BhY2l0eTogMTtcXG59XFxuXFxuI21vY2hhLXJlcG9ydC5wYXNzIC50ZXN0LmZhaWwge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuI21vY2hhLXJlcG9ydC5mYWlsIC50ZXN0LnBhc3Mge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuI21vY2hhLXJlcG9ydC5wZW5kaW5nIC50ZXN0LnBhc3MsXFxuI21vY2hhLXJlcG9ydC5wZW5kaW5nIC50ZXN0LmZhaWwge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuI21vY2hhLXJlcG9ydC5wZW5kaW5nIC50ZXN0LnBhc3MucGVuZGluZyB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuI21vY2hhLWVycm9yIHtcXG4gIGNvbG9yOiAjYzAwO1xcbiAgZm9udC1zaXplOiAxLjVlbTtcXG4gIGZvbnQtd2VpZ2h0OiAxMDA7XFxuICBsZXR0ZXItc3BhY2luZzogMXB4O1xcbn1cXG5cXG4jbW9jaGEtc3RhdHMge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgdG9wOiAxNXB4O1xcbiAgcmlnaHQ6IDEwcHg7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBtYXJnaW46IDA7XFxuICBjb2xvcjogIzg4ODtcXG4gIHotaW5kZXg6IDE7XFxufVxcblxcbiNtb2NoYS1zdGF0cyAucHJvZ3Jlc3Mge1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbiAgcGFkZGluZy10b3A6IDA7XFxuXFxuICAvKipcXG4gICAqIFNldCBzYWZlIGluaXRpYWwgdmFsdWVzLCBzbyBtb2NoYXMgLnByb2dyZXNzIGRvZXMgbm90IGluaGVyaXQgdGhlc2VcXG4gICAqIHByb3BlcnRpZXMgZnJvbSBCb290c3RyYXAgLnByb2dyZXNzICh3aGljaCBjYXVzZXMgLnByb2dyZXNzIGhlaWdodCB0b1xcbiAgICogZXF1YWwgbGluZSBoZWlnaHQgc2V0IGluIEJvb3RzdHJhcCkuXFxuICAgKi9cXG4gIGhlaWdodDogYXV0bztcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogbm9uZTtcXG4gIC1tb3otYm94LXNoYWRvdzogbm9uZTtcXG4gIGJveC1zaGFkb3c6IG5vbmU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBpbml0aWFsO1xcbn1cXG5cXG4jbW9jaGEtc3RhdHMgZW0ge1xcbiAgY29sb3I6IGJsYWNrO1xcbn1cXG5cXG4jbW9jaGEtc3RhdHMgYSB7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICBjb2xvcjogaW5oZXJpdDtcXG59XFxuXFxuI21vY2hhLXN0YXRzIGE6aG92ZXIge1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlZWU7XFxufVxcblxcbiNtb2NoYS1zdGF0cyBsaSB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBtYXJnaW46IDAgNXB4O1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG4gIHBhZGRpbmctdG9wOiAxMXB4O1xcbn1cXG5cXG4jbW9jaGEtc3RhdHMgY2FudmFzIHtcXG4gIHdpZHRoOiA0MHB4O1xcbiAgaGVpZ2h0OiA0MHB4O1xcbn1cXG5cXG4jbW9jaGEgY29kZSAuY29tbWVudCB7IGNvbG9yOiAjZGRkOyB9XFxuI21vY2hhIGNvZGUgLmluaXQgeyBjb2xvcjogIzJmNmZhZDsgfVxcbiNtb2NoYSBjb2RlIC5zdHJpbmcgeyBjb2xvcjogIzU4OTBhZDsgfVxcbiNtb2NoYSBjb2RlIC5rZXl3b3JkIHsgY29sb3I6ICM4YTYzNDM7IH1cXG4jbW9jaGEgY29kZSAubnVtYmVyIHsgY29sb3I6ICMyZjZmYWQ7IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LWRldmljZS13aWR0aDogNDgwcHgpIHtcXG4gICNtb2NoYSB7XFxuICAgIG1hcmdpbjogNjBweCAwcHg7XFxuICB9XFxuXFxuICAjbW9jaGEgI3N0YXRzIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgfVxcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG4iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbW9jaGEuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbW9jaGEuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9tb2NoYS1sb2FkZXIvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9tb2NoYS5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdGlmICh0eXBlb2YgbWVtb1tzZWxlY3Rvcl0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBzdHlsZVRhcmdldCA9IGZuLmNhbGwodGhpcywgc2VsZWN0b3IpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmIChzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG5cdFx0XHRcdFx0Ly8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG1lbW9bc2VsZWN0b3JdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3NlbGVjdG9yXVxuXHR9O1xufSkoZnVuY3Rpb24gKHRhcmdldCkge1xuXHRyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpXG59KTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcblx0aWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8gKyBcIiBcIiArIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiIsIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuIiwicHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0ZGVsZXRlIHJlcXVpcmUuY2FjaGVbbW9kdWxlLmlkXTtcblx0aWYodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubW9jaGFQaGFudG9tSlMpXG5cdFx0bW9jaGFQaGFudG9tSlMucnVuKCk7XG5cdGVsc2Vcblx0XHRtb2NoYS5ydW4oKTtcbn0pO1xuIiwiaWYgKCEgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtb2NoYVwiKSkgeyBkb2N1bWVudC53cml0ZShcIjxkaXYgaWQ9XFxcIm1vY2hhXFxcIj48L2Rpdj5cIik7IH1cblxucmVxdWlyZShcIiFzdHlsZS1sb2FkZXIhY3NzLWxvYWRlciFtb2NoYS9tb2NoYS5jc3NcIik7XG5yZXF1aXJlKFwiIXNjcmlwdC1sb2FkZXIhbW9jaGEvbW9jaGEuanNcIik7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XFxcImZ1bmN0aW9uXFxcIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcXFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcXFwiK28rXFxcIidcXFwiKTt0aHJvdyBmLmNvZGU9XFxcIk1PRFVMRV9OT1RfRk9VTkRcXFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XFxcImZ1bmN0aW9uXFxcIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IG9mZiAqL1xcbi8qIGVzbGludC1lbnYgY29tbW9uanMgKi9cXG5cXG4vKipcXG4gKiBTaGltIHByb2Nlc3Muc3Rkb3V0LlxcbiAqL1xcblxcbnByb2Nlc3Muc3Rkb3V0ID0gcmVxdWlyZSgnYnJvd3Nlci1zdGRvdXQnKSh7bGV2ZWw6IGZhbHNlfSk7XFxuXFxudmFyIE1vY2hhID0gcmVxdWlyZSgnLi9saWIvbW9jaGEnKTtcXG5cXG4vKipcXG4gKiBDcmVhdGUgYSBNb2NoYSBpbnN0YW5jZS5cXG4gKlxcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cXG4gKi9cXG5cXG52YXIgbW9jaGEgPSBuZXcgTW9jaGEoeyByZXBvcnRlcjogJ2h0bWwnIH0pO1xcblxcbi8qKlxcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZyAoc2VlIEdILTIzNykuXFxuICovXFxuXFxudmFyIERhdGUgPSBnbG9iYWwuRGF0ZTtcXG52YXIgc2V0VGltZW91dCA9IGdsb2JhbC5zZXRUaW1lb3V0O1xcbnZhciBzZXRJbnRlcnZhbCA9IGdsb2JhbC5zZXRJbnRlcnZhbDtcXG52YXIgY2xlYXJUaW1lb3V0ID0gZ2xvYmFsLmNsZWFyVGltZW91dDtcXG52YXIgY2xlYXJJbnRlcnZhbCA9IGdsb2JhbC5jbGVhckludGVydmFsO1xcblxcbnZhciB1bmNhdWdodEV4Y2VwdGlvbkhhbmRsZXJzID0gW107XFxuXFxudmFyIG9yaWdpbmFsT25lcnJvckhhbmRsZXIgPSBnbG9iYWwub25lcnJvcjtcXG5cXG4vKipcXG4gKiBSZW1vdmUgdW5jYXVnaHRFeGNlcHRpb24gbGlzdGVuZXIuXFxuICogUmV2ZXJ0IHRvIG9yaWdpbmFsIG9uZXJyb3IgaGFuZGxlciBpZiBwcmV2aW91c2x5IGRlZmluZWQuXFxuICovXFxuXFxucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChlLCBmbikge1xcbiAgaWYgKGUgPT09ICd1bmNhdWdodEV4Y2VwdGlvbicpIHtcXG4gICAgaWYgKG9yaWdpbmFsT25lcnJvckhhbmRsZXIpIHtcXG4gICAgICBnbG9iYWwub25lcnJvciA9IG9yaWdpbmFsT25lcnJvckhhbmRsZXI7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZ2xvYmFsLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7fTtcXG4gICAgfVxcbiAgICB2YXIgaSA9IHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcnMuaW5kZXhPZihmbik7XFxuICAgIGlmIChpICE9PSAtMSkge1xcbiAgICAgIHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcnMuc3BsaWNlKGksIDEpO1xcbiAgICB9XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBJbXBsZW1lbnRzIHVuY2F1Z2h0RXhjZXB0aW9uIGxpc3RlbmVyLlxcbiAqL1xcblxcbnByb2Nlc3Mub24gPSBmdW5jdGlvbiAoZSwgZm4pIHtcXG4gIGlmIChlID09PSAndW5jYXVnaHRFeGNlcHRpb24nKSB7XFxuICAgIGdsb2JhbC5vbmVycm9yID0gZnVuY3Rpb24gKGVyciwgdXJsLCBsaW5lKSB7XFxuICAgICAgZm4obmV3IEVycm9yKGVyciArICcgKCcgKyB1cmwgKyAnOicgKyBsaW5lICsgJyknKSk7XFxuICAgICAgcmV0dXJuICFtb2NoYS5hbGxvd1VuY2F1Z2h0O1xcbiAgICB9O1xcbiAgICB1bmNhdWdodEV4Y2VwdGlvbkhhbmRsZXJzLnB1c2goZm4pO1xcbiAgfVxcbn07XFxuXFxuLy8gVGhlIEJERCBVSSBpcyByZWdpc3RlcmVkIGJ5IGRlZmF1bHQsIGJ1dCBubyBVSSB3aWxsIGJlIGZ1bmN0aW9uYWwgaW4gdGhlXFxuLy8gYnJvd3NlciB3aXRob3V0IGFuIGV4cGxpY2l0IGNhbGwgdG8gdGhlIG92ZXJyaWRkZW4gYG1vY2hhLnVpYCAoc2VlIGJlbG93KS5cXG4vLyBFbnN1cmUgdGhhdCB0aGlzIGRlZmF1bHQgVUkgZG9lcyBub3QgZXhwb3NlIGl0cyBtZXRob2RzIHRvIHRoZSBnbG9iYWwgc2NvcGUuXFxubW9jaGEuc3VpdGUucmVtb3ZlQWxsTGlzdGVuZXJzKCdwcmUtcmVxdWlyZScpO1xcblxcbnZhciBpbW1lZGlhdGVRdWV1ZSA9IFtdO1xcbnZhciBpbW1lZGlhdGVUaW1lb3V0O1xcblxcbmZ1bmN0aW9uIHRpbWVzbGljZSAoKSB7XFxuICB2YXIgaW1tZWRpYXRlU3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXG4gIHdoaWxlIChpbW1lZGlhdGVRdWV1ZS5sZW5ndGggJiYgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gaW1tZWRpYXRlU3RhcnQpIDwgMTAwKSB7XFxuICAgIGltbWVkaWF0ZVF1ZXVlLnNoaWZ0KCkoKTtcXG4gIH1cXG4gIGlmIChpbW1lZGlhdGVRdWV1ZS5sZW5ndGgpIHtcXG4gICAgaW1tZWRpYXRlVGltZW91dCA9IHNldFRpbWVvdXQodGltZXNsaWNlLCAwKTtcXG4gIH0gZWxzZSB7XFxuICAgIGltbWVkaWF0ZVRpbWVvdXQgPSBudWxsO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBIaWdoLXBlcmZvcm1hbmNlIG92ZXJyaWRlIG9mIFJ1bm5lci5pbW1lZGlhdGVseS5cXG4gKi9cXG5cXG5Nb2NoYS5SdW5uZXIuaW1tZWRpYXRlbHkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcXG4gIGltbWVkaWF0ZVF1ZXVlLnB1c2goY2FsbGJhY2spO1xcbiAgaWYgKCFpbW1lZGlhdGVUaW1lb3V0KSB7XFxuICAgIGltbWVkaWF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHRpbWVzbGljZSwgMCk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBGdW5jdGlvbiB0byBhbGxvdyBhc3NlcnRpb24gbGlicmFyaWVzIHRvIHRocm93IGVycm9ycyBkaXJlY3RseSBpbnRvIG1vY2hhLlxcbiAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gcnVubmluZyB0ZXN0cyBpbiBhIGJyb3dzZXIgYmVjYXVzZSB3aW5kb3cub25lcnJvciB3aWxsXFxuICogb25seSByZWNlaXZlIHRoZSAnbWVzc2FnZScgYXR0cmlidXRlIG9mIHRoZSBFcnJvci5cXG4gKi9cXG5tb2NoYS50aHJvd0Vycm9yID0gZnVuY3Rpb24gKGVycikge1xcbiAgdW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xcbiAgICBmbihlcnIpO1xcbiAgfSk7XFxuICB0aHJvdyBlcnI7XFxufTtcXG5cXG4vKipcXG4gKiBPdmVycmlkZSB1aSB0byBlbnN1cmUgdGhhdCB0aGUgdWkgZnVuY3Rpb25zIGFyZSBpbml0aWFsaXplZC5cXG4gKiBOb3JtYWxseSB0aGlzIHdvdWxkIGhhcHBlbiBpbiBNb2NoYS5wcm90b3R5cGUubG9hZEZpbGVzLlxcbiAqL1xcblxcbm1vY2hhLnVpID0gZnVuY3Rpb24gKHVpKSB7XFxuICBNb2NoYS5wcm90b3R5cGUudWkuY2FsbCh0aGlzLCB1aSk7XFxuICB0aGlzLnN1aXRlLmVtaXQoJ3ByZS1yZXF1aXJlJywgZ2xvYmFsLCBudWxsLCB0aGlzKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0dXAgbW9jaGEgd2l0aCB0aGUgZ2l2ZW4gc2V0dGluZyBvcHRpb25zLlxcbiAqL1xcblxcbm1vY2hhLnNldHVwID0gZnVuY3Rpb24gKG9wdHMpIHtcXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIHtcXG4gICAgb3B0cyA9IHsgdWk6IG9wdHMgfTtcXG4gIH1cXG4gIGZvciAodmFyIG9wdCBpbiBvcHRzKSB7XFxuICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KG9wdCkpIHtcXG4gICAgICB0aGlzW29wdF0ob3B0c1tvcHRdKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gbW9jaGEsIHJldHVybmluZyB0aGUgUnVubmVyLlxcbiAqL1xcblxcbm1vY2hhLnJ1biA9IGZ1bmN0aW9uIChmbikge1xcbiAgdmFyIG9wdGlvbnMgPSBtb2NoYS5vcHRpb25zO1xcbiAgbW9jaGEuZ2xvYmFscygnbG9jYXRpb24nKTtcXG5cXG4gIHZhciBxdWVyeSA9IE1vY2hhLnV0aWxzLnBhcnNlUXVlcnkoZ2xvYmFsLmxvY2F0aW9uLnNlYXJjaCB8fCAnJyk7XFxuICBpZiAocXVlcnkuZ3JlcCkge1xcbiAgICBtb2NoYS5ncmVwKHF1ZXJ5LmdyZXApO1xcbiAgfVxcbiAgaWYgKHF1ZXJ5LmZncmVwKSB7XFxuICAgIG1vY2hhLmZncmVwKHF1ZXJ5LmZncmVwKTtcXG4gIH1cXG4gIGlmIChxdWVyeS5pbnZlcnQpIHtcXG4gICAgbW9jaGEuaW52ZXJ0KCk7XFxuICB9XFxuXFxuICByZXR1cm4gTW9jaGEucHJvdG90eXBlLnJ1bi5jYWxsKG1vY2hhLCBmdW5jdGlvbiAoZXJyKSB7XFxuICAgIC8vIFRoZSBET00gRG9jdW1lbnQgaXMgbm90IGF2YWlsYWJsZSBpbiBXZWIgV29ya2Vycy5cXG4gICAgdmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xcbiAgICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vY2hhJykgJiYgb3B0aW9ucy5ub0hpZ2hsaWdodGluZyAhPT0gdHJ1ZSkge1xcbiAgICAgIE1vY2hhLnV0aWxzLmhpZ2hsaWdodFRhZ3MoJ2NvZGUnKTtcXG4gICAgfVxcbiAgICBpZiAoZm4pIHtcXG4gICAgICBmbihlcnIpO1xcbiAgICB9XFxuICB9KTtcXG59O1xcblxcbi8qKlxcbiAqIEV4cG9zZSB0aGUgcHJvY2VzcyBzaGltLlxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2NoYWpzL21vY2hhL3B1bGwvOTE2XFxuICovXFxuXFxuTW9jaGEucHJvY2VzcyA9IHByb2Nlc3M7XFxuXFxuLyoqXFxuICogRXhwb3NlIG1vY2hhLlxcbiAqL1xcblxcbmdsb2JhbC5Nb2NoYSA9IE1vY2hhO1xcbmdsb2JhbC5tb2NoYSA9IG1vY2hhO1xcblxcbi8vIHRoaXMgYWxsb3dzIHRlc3QvYWNjZXB0YW5jZS9yZXF1aXJlZC10b2tlbnMuanMgdG8gcGFzczsgdGh1cyxcXG4vLyB5b3UgY2FuIG5vdyBkbyBgY29uc3QgZGVzY3JpYmUgPSByZXF1aXJlKCdtb2NoYScpLmRlc2NyaWJlYCBpbiBhXFxuLy8gYnJvd3NlciBjb250ZXh0IChhc3N1bWluZyBicm93c2VyaWZpY2F0aW9uKS4gIHNob3VsZCBmaXggIzg4MFxcbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4vbGliL21vY2hhXFxcIjoxMyxcXFwiX3Byb2Nlc3NcXFwiOjU2LFxcXCJicm93c2VyLXN0ZG91dFxcXCI6Mzl9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLy8ganVzdCBzdHViIG91dCBncm93bFxcblxcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5ub29wO1xcblxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzZ9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBQcm9ncmVzc2AuXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBQcm9ncmVzcztcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBQcm9ncmVzc2AgaW5kaWNhdG9yLlxcbiAqL1xcbmZ1bmN0aW9uIFByb2dyZXNzICgpIHtcXG4gIHRoaXMucGVyY2VudCA9IDA7XFxuICB0aGlzLnNpemUoMCk7XFxuICB0aGlzLmZvbnRTaXplKDExKTtcXG4gIHRoaXMuZm9udCgnaGVsdmV0aWNhLCBhcmlhbCwgc2Fucy1zZXJpZicpO1xcbn1cXG5cXG4vKipcXG4gKiBTZXQgcHJvZ3Jlc3Mgc2l6ZSB0byBgc2l6ZWAuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXFxuICogQHJldHVybiB7UHJvZ3Jlc3N9IFByb2dyZXNzIGluc3RhbmNlLlxcbiAqL1xcblByb2dyZXNzLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKHNpemUpIHtcXG4gIHRoaXMuX3NpemUgPSBzaXplO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgdGV4dCB0byBgdGV4dGAuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XFxuICogQHJldHVybiB7UHJvZ3Jlc3N9IFByb2dyZXNzIGluc3RhbmNlLlxcbiAqL1xcblByb2dyZXNzLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcXG4gIHRoaXMuX3RleHQgPSB0ZXh0O1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgZm9udCBzaXplIHRvIGBzaXplYC5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtudW1iZXJ9IHNpemVcXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXFxuICovXFxuUHJvZ3Jlc3MucHJvdG90eXBlLmZvbnRTaXplID0gZnVuY3Rpb24gKHNpemUpIHtcXG4gIHRoaXMuX2ZvbnRTaXplID0gc2l6ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IGZvbnQgdG8gYGZhbWlseWAuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gZmFtaWx5XFxuICogQHJldHVybiB7UHJvZ3Jlc3N9IFByb2dyZXNzIGluc3RhbmNlLlxcbiAqL1xcblByb2dyZXNzLnByb3RvdHlwZS5mb250ID0gZnVuY3Rpb24gKGZhbWlseSkge1xcbiAgdGhpcy5fZm9udCA9IGZhbWlseTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogVXBkYXRlIHBlcmNlbnRhZ2UgdG8gYG5gLlxcbiAqXFxuICogQHBhcmFtIHtudW1iZXJ9IG5cXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXFxuICovXFxuUHJvZ3Jlc3MucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChuKSB7XFxuICB0aGlzLnBlcmNlbnQgPSBuO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBEcmF3IG9uIGBjdHhgLlxcbiAqXFxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MmR9IGN0eFxcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cXG4gKi9cXG5Qcm9ncmVzcy5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcXG4gIHRyeSB7XFxuICAgIHZhciBwZXJjZW50ID0gTWF0aC5taW4odGhpcy5wZXJjZW50LCAxMDApO1xcbiAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XFxuICAgIHZhciBoYWxmID0gc2l6ZSAvIDI7XFxuICAgIHZhciB4ID0gaGFsZjtcXG4gICAgdmFyIHkgPSBoYWxmO1xcbiAgICB2YXIgcmFkID0gaGFsZiAtIDE7XFxuICAgIHZhciBmb250U2l6ZSA9IHRoaXMuX2ZvbnRTaXplO1xcblxcbiAgICBjdHguZm9udCA9IGZvbnRTaXplICsgJ3B4ICcgKyB0aGlzLl9mb250O1xcblxcbiAgICB2YXIgYW5nbGUgPSBNYXRoLlBJICogMiAqIChwZXJjZW50IC8gMTAwKTtcXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBzaXplLCBzaXplKTtcXG5cXG4gICAgLy8gb3V0ZXIgY2lyY2xlXFxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjOWY5ZjlmJztcXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xcbiAgICBjdHguYXJjKHgsIHksIHJhZCwgMCwgYW5nbGUsIGZhbHNlKTtcXG4gICAgY3R4LnN0cm9rZSgpO1xcblxcbiAgICAvLyBpbm5lciBjaXJjbGVcXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJyNlZWUnO1xcbiAgICBjdHguYmVnaW5QYXRoKCk7XFxuICAgIGN0eC5hcmMoeCwgeSwgcmFkIC0gMSwgMCwgYW5nbGUsIHRydWUpO1xcbiAgICBjdHguc3Ryb2tlKCk7XFxuXFxuICAgIC8vIHRleHRcXG4gICAgdmFyIHRleHQgPSB0aGlzLl90ZXh0IHx8IChwZXJjZW50IHwgMCkgKyAnJSc7XFxuICAgIHZhciB3ID0gY3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xcblxcbiAgICBjdHguZmlsbFRleHQodGV4dCwgeCAtIHcgLyAyICsgMSwgeSArIGZvbnRTaXplIC8gMiAtIDEpO1xcbiAgfSBjYXRjaCAoZXJyKSB7XFxuICAgIC8vIGRvbid0IGZhaWwgaWYgd2UgY2FuJ3QgcmVuZGVyIHByb2dyZXNzXFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbn0se31dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAoZ2xvYmFsKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuZXhwb3J0cy5pc2F0dHkgPSBmdW5jdGlvbiBpc2F0dHkgKCkge1xcbiAgcmV0dXJuIHRydWU7XFxufTtcXG5cXG5leHBvcnRzLmdldFdpbmRvd1NpemUgPSBmdW5jdGlvbiBnZXRXaW5kb3dTaXplICgpIHtcXG4gIGlmICgnaW5uZXJIZWlnaHQnIGluIGdsb2JhbCkge1xcbiAgICByZXR1cm4gW2dsb2JhbC5pbm5lckhlaWdodCwgZ2xvYmFsLmlubmVyV2lkdGhdO1xcbiAgfVxcbiAgLy8gSW4gYSBXZWIgV29ya2VyLCB0aGUgRE9NIFdpbmRvdyBpcyBub3QgYXZhaWxhYmxlLlxcbiAgcmV0dXJuIFs2NDAsIDQ4MF07XFxufTtcXG5cXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHt9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBDb250ZXh0XFxuICovXFxuLyoqXFxuICogRXhwb3NlIGBDb250ZXh0YC5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRleHQ7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgQ29udGV4dGAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5mdW5jdGlvbiBDb250ZXh0ICgpIHt9XFxuXFxuLyoqXFxuICogU2V0IG9yIGdldCB0aGUgY29udGV4dCBgUnVubmFibGVgIHRvIGBydW5uYWJsZWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1J1bm5hYmxlfSBydW5uYWJsZVxcbiAqIEByZXR1cm4ge0NvbnRleHR9IGNvbnRleHRcXG4gKi9cXG5Db250ZXh0LnByb3RvdHlwZS5ydW5uYWJsZSA9IGZ1bmN0aW9uIChydW5uYWJsZSkge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9ydW5uYWJsZTtcXG4gIH1cXG4gIHRoaXMudGVzdCA9IHRoaXMuX3J1bm5hYmxlID0gcnVubmFibGU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBvciBnZXQgdGVzdCB0aW1lb3V0IGBtc2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gbXNcXG4gKiBAcmV0dXJuIHtDb250ZXh0fSBzZWxmXFxuICovXFxuQ29udGV4dC5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIChtcykge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLnJ1bm5hYmxlKCkudGltZW91dCgpO1xcbiAgfVxcbiAgdGhpcy5ydW5uYWJsZSgpLnRpbWVvdXQobXMpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgdGVzdCB0aW1lb3V0IGBlbmFibGVkYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxcbiAqIEByZXR1cm4ge0NvbnRleHR9IHNlbGZcXG4gKi9cXG5Db250ZXh0LnByb3RvdHlwZS5lbmFibGVUaW1lb3V0cyA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMucnVubmFibGUoKS5lbmFibGVUaW1lb3V0cygpO1xcbiAgfVxcbiAgdGhpcy5ydW5uYWJsZSgpLmVuYWJsZVRpbWVvdXRzKGVuYWJsZWQpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgb3IgZ2V0IHRlc3Qgc2xvd25lc3MgdGhyZXNob2xkIGBtc2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gbXNcXG4gKiBAcmV0dXJuIHtDb250ZXh0fSBzZWxmXFxuICovXFxuQ29udGV4dC5wcm90b3R5cGUuc2xvdyA9IGZ1bmN0aW9uIChtcykge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLnJ1bm5hYmxlKCkuc2xvdygpO1xcbiAgfVxcbiAgdGhpcy5ydW5uYWJsZSgpLnNsb3cobXMpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBNYXJrIGEgdGVzdCBhcyBza2lwcGVkLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHRocm93cyBQZW5kaW5nXFxuICovXFxuQ29udGV4dC5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMucnVubmFibGUoKS5za2lwKCk7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgb3IgZ2V0IGEgbnVtYmVyIG9mIGFsbG93ZWQgcmV0cmllcyBvbiBmYWlsZWQgdGVzdHNcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHJldHVybiB7Q29udGV4dH0gc2VsZlxcbiAqL1xcbkNvbnRleHQucHJvdG90eXBlLnJldHJpZXMgPSBmdW5jdGlvbiAobikge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLnJ1bm5hYmxlKCkucmV0cmllcygpO1xcbiAgfVxcbiAgdGhpcy5ydW5uYWJsZSgpLnJldHJpZXMobik7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbn0se31dLDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIEhvb2tcXG4gKlxcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIFJ1bm5hYmxlID0gcmVxdWlyZSgnLi9ydW5uYWJsZScpO1xcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4vdXRpbHMnKS5pbmhlcml0cztcXG5cXG4vKipcXG4gKiBFeHBvc2UgYEhvb2tgLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gSG9vaztcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBIb29rYCB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gLiBEZXJpdmVkIGZyb21cXG4gKiBgUnVubmFibGVgLlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzc1xcbiAqIEBwYXJhbSB7U3RyaW5nfSB0aXRsZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuZnVuY3Rpb24gSG9vayAodGl0bGUsIGZuKSB7XFxuICBSdW5uYWJsZS5jYWxsKHRoaXMsIHRpdGxlLCBmbik7XFxuICB0aGlzLnR5cGUgPSAnaG9vayc7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgUnVubmFibGUucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhIb29rLCBSdW5uYWJsZSk7XFxuXFxuLyoqXFxuICogR2V0IG9yIHNldCB0aGUgdGVzdCBgZXJyYC5cXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYS5Ib29rXFxuICogQHB1YmxpY1xcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxcbiAqIEByZXR1cm4ge0Vycm9yfVxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuSG9vay5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgZXJyID0gdGhpcy5fZXJyb3I7XFxuICAgIHRoaXMuX2Vycm9yID0gbnVsbDtcXG4gICAgcmV0dXJuIGVycjtcXG4gIH1cXG5cXG4gIHRoaXMuX2Vycm9yID0gZXJyO1xcbn07XFxuXFxufSx7XFxcIi4vcnVubmFibGVcXFwiOjMyLFxcXCIuL3V0aWxzXFxcIjozNn1dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBUZXN0ID0gcmVxdWlyZSgnLi4vdGVzdCcpO1xcblxcbi8qKlxcbiAqIEJERC1zdHlsZSBpbnRlcmZhY2U6XFxuICpcXG4gKiAgICAgIGRlc2NyaWJlKCdBcnJheScsIGZ1bmN0aW9uKCkge1xcbiAqICAgICAgICBkZXNjcmliZSgnI2luZGV4T2YoKScsIGZ1bmN0aW9uKCkge1xcbiAqICAgICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIC0xIHdoZW4gbm90IHByZXNlbnQnLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICAgICAgIC8vIC4uLlxcbiAqICAgICAgICAgIH0pO1xcbiAqXFxuICogICAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gdGhlIGluZGV4IHdoZW4gcHJlc2VudCcsIGZ1bmN0aW9uKCkge1xcbiAqICAgICAgICAgICAgLy8gLi4uXFxuICogICAgICAgICAgfSk7XFxuICogICAgICAgIH0pO1xcbiAqICAgICAgfSk7XFxuICpcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSBSb290IHN1aXRlLlxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN1aXRlKSB7XFxuICB2YXIgc3VpdGVzID0gW3N1aXRlXTtcXG5cXG4gIHN1aXRlLm9uKCdwcmUtcmVxdWlyZScsIGZ1bmN0aW9uIChjb250ZXh0LCBmaWxlLCBtb2NoYSkge1xcbiAgICB2YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKShzdWl0ZXMsIGNvbnRleHQsIG1vY2hhKTtcXG5cXG4gICAgY29udGV4dC5iZWZvcmUgPSBjb21tb24uYmVmb3JlO1xcbiAgICBjb250ZXh0LmFmdGVyID0gY29tbW9uLmFmdGVyO1xcbiAgICBjb250ZXh0LmJlZm9yZUVhY2ggPSBjb21tb24uYmVmb3JlRWFjaDtcXG4gICAgY29udGV4dC5hZnRlckVhY2ggPSBjb21tb24uYWZ0ZXJFYWNoO1xcbiAgICBjb250ZXh0LnJ1biA9IG1vY2hhLm9wdGlvbnMuZGVsYXkgJiYgY29tbW9uLnJ1bldpdGhTdWl0ZShzdWl0ZSk7XFxuICAgIC8qKlxcbiAgICAgKiBEZXNjcmliZSBhIFxcXCJzdWl0ZVxcXCIgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYFxcbiAgICAgKiBhbmQgY2FsbGJhY2sgYGZuYCBjb250YWluaW5nIG5lc3RlZCBzdWl0ZXNcXG4gICAgICogYW5kL29yIHRlc3RzLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC5kZXNjcmliZSA9IGNvbnRleHQuY29udGV4dCA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLmNyZWF0ZSh7XFxuICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICBmaWxlOiBmaWxlLFxcbiAgICAgICAgZm46IGZuXFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBQZW5kaW5nIGRlc2NyaWJlLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC54ZGVzY3JpYmUgPSBjb250ZXh0Lnhjb250ZXh0ID0gY29udGV4dC5kZXNjcmliZS5za2lwID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgICAgIHJldHVybiBjb21tb24uc3VpdGUuc2tpcCh7XFxuICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICBmaWxlOiBmaWxlLFxcbiAgICAgICAgZm46IGZuXFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGNsdXNpdmUgc3VpdGUuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0LmRlc2NyaWJlLm9ubHkgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgcmV0dXJuIGNvbW1vbi5zdWl0ZS5vbmx5KHtcXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgIGZpbGU6IGZpbGUsXFxuICAgICAgICBmbjogZm5cXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIERlc2NyaWJlIGEgc3BlY2lmaWNhdGlvbiBvciB0ZXN0LWNhc2VcXG4gICAgICogd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgY2FsbGJhY2sgYGZuYFxcbiAgICAgKiBhY3RpbmcgYXMgYSB0aHVuay5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQuaXQgPSBjb250ZXh0LnNwZWNpZnkgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgdmFyIHN1aXRlID0gc3VpdGVzWzBdO1xcbiAgICAgIGlmIChzdWl0ZS5pc1BlbmRpbmcoKSkge1xcbiAgICAgICAgZm4gPSBudWxsO1xcbiAgICAgIH1cXG4gICAgICB2YXIgdGVzdCA9IG5ldyBUZXN0KHRpdGxlLCBmbik7XFxuICAgICAgdGVzdC5maWxlID0gZmlsZTtcXG4gICAgICBzdWl0ZS5hZGRUZXN0KHRlc3QpO1xcbiAgICAgIHJldHVybiB0ZXN0O1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRXhjbHVzaXZlIHRlc3QtY2FzZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQuaXQub25seSA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gICAgICByZXR1cm4gY29tbW9uLnRlc3Qub25seShtb2NoYSwgY29udGV4dC5pdCh0aXRsZSwgZm4pKTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFBlbmRpbmcgdGVzdCBjYXNlLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC54aXQgPSBjb250ZXh0LnhzcGVjaWZ5ID0gY29udGV4dC5pdC5za2lwID0gZnVuY3Rpb24gKHRpdGxlKSB7XFxuICAgICAgcmV0dXJuIGNvbnRleHQuaXQodGl0bGUpO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogTnVtYmVyIG9mIGF0dGVtcHRzIHRvIHJldHJ5LlxcbiAgICAgKi9cXG4gICAgY29udGV4dC5pdC5yZXRyaWVzID0gZnVuY3Rpb24gKG4pIHtcXG4gICAgICBjb250ZXh0LnJldHJpZXMobik7XFxuICAgIH07XFxuICB9KTtcXG59O1xcblxcbn0se1xcXCIuLi90ZXN0XFxcIjozNSxcXFwiLi9jb21tb25cXFwiOjh9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxudmFyIFN1aXRlID0gcmVxdWlyZSgnLi4vc3VpdGUnKTtcXG5cXG4vKipcXG4gKiBGdW5jdGlvbnMgY29tbW9uIHRvIG1vcmUgdGhhbiBvbmUgaW50ZXJmYWNlLlxcbiAqXFxuICogQHBhcmFtIHtTdWl0ZVtdfSBzdWl0ZXNcXG4gKiBAcGFyYW0ge0NvbnRleHR9IGNvbnRleHRcXG4gKiBAcGFyYW0ge01vY2hhfSBtb2NoYVxcbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tbW9uIGZ1bmN0aW9ucy5cXG4gKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdWl0ZXMsIGNvbnRleHQsIG1vY2hhKSB7XFxuICByZXR1cm4ge1xcbiAgICAvKipcXG4gICAgICogVGhpcyBpcyBvbmx5IHByZXNlbnQgaWYgZmxhZyAtLWRlbGF5IGlzIHBhc3NlZCBpbnRvIE1vY2hhLiBJdCB0cmlnZ2Vyc1xcbiAgICAgKiByb290IHN1aXRlIGV4ZWN1dGlvbi5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtTdWl0ZX0gc3VpdGUgVGhlIHJvb3Qgc3VpdGUuXFxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHdoaWNoIHJ1bnMgdGhlIHJvb3Qgc3VpdGVcXG4gICAgICovXFxuICAgIHJ1bldpdGhTdWl0ZTogZnVuY3Rpb24gcnVuV2l0aFN1aXRlIChzdWl0ZSkge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiBydW4gKCkge1xcbiAgICAgICAgc3VpdGUucnVuKCk7XFxuICAgICAgfTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4ZWN1dGUgYmVmb3JlIHJ1bm5pbmcgdGVzdHMuXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICAgICAqL1xcbiAgICBiZWZvcmU6IGZ1bmN0aW9uIChuYW1lLCBmbikge1xcbiAgICAgIHN1aXRlc1swXS5iZWZvcmVBbGwobmFtZSwgZm4pO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogRXhlY3V0ZSBhZnRlciBydW5uaW5nIHRlc3RzLlxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAgICAgKi9cXG4gICAgYWZ0ZXI6IGZ1bmN0aW9uIChuYW1lLCBmbikge1xcbiAgICAgIHN1aXRlc1swXS5hZnRlckFsbChuYW1lLCBmbik7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGVjdXRlIGJlZm9yZSBlYWNoIHRlc3QgY2FzZS5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gICAgICovXFxuICAgIGJlZm9yZUVhY2g6IGZ1bmN0aW9uIChuYW1lLCBmbikge1xcbiAgICAgIHN1aXRlc1swXS5iZWZvcmVFYWNoKG5hbWUsIGZuKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4ZWN1dGUgYWZ0ZXIgZWFjaCB0ZXN0IGNhc2UuXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICAgICAqL1xcbiAgICBhZnRlckVhY2g6IGZ1bmN0aW9uIChuYW1lLCBmbikge1xcbiAgICAgIHN1aXRlc1swXS5hZnRlckVhY2gobmFtZSwgZm4pO1xcbiAgICB9LFxcblxcbiAgICBzdWl0ZToge1xcbiAgICAgIC8qKlxcbiAgICAgICAqIENyZWF0ZSBhbiBleGNsdXNpdmUgU3VpdGU7IGNvbnZlbmllbmNlIGZ1bmN0aW9uXFxuICAgICAgICogU2VlIGRvY3N0cmluZyBmb3IgY3JlYXRlKCkgYmVsb3cuXFxuICAgICAgICpcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xcbiAgICAgICAqIEByZXR1cm5zIHtTdWl0ZX1cXG4gICAgICAgKi9cXG4gICAgICBvbmx5OiBmdW5jdGlvbiBvbmx5IChvcHRzKSB7XFxuICAgICAgICBvcHRzLmlzT25seSA9IHRydWU7XFxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUob3B0cyk7XFxuICAgICAgfSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBDcmVhdGUgYSBTdWl0ZSwgYnV0IHNraXAgaXQ7IGNvbnZlbmllbmNlIGZ1bmN0aW9uXFxuICAgICAgICogU2VlIGRvY3N0cmluZyBmb3IgY3JlYXRlKCkgYmVsb3cuXFxuICAgICAgICpcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xcbiAgICAgICAqIEByZXR1cm5zIHtTdWl0ZX1cXG4gICAgICAgKi9cXG4gICAgICBza2lwOiBmdW5jdGlvbiBza2lwIChvcHRzKSB7XFxuICAgICAgICBvcHRzLnBlbmRpbmcgPSB0cnVlO1xcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKG9wdHMpO1xcbiAgICAgIH0sXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogQ3JlYXRlcyBhIHN1aXRlLlxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbnNcXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy50aXRsZSBUaXRsZSBvZiBTdWl0ZVxcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmZuXSBTdWl0ZSBGdW5jdGlvbiAobm90IGFsd2F5cyBhcHBsaWNhYmxlKVxcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMucGVuZGluZ10gSXMgU3VpdGUgcGVuZGluZz9cXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZmlsZV0gRmlsZXBhdGggd2hlcmUgdGhpcyBTdWl0ZSByZXNpZGVzXFxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pc09ubHldIElzIFN1aXRlIGV4Y2x1c2l2ZT9cXG4gICAgICAgKiBAcmV0dXJucyB7U3VpdGV9XFxuICAgICAgICovXFxuICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKG9wdHMpIHtcXG4gICAgICAgIHZhciBzdWl0ZSA9IFN1aXRlLmNyZWF0ZShzdWl0ZXNbMF0sIG9wdHMudGl0bGUpO1xcbiAgICAgICAgc3VpdGUucGVuZGluZyA9IEJvb2xlYW4ob3B0cy5wZW5kaW5nKTtcXG4gICAgICAgIHN1aXRlLmZpbGUgPSBvcHRzLmZpbGU7XFxuICAgICAgICBzdWl0ZXMudW5zaGlmdChzdWl0ZSk7XFxuICAgICAgICBpZiAob3B0cy5pc09ubHkpIHtcXG4gICAgICAgICAgc3VpdGUucGFyZW50Ll9vbmx5U3VpdGVzID0gc3VpdGUucGFyZW50Ll9vbmx5U3VpdGVzLmNvbmNhdChzdWl0ZSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodHlwZW9mIG9wdHMuZm4gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgb3B0cy5mbi5jYWxsKHN1aXRlKTtcXG4gICAgICAgICAgc3VpdGVzLnNoaWZ0KCk7XFxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLmZuID09PSAndW5kZWZpbmVkJyAmJiAhc3VpdGUucGVuZGluZykge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1aXRlIFxcXCInICsgc3VpdGUuZnVsbFRpdGxlKCkgKyAnXFxcIiB3YXMgZGVmaW5lZCBidXQgbm8gY2FsbGJhY2sgd2FzIHN1cHBsaWVkLiBTdXBwbHkgYSBjYWxsYmFjayBvciBleHBsaWNpdGx5IHNraXAgdGhlIHN1aXRlLicpO1xcbiAgICAgICAgfSBlbHNlIGlmICghb3B0cy5mbiAmJiBzdWl0ZS5wZW5kaW5nKSB7XFxuICAgICAgICAgIHN1aXRlcy5zaGlmdCgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHN1aXRlO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgdGVzdDoge1xcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEV4Y2x1c2l2ZSB0ZXN0LWNhc2UuXFxuICAgICAgICpcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9jaGFcXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0ZXN0XFxuICAgICAgICogQHJldHVybnMgeyp9XFxuICAgICAgICovXFxuICAgICAgb25seTogZnVuY3Rpb24gKG1vY2hhLCB0ZXN0KSB7XFxuICAgICAgICB0ZXN0LnBhcmVudC5fb25seVRlc3RzID0gdGVzdC5wYXJlbnQuX29ubHlUZXN0cy5jb25jYXQodGVzdCk7XFxuICAgICAgICByZXR1cm4gdGVzdDtcXG4gICAgICB9LFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIFBlbmRpbmcgdGVzdCBjYXNlLlxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXFxuICAgICAgICovXFxuICAgICAgc2tpcDogZnVuY3Rpb24gKHRpdGxlKSB7XFxuICAgICAgICBjb250ZXh0LnRlc3QodGl0bGUpO1xcbiAgICAgIH0sXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogTnVtYmVyIG9mIHJldHJ5IGF0dGVtcHRzXFxuICAgICAgICpcXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gblxcbiAgICAgICAqL1xcbiAgICAgIHJldHJpZXM6IGZ1bmN0aW9uIChuKSB7XFxuICAgICAgICBjb250ZXh0LnJldHJpZXMobik7XFxuICAgICAgfVxcbiAgICB9XFxuICB9O1xcbn07XFxuXFxufSx7XFxcIi4uL3N1aXRlXFxcIjozNH1dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBTdWl0ZSA9IHJlcXVpcmUoJy4uL3N1aXRlJyk7XFxudmFyIFRlc3QgPSByZXF1aXJlKCcuLi90ZXN0Jyk7XFxuXFxuLyoqXFxuICogRXhwb3J0cy1zdHlsZSAoYXMgTm9kZS5qcyBtb2R1bGUpIGludGVyZmFjZTpcXG4gKlxcbiAqICAgICBleHBvcnRzLkFycmF5ID0ge1xcbiAqICAgICAgICcjaW5kZXhPZigpJzoge1xcbiAqICAgICAgICAgJ3Nob3VsZCByZXR1cm4gLTEgd2hlbiB0aGUgdmFsdWUgaXMgbm90IHByZXNlbnQnOiBmdW5jdGlvbigpIHtcXG4gKlxcbiAqICAgICAgICAgfSxcXG4gKlxcbiAqICAgICAgICAgJ3Nob3VsZCByZXR1cm4gdGhlIGNvcnJlY3QgaW5kZXggd2hlbiB0aGUgdmFsdWUgaXMgcHJlc2VudCc6IGZ1bmN0aW9uKCkge1xcbiAqXFxuICogICAgICAgICB9XFxuICogICAgICAgfVxcbiAqICAgICB9O1xcbiAqXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGUgUm9vdCBzdWl0ZS5cXG4gKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgdmFyIHN1aXRlcyA9IFtzdWl0ZV07XFxuXFxuICBzdWl0ZS5vbigncmVxdWlyZScsIHZpc2l0KTtcXG5cXG4gIGZ1bmN0aW9uIHZpc2l0IChvYmosIGZpbGUpIHtcXG4gICAgdmFyIHN1aXRlO1xcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XFxuICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgdmFyIGZuID0gb2JqW2tleV07XFxuICAgICAgICBzd2l0Y2ggKGtleSkge1xcbiAgICAgICAgICBjYXNlICdiZWZvcmUnOlxcbiAgICAgICAgICAgIHN1aXRlc1swXS5iZWZvcmVBbGwoZm4pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlICdhZnRlcic6XFxuICAgICAgICAgICAgc3VpdGVzWzBdLmFmdGVyQWxsKGZuKTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgY2FzZSAnYmVmb3JlRWFjaCc6XFxuICAgICAgICAgICAgc3VpdGVzWzBdLmJlZm9yZUVhY2goZm4pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlICdhZnRlckVhY2gnOlxcbiAgICAgICAgICAgIHN1aXRlc1swXS5hZnRlckVhY2goZm4pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgIHZhciB0ZXN0ID0gbmV3IFRlc3Qoa2V5LCBmbik7XFxuICAgICAgICAgICAgdGVzdC5maWxlID0gZmlsZTtcXG4gICAgICAgICAgICBzdWl0ZXNbMF0uYWRkVGVzdCh0ZXN0KTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc3VpdGUgPSBTdWl0ZS5jcmVhdGUoc3VpdGVzWzBdLCBrZXkpO1xcbiAgICAgICAgc3VpdGVzLnVuc2hpZnQoc3VpdGUpO1xcbiAgICAgICAgdmlzaXQob2JqW2tleV0sIGZpbGUpO1xcbiAgICAgICAgc3VpdGVzLnNoaWZ0KCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufTtcXG5cXG59LHtcXFwiLi4vc3VpdGVcXFwiOjM0LFxcXCIuLi90ZXN0XFxcIjozNX1dLDEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuZXhwb3J0cy5iZGQgPSByZXF1aXJlKCcuL2JkZCcpO1xcbmV4cG9ydHMudGRkID0gcmVxdWlyZSgnLi90ZGQnKTtcXG5leHBvcnRzLnF1bml0ID0gcmVxdWlyZSgnLi9xdW5pdCcpO1xcbmV4cG9ydHMuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZXhwb3J0cycpO1xcblxcbn0se1xcXCIuL2JkZFxcXCI6NyxcXFwiLi9leHBvcnRzXFxcIjo5LFxcXCIuL3F1bml0XFxcIjoxMSxcXFwiLi90ZGRcXFwiOjEyfV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBUZXN0ID0gcmVxdWlyZSgnLi4vdGVzdCcpO1xcblxcbi8qKlxcbiAqIFFVbml0LXN0eWxlIGludGVyZmFjZTpcXG4gKlxcbiAqICAgICBzdWl0ZSgnQXJyYXknKTtcXG4gKlxcbiAqICAgICB0ZXN0KCcjbGVuZ3RoJywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgdmFyIGFyciA9IFsxLDIsM107XFxuICogICAgICAgb2soYXJyLmxlbmd0aCA9PSAzKTtcXG4gKiAgICAgfSk7XFxuICpcXG4gKiAgICAgdGVzdCgnI2luZGV4T2YoKScsIGZ1bmN0aW9uKCkge1xcbiAqICAgICAgIHZhciBhcnIgPSBbMSwyLDNdO1xcbiAqICAgICAgIG9rKGFyci5pbmRleE9mKDEpID09IDApO1xcbiAqICAgICAgIG9rKGFyci5pbmRleE9mKDIpID09IDEpO1xcbiAqICAgICAgIG9rKGFyci5pbmRleE9mKDMpID09IDIpO1xcbiAqICAgICB9KTtcXG4gKlxcbiAqICAgICBzdWl0ZSgnU3RyaW5nJyk7XFxuICpcXG4gKiAgICAgdGVzdCgnI2xlbmd0aCcsIGZ1bmN0aW9uKCkge1xcbiAqICAgICAgIG9rKCdmb28nLmxlbmd0aCA9PSAzKTtcXG4gKiAgICAgfSk7XFxuICpcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSBSb290IHN1aXRlLlxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN1aXRlKSB7XFxuICB2YXIgc3VpdGVzID0gW3N1aXRlXTtcXG5cXG4gIHN1aXRlLm9uKCdwcmUtcmVxdWlyZScsIGZ1bmN0aW9uIChjb250ZXh0LCBmaWxlLCBtb2NoYSkge1xcbiAgICB2YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKShzdWl0ZXMsIGNvbnRleHQsIG1vY2hhKTtcXG5cXG4gICAgY29udGV4dC5iZWZvcmUgPSBjb21tb24uYmVmb3JlO1xcbiAgICBjb250ZXh0LmFmdGVyID0gY29tbW9uLmFmdGVyO1xcbiAgICBjb250ZXh0LmJlZm9yZUVhY2ggPSBjb21tb24uYmVmb3JlRWFjaDtcXG4gICAgY29udGV4dC5hZnRlckVhY2ggPSBjb21tb24uYWZ0ZXJFYWNoO1xcbiAgICBjb250ZXh0LnJ1biA9IG1vY2hhLm9wdGlvbnMuZGVsYXkgJiYgY29tbW9uLnJ1bldpdGhTdWl0ZShzdWl0ZSk7XFxuICAgIC8qKlxcbiAgICAgKiBEZXNjcmliZSBhIFxcXCJzdWl0ZVxcXCIgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYC5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQuc3VpdGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcXG4gICAgICBpZiAoc3VpdGVzLmxlbmd0aCA+IDEpIHtcXG4gICAgICAgIHN1aXRlcy5zaGlmdCgpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLmNyZWF0ZSh7XFxuICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICBmaWxlOiBmaWxlLFxcbiAgICAgICAgZm46IGZhbHNlXFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGNsdXNpdmUgU3VpdGUuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0LnN1aXRlLm9ubHkgPSBmdW5jdGlvbiAodGl0bGUpIHtcXG4gICAgICBpZiAoc3VpdGVzLmxlbmd0aCA+IDEpIHtcXG4gICAgICAgIHN1aXRlcy5zaGlmdCgpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLm9ubHkoe1xcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgZmlsZTogZmlsZSxcXG4gICAgICAgIGZuOiBmYWxzZVxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRGVzY3JpYmUgYSBzcGVjaWZpY2F0aW9uIG9yIHRlc3QtY2FzZVxcbiAgICAgKiB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gXFxuICAgICAqIGFjdGluZyBhcyBhIHRodW5rLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC50ZXN0ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgICAgIHZhciB0ZXN0ID0gbmV3IFRlc3QodGl0bGUsIGZuKTtcXG4gICAgICB0ZXN0LmZpbGUgPSBmaWxlO1xcbiAgICAgIHN1aXRlc1swXS5hZGRUZXN0KHRlc3QpO1xcbiAgICAgIHJldHVybiB0ZXN0O1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRXhjbHVzaXZlIHRlc3QtY2FzZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQudGVzdC5vbmx5ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgICAgIHJldHVybiBjb21tb24udGVzdC5vbmx5KG1vY2hhLCBjb250ZXh0LnRlc3QodGl0bGUsIGZuKSk7XFxuICAgIH07XFxuXFxuICAgIGNvbnRleHQudGVzdC5za2lwID0gY29tbW9uLnRlc3Quc2tpcDtcXG4gICAgY29udGV4dC50ZXN0LnJldHJpZXMgPSBjb21tb24udGVzdC5yZXRyaWVzO1xcbiAgfSk7XFxufTtcXG5cXG59LHtcXFwiLi4vdGVzdFxcXCI6MzUsXFxcIi4vY29tbW9uXFxcIjo4fV0sMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBUZXN0ID0gcmVxdWlyZSgnLi4vdGVzdCcpO1xcblxcbi8qKlxcbiAqIFRERC1zdHlsZSBpbnRlcmZhY2U6XFxuICpcXG4gKiAgICAgIHN1aXRlKCdBcnJheScsIGZ1bmN0aW9uKCkge1xcbiAqICAgICAgICBzdWl0ZSgnI2luZGV4T2YoKScsIGZ1bmN0aW9uKCkge1xcbiAqICAgICAgICAgIHN1aXRlU2V0dXAoZnVuY3Rpb24oKSB7XFxuICpcXG4gKiAgICAgICAgICB9KTtcXG4gKlxcbiAqICAgICAgICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gLTEgd2hlbiBub3QgcHJlc2VudCcsIGZ1bmN0aW9uKCkge1xcbiAqXFxuICogICAgICAgICAgfSk7XFxuICpcXG4gKiAgICAgICAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIHRoZSBpbmRleCB3aGVuIHByZXNlbnQnLCBmdW5jdGlvbigpIHtcXG4gKlxcbiAqICAgICAgICAgIH0pO1xcbiAqXFxuICogICAgICAgICAgc3VpdGVUZWFyZG93bihmdW5jdGlvbigpIHtcXG4gKlxcbiAqICAgICAgICAgIH0pO1xcbiAqICAgICAgICB9KTtcXG4gKiAgICAgIH0pO1xcbiAqXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGUgUm9vdCBzdWl0ZS5cXG4gKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgdmFyIHN1aXRlcyA9IFtzdWl0ZV07XFxuXFxuICBzdWl0ZS5vbigncHJlLXJlcXVpcmUnLCBmdW5jdGlvbiAoY29udGV4dCwgZmlsZSwgbW9jaGEpIHtcXG4gICAgdmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJykoc3VpdGVzLCBjb250ZXh0LCBtb2NoYSk7XFxuXFxuICAgIGNvbnRleHQuc2V0dXAgPSBjb21tb24uYmVmb3JlRWFjaDtcXG4gICAgY29udGV4dC50ZWFyZG93biA9IGNvbW1vbi5hZnRlckVhY2g7XFxuICAgIGNvbnRleHQuc3VpdGVTZXR1cCA9IGNvbW1vbi5iZWZvcmU7XFxuICAgIGNvbnRleHQuc3VpdGVUZWFyZG93biA9IGNvbW1vbi5hZnRlcjtcXG4gICAgY29udGV4dC5ydW4gPSBtb2NoYS5vcHRpb25zLmRlbGF5ICYmIGNvbW1vbi5ydW5XaXRoU3VpdGUoc3VpdGUpO1xcblxcbiAgICAvKipcXG4gICAgICogRGVzY3JpYmUgYSBcXFwic3VpdGVcXFwiIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmAgY29udGFpbmluZ1xcbiAgICAgKiBuZXN0ZWQgc3VpdGVzIGFuZC9vciB0ZXN0cy5cXG4gICAgICovXFxuICAgIGNvbnRleHQuc3VpdGUgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgcmV0dXJuIGNvbW1vbi5zdWl0ZS5jcmVhdGUoe1xcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgZmlsZTogZmlsZSxcXG4gICAgICAgIGZuOiBmblxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogUGVuZGluZyBzdWl0ZS5cXG4gICAgICovXFxuICAgIGNvbnRleHQuc3VpdGUuc2tpcCA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLnNraXAoe1xcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgZmlsZTogZmlsZSxcXG4gICAgICAgIGZuOiBmblxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRXhjbHVzaXZlIHRlc3QtY2FzZS5cXG4gICAgICovXFxuICAgIGNvbnRleHQuc3VpdGUub25seSA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLm9ubHkoe1xcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgZmlsZTogZmlsZSxcXG4gICAgICAgIGZuOiBmblxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRGVzY3JpYmUgYSBzcGVjaWZpY2F0aW9uIG9yIHRlc3QtY2FzZSB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZFxcbiAgICAgKiBjYWxsYmFjayBgZm5gIGFjdGluZyBhcyBhIHRodW5rLlxcbiAgICAgKi9cXG4gICAgY29udGV4dC50ZXN0ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgICAgIHZhciBzdWl0ZSA9IHN1aXRlc1swXTtcXG4gICAgICBpZiAoc3VpdGUuaXNQZW5kaW5nKCkpIHtcXG4gICAgICAgIGZuID0gbnVsbDtcXG4gICAgICB9XFxuICAgICAgdmFyIHRlc3QgPSBuZXcgVGVzdCh0aXRsZSwgZm4pO1xcbiAgICAgIHRlc3QuZmlsZSA9IGZpbGU7XFxuICAgICAgc3VpdGUuYWRkVGVzdCh0ZXN0KTtcXG4gICAgICByZXR1cm4gdGVzdDtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4Y2x1c2l2ZSB0ZXN0LWNhc2UuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0LnRlc3Qub25seSA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gICAgICByZXR1cm4gY29tbW9uLnRlc3Qub25seShtb2NoYSwgY29udGV4dC50ZXN0KHRpdGxlLCBmbikpO1xcbiAgICB9O1xcblxcbiAgICBjb250ZXh0LnRlc3Quc2tpcCA9IGNvbW1vbi50ZXN0LnNraXA7XFxuICAgIGNvbnRleHQudGVzdC5yZXRyaWVzID0gY29tbW9uLnRlc3QucmV0cmllcztcXG4gIH0pO1xcbn07XFxuXFxufSx7XFxcIi4uL3Rlc3RcXFwiOjM1LFxcXCIuL2NvbW1vblxcXCI6OH1dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLF9fZGlybmFtZSl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qIVxcbiAqIG1vY2hhXFxuICogQ29weXJpZ2h0KGMpIDIwMTEgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cXG4gKiBNSVQgTGljZW5zZWRcXG4gKi9cXG4vKipcXG4gKiBAbmFtZXNwYWNlIE1vY2hhXFxuICogQG1vZHVsZSBNb2NoYVxcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIGVzY2FwZVJlID0gcmVxdWlyZSgnZXNjYXBlLXN0cmluZy1yZWdleHAnKTtcXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcXG52YXIgcmVwb3J0ZXJzID0gcmVxdWlyZSgnLi9yZXBvcnRlcnMnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBNb2NoYWAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTW9jaGE7XFxuXFxuLyoqXFxuICogVG8gcmVxdWlyZSBsb2NhbCBVSXMgYW5kIHJlcG9ydGVycyB3aGVuIHJ1bm5pbmcgaW4gbm9kZS5cXG4gKi9cXG5cXG5pZiAoIXByb2Nlc3MuYnJvd3Nlcikge1xcbiAgdmFyIGN3ZCA9IHByb2Nlc3MuY3dkKCk7XFxuICBtb2R1bGUucGF0aHMucHVzaChjd2QsIHBhdGguam9pbihjd2QsICdub2RlX21vZHVsZXMnKSk7XFxufVxcblxcbi8qKlxcbiAqIEV4cG9zZSBpbnRlcm5hbHMuXFxuICovXFxuXFxuLyoqXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzcyB1dGlsc1xcbiAqIEBtZW1iZXJvZiBNb2NoYVxcbiAqL1xcbmV4cG9ydHMudXRpbHMgPSB1dGlscztcXG5leHBvcnRzLmludGVyZmFjZXMgPSByZXF1aXJlKCcuL2ludGVyZmFjZXMnKTtcXG4vKipcXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYVxcbiAqIEBwdWJsaWNcXG4gKi9cXG5leHBvcnRzLnJlcG9ydGVycyA9IHJlcG9ydGVycztcXG5leHBvcnRzLlJ1bm5hYmxlID0gcmVxdWlyZSgnLi9ydW5uYWJsZScpO1xcbmV4cG9ydHMuQ29udGV4dCA9IHJlcXVpcmUoJy4vY29udGV4dCcpO1xcbi8qKlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhXFxuICovXFxuZXhwb3J0cy5SdW5uZXIgPSByZXF1aXJlKCcuL3J1bm5lcicpO1xcbmV4cG9ydHMuU3VpdGUgPSByZXF1aXJlKCcuL3N1aXRlJyk7XFxuZXhwb3J0cy5Ib29rID0gcmVxdWlyZSgnLi9ob29rJyk7XFxuZXhwb3J0cy5UZXN0ID0gcmVxdWlyZSgnLi90ZXN0Jyk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGltYWdlIGBuYW1lYCBwYXRoLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gaW1hZ2UgKG5hbWUpIHtcXG4gIHJldHVybiBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4vaW1hZ2VzJywgbmFtZSArICcucG5nJyk7XFxufVxcblxcbi8qKlxcbiAqIFNldCB1cCBtb2NoYSB3aXRoIGBvcHRpb25zYC5cXG4gKlxcbiAqIE9wdGlvbnM6XFxuICpcXG4gKiAgIC0gYHVpYCBuYW1lIFxcXCJiZGRcXFwiLCBcXFwidGRkXFxcIiwgXFxcImV4cG9ydHNcXFwiIGV0Y1xcbiAqICAgLSBgcmVwb3J0ZXJgIHJlcG9ydGVyIGluc3RhbmNlLCBkZWZhdWx0cyB0byBgbW9jaGEucmVwb3J0ZXJzLnNwZWNgXFxuICogICAtIGBnbG9iYWxzYCBhcnJheSBvZiBhY2NlcHRlZCBnbG9iYWxzXFxuICogICAtIGB0aW1lb3V0YCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xcbiAqICAgLSBgcmV0cmllc2AgbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5IGZhaWxlZCB0ZXN0c1xcbiAqICAgLSBgYmFpbGAgYmFpbCBvbiB0aGUgZmlyc3QgdGVzdCBmYWlsdXJlXFxuICogICAtIGBzbG93YCBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgY29uc2lkZXJpbmcgYSB0ZXN0IHNsb3dcXG4gKiAgIC0gYGlnbm9yZUxlYWtzYCBpZ25vcmUgZ2xvYmFsIGxlYWtzXFxuICogICAtIGBmdWxsVHJhY2VgIGRpc3BsYXkgdGhlIGZ1bGwgc3RhY2stdHJhY2Ugb24gZmFpbGluZ1xcbiAqICAgLSBgZ3JlcGAgc3RyaW5nIG9yIHJlZ2V4cCB0byBmaWx0ZXIgdGVzdHMgd2l0aFxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzcyBNb2NoYVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5mdW5jdGlvbiBNb2NoYSAob3B0aW9ucykge1xcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuICB0aGlzLmZpbGVzID0gW107XFxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xcbiAgaWYgKG9wdGlvbnMuZ3JlcCkge1xcbiAgICB0aGlzLmdyZXAobmV3IFJlZ0V4cChvcHRpb25zLmdyZXApKTtcXG4gIH1cXG4gIGlmIChvcHRpb25zLmZncmVwKSB7XFxuICAgIHRoaXMuZmdyZXAob3B0aW9ucy5mZ3JlcCk7XFxuICB9XFxuICB0aGlzLnN1aXRlID0gbmV3IGV4cG9ydHMuU3VpdGUoJycsIG5ldyBleHBvcnRzLkNvbnRleHQoKSk7XFxuICB0aGlzLnVpKG9wdGlvbnMudWkpO1xcbiAgdGhpcy5iYWlsKG9wdGlvbnMuYmFpbCk7XFxuICB0aGlzLnJlcG9ydGVyKG9wdGlvbnMucmVwb3J0ZXIsIG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zKTtcXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy50aW1lb3V0ICE9PSAndW5kZWZpbmVkJyAmJiBvcHRpb25zLnRpbWVvdXQgIT09IG51bGwpIHtcXG4gICAgdGhpcy50aW1lb3V0KG9wdGlvbnMudGltZW91dCk7XFxuICB9XFxuICBpZiAodHlwZW9mIG9wdGlvbnMucmV0cmllcyAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0aW9ucy5yZXRyaWVzICE9PSBudWxsKSB7XFxuICAgIHRoaXMucmV0cmllcyhvcHRpb25zLnJldHJpZXMpO1xcbiAgfVxcbiAgdGhpcy51c2VDb2xvcnMob3B0aW9ucy51c2VDb2xvcnMpO1xcbiAgaWYgKG9wdGlvbnMuZW5hYmxlVGltZW91dHMgIT09IG51bGwpIHtcXG4gICAgdGhpcy5lbmFibGVUaW1lb3V0cyhvcHRpb25zLmVuYWJsZVRpbWVvdXRzKTtcXG4gIH1cXG4gIGlmIChvcHRpb25zLnNsb3cpIHtcXG4gICAgdGhpcy5zbG93KG9wdGlvbnMuc2xvdyk7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIEVuYWJsZSBvciBkaXNhYmxlIGJhaWxpbmcgb24gdGhlIGZpcnN0IGZhaWx1cmUuXFxuICpcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtiYWlsXVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5iYWlsID0gZnVuY3Rpb24gKGJhaWwpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICBiYWlsID0gdHJ1ZTtcXG4gIH1cXG4gIHRoaXMuc3VpdGUuYmFpbChiYWlsKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogQWRkIHRlc3QgYGZpbGVgLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuYWRkRmlsZSA9IGZ1bmN0aW9uIChmaWxlKSB7XFxuICB0aGlzLmZpbGVzLnB1c2goZmlsZSk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCByZXBvcnRlciB0byBgcmVwb3J0ZXJgLCBkZWZhdWx0cyB0byBcXFwic3BlY1xcXCIuXFxuICpcXG4gKiBAcHVibGljXFxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHJlcG9ydGVyIG5hbWUgb3IgY29uc3RydWN0b3JcXG4gKiBAcGFyYW0ge09iamVjdH0gcmVwb3J0ZXJPcHRpb25zIG9wdGlvbmFsIG9wdGlvbnNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufSByZXBvcnRlciBuYW1lIG9yIGNvbnN0cnVjdG9yXFxuICogQHBhcmFtIHtPYmplY3R9IHJlcG9ydGVyT3B0aW9ucyBvcHRpb25hbCBvcHRpb25zXFxuICovXFxuTW9jaGEucHJvdG90eXBlLnJlcG9ydGVyID0gZnVuY3Rpb24gKHJlcG9ydGVyLCByZXBvcnRlck9wdGlvbnMpIHtcXG4gIGlmICh0eXBlb2YgcmVwb3J0ZXIgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgdGhpcy5fcmVwb3J0ZXIgPSByZXBvcnRlcjtcXG4gIH0gZWxzZSB7XFxuICAgIHJlcG9ydGVyID0gcmVwb3J0ZXIgfHwgJ3NwZWMnO1xcbiAgICB2YXIgX3JlcG9ydGVyO1xcbiAgICAvLyBUcnkgdG8gbG9hZCBhIGJ1aWx0LWluIHJlcG9ydGVyLlxcbiAgICBpZiAocmVwb3J0ZXJzW3JlcG9ydGVyXSkge1xcbiAgICAgIF9yZXBvcnRlciA9IHJlcG9ydGVyc1tyZXBvcnRlcl07XFxuICAgIH1cXG4gICAgLy8gVHJ5IHRvIGxvYWQgcmVwb3J0ZXJzIGZyb20gcHJvY2Vzcy5jd2QoKSBhbmQgbm9kZV9tb2R1bGVzXFxuICAgIGlmICghX3JlcG9ydGVyKSB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIF9yZXBvcnRlciA9IHJlcXVpcmUocmVwb3J0ZXIpO1xcbiAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoJ0Nhbm5vdCBmaW5kIG1vZHVsZScpICE9PSAtMSkge1xcbiAgICAgICAgICAvLyBUcnkgdG8gbG9hZCByZXBvcnRlcnMgZnJvbSBhIHBhdGggKGFic29sdXRlIG9yIHJlbGF0aXZlKVxcbiAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIF9yZXBvcnRlciA9IHJlcXVpcmUocGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIHJlcG9ydGVyKSk7XFxuICAgICAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcXG4gICAgICAgICAgICBlcnIubWVzc2FnZS5pbmRleE9mKCdDYW5ub3QgZmluZCBtb2R1bGUnKSAhPT0gLTEgPyBjb25zb2xlLndhcm4oJ1xcXCInICsgcmVwb3J0ZXIgKyAnXFxcIiByZXBvcnRlciBub3QgZm91bmQnKVxcbiAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm4oJ1xcXCInICsgcmVwb3J0ZXIgKyAnXFxcIiByZXBvcnRlciBibGV3IHVwIHdpdGggZXJyb3I6XFxcXG4nICsgZXJyLnN0YWNrKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgY29uc29sZS53YXJuKCdcXFwiJyArIHJlcG9ydGVyICsgJ1xcXCIgcmVwb3J0ZXIgYmxldyB1cCB3aXRoIGVycm9yOlxcXFxuJyArIGVyci5zdGFjayk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmICghX3JlcG9ydGVyICYmIHJlcG9ydGVyID09PSAndGVhbWNpdHknKSB7XFxuICAgICAgY29uc29sZS53YXJuKCdUaGUgVGVhbWNpdHkgcmVwb3J0ZXIgd2FzIG1vdmVkIHRvIGEgcGFja2FnZSBuYW1lZCAnICtcXG4gICAgICAgICdtb2NoYS10ZWFtY2l0eS1yZXBvcnRlciAnICtcXG4gICAgICAgICcoaHR0cHM6Ly9ucG1qcy5vcmcvcGFja2FnZS9tb2NoYS10ZWFtY2l0eS1yZXBvcnRlcikuJyk7XFxuICAgIH1cXG4gICAgaWYgKCFfcmVwb3J0ZXIpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVwb3J0ZXIgXFxcIicgKyByZXBvcnRlciArICdcXFwiJyk7XFxuICAgIH1cXG4gICAgdGhpcy5fcmVwb3J0ZXIgPSBfcmVwb3J0ZXI7XFxuICB9XFxuICB0aGlzLm9wdGlvbnMucmVwb3J0ZXJPcHRpb25zID0gcmVwb3J0ZXJPcHRpb25zO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgdGVzdCBVSSBgbmFtZWAsIGRlZmF1bHRzIHRvIFxcXCJiZGRcXFwiLlxcbiAqIEBwdWJsaWNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBiZGRcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUudWkgPSBmdW5jdGlvbiAobmFtZSkge1xcbiAgbmFtZSA9IG5hbWUgfHwgJ2JkZCc7XFxuICB0aGlzLl91aSA9IGV4cG9ydHMuaW50ZXJmYWNlc1tuYW1lXTtcXG4gIGlmICghdGhpcy5fdWkpIHtcXG4gICAgdHJ5IHtcXG4gICAgICB0aGlzLl91aSA9IHJlcXVpcmUobmFtZSk7XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnRlcmZhY2UgXFxcIicgKyBuYW1lICsgJ1xcXCInKTtcXG4gICAgfVxcbiAgfVxcbiAgdGhpcy5fdWkgPSB0aGlzLl91aSh0aGlzLnN1aXRlKTtcXG5cXG4gIHRoaXMuc3VpdGUub24oJ3ByZS1yZXF1aXJlJywgZnVuY3Rpb24gKGNvbnRleHQpIHtcXG4gICAgZXhwb3J0cy5hZnRlckVhY2ggPSBjb250ZXh0LmFmdGVyRWFjaCB8fCBjb250ZXh0LnRlYXJkb3duO1xcbiAgICBleHBvcnRzLmFmdGVyID0gY29udGV4dC5hZnRlciB8fCBjb250ZXh0LnN1aXRlVGVhcmRvd247XFxuICAgIGV4cG9ydHMuYmVmb3JlRWFjaCA9IGNvbnRleHQuYmVmb3JlRWFjaCB8fCBjb250ZXh0LnNldHVwO1xcbiAgICBleHBvcnRzLmJlZm9yZSA9IGNvbnRleHQuYmVmb3JlIHx8IGNvbnRleHQuc3VpdGVTZXR1cDtcXG4gICAgZXhwb3J0cy5kZXNjcmliZSA9IGNvbnRleHQuZGVzY3JpYmUgfHwgY29udGV4dC5zdWl0ZTtcXG4gICAgZXhwb3J0cy5pdCA9IGNvbnRleHQuaXQgfHwgY29udGV4dC50ZXN0O1xcbiAgICBleHBvcnRzLnhpdCA9IGNvbnRleHQueGl0IHx8IGNvbnRleHQudGVzdC5za2lwO1xcbiAgICBleHBvcnRzLnNldHVwID0gY29udGV4dC5zZXR1cCB8fCBjb250ZXh0LmJlZm9yZUVhY2g7XFxuICAgIGV4cG9ydHMuc3VpdGVTZXR1cCA9IGNvbnRleHQuc3VpdGVTZXR1cCB8fCBjb250ZXh0LmJlZm9yZTtcXG4gICAgZXhwb3J0cy5zdWl0ZVRlYXJkb3duID0gY29udGV4dC5zdWl0ZVRlYXJkb3duIHx8IGNvbnRleHQuYWZ0ZXI7XFxuICAgIGV4cG9ydHMuc3VpdGUgPSBjb250ZXh0LnN1aXRlIHx8IGNvbnRleHQuZGVzY3JpYmU7XFxuICAgIGV4cG9ydHMudGVhcmRvd24gPSBjb250ZXh0LnRlYXJkb3duIHx8IGNvbnRleHQuYWZ0ZXJFYWNoO1xcbiAgICBleHBvcnRzLnRlc3QgPSBjb250ZXh0LnRlc3QgfHwgY29udGV4dC5pdDtcXG4gICAgZXhwb3J0cy5ydW4gPSBjb250ZXh0LnJ1bjtcXG4gIH0pO1xcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBMb2FkIHJlZ2lzdGVyZWQgZmlsZXMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUubG9hZEZpbGVzID0gZnVuY3Rpb24gKGZuKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgc3VpdGUgPSB0aGlzLnN1aXRlO1xcbiAgdGhpcy5maWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XFxuICAgIGZpbGUgPSBwYXRoLnJlc29sdmUoZmlsZSk7XFxuICAgIHN1aXRlLmVtaXQoJ3ByZS1yZXF1aXJlJywgZ2xvYmFsLCBmaWxlLCBzZWxmKTtcXG4gICAgc3VpdGUuZW1pdCgncmVxdWlyZScsIHJlcXVpcmUoZmlsZSksIGZpbGUsIHNlbGYpO1xcbiAgICBzdWl0ZS5lbWl0KCdwb3N0LXJlcXVpcmUnLCBnbG9iYWwsIGZpbGUsIHNlbGYpO1xcbiAgfSk7XFxuICBmbiAmJiBmbigpO1xcbn07XFxuXFxuLyoqXFxuICogRW5hYmxlIGdyb3dsIHN1cHBvcnQuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuX2dyb3dsID0gZnVuY3Rpb24gKHJ1bm5lciwgcmVwb3J0ZXIpIHtcXG4gIHZhciBub3RpZnkgPSByZXF1aXJlKCdncm93bCcpO1xcblxcbiAgcnVubmVyLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBzdGF0cyA9IHJlcG9ydGVyLnN0YXRzO1xcbiAgICBpZiAoc3RhdHMuZmFpbHVyZXMpIHtcXG4gICAgICB2YXIgbXNnID0gc3RhdHMuZmFpbHVyZXMgKyAnIG9mICcgKyBydW5uZXIudG90YWwgKyAnIHRlc3RzIGZhaWxlZCc7XFxuICAgICAgbm90aWZ5KG1zZywgeyBuYW1lOiAnbW9jaGEnLCB0aXRsZTogJ0ZhaWxlZCcsIGltYWdlOiBpbWFnZSgnZXJyb3InKSB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBub3RpZnkoc3RhdHMucGFzc2VzICsgJyB0ZXN0cyBwYXNzZWQgaW4gJyArIHN0YXRzLmR1cmF0aW9uICsgJ21zJywge1xcbiAgICAgICAgbmFtZTogJ21vY2hhJyxcXG4gICAgICAgIHRpdGxlOiAnUGFzc2VkJyxcXG4gICAgICAgIGltYWdlOiBpbWFnZSgnb2snKVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9KTtcXG59O1xcblxcbi8qKlxcbiAqIEVzY2FwZSBzdHJpbmcgYW5kIGFkZCBpdCB0byBncmVwIGFzIGEgcmVnZXhwLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHN0clxcbiAqIEByZXR1cm5zIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZmdyZXAgPSBmdW5jdGlvbiAoc3RyKSB7XFxuICByZXR1cm4gdGhpcy5ncmVwKG5ldyBSZWdFeHAoZXNjYXBlUmUoc3RyKSkpO1xcbn07XFxuXFxuLyoqXFxuICogQWRkIHJlZ2V4cCB0byBncmVwLCBpZiBgcmVgIGlzIGEgc3RyaW5nIGl0IGlzIGVzY2FwZWQuXFxuICpcXG4gKiBAcHVibGljXFxuICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSByZVxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSByZVxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5ncmVwID0gZnVuY3Rpb24gKHJlKSB7XFxuICBpZiAodXRpbHMuaXNTdHJpbmcocmUpKSB7XFxuICAgIC8vIGV4dHJhY3QgYXJncyBpZiBpdCdzIHJlZ2V4LWxpa2UsIGkuZTogW3N0cmluZywgcGF0dGVybiwgZmxhZ11cXG4gICAgdmFyIGFyZyA9IHJlLm1hdGNoKC9eXFxcXC8oLiopXFxcXC8oZ3xpfCkkfC4qLyk7XFxuICAgIHRoaXMub3B0aW9ucy5ncmVwID0gbmV3IFJlZ0V4cChhcmdbMV0gfHwgYXJnWzBdLCBhcmdbMl0pO1xcbiAgfSBlbHNlIHtcXG4gICAgdGhpcy5vcHRpb25zLmdyZXAgPSByZTtcXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuLyoqXFxuICogSW52ZXJ0IGAuZ3JlcCgpYCBtYXRjaGVzLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMub3B0aW9ucy5pbnZlcnQgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBJZ25vcmUgZ2xvYmFsIGxlYWtzLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlnbm9yZVxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5pZ25vcmVMZWFrcyA9IGZ1bmN0aW9uIChpZ25vcmUpIHtcXG4gIHRoaXMub3B0aW9ucy5pZ25vcmVMZWFrcyA9IEJvb2xlYW4oaWdub3JlKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRW5hYmxlIGdsb2JhbCBsZWFrIGNoZWNraW5nLlxcbiAqXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmNoZWNrTGVha3MgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLm9wdGlvbnMuaWdub3JlTGVha3MgPSBmYWxzZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRGlzcGxheSBsb25nIHN0YWNrLXRyYWNlIG9uIGZhaWxpbmdcXG4gKlxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5mdWxsVHJhY2UgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLm9wdGlvbnMuZnVsbFN0YWNrVHJhY2UgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBFbmFibGUgZ3Jvd2wgc3VwcG9ydC5cXG4gKlxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5ncm93bCA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMub3B0aW9ucy5ncm93bCA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIElnbm9yZSBgZ2xvYmFsc2AgYXJyYXkgb3Igc3RyaW5nLlxcbiAqXFxuICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGdsb2JhbHNcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gZ2xvYmFsc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5nbG9iYWxzID0gZnVuY3Rpb24gKGdsb2JhbHMpIHtcXG4gIHRoaXMub3B0aW9ucy5nbG9iYWxzID0gKHRoaXMub3B0aW9ucy5nbG9iYWxzIHx8IFtdKS5jb25jYXQoZ2xvYmFscyk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEVtaXQgY29sb3Igb3V0cHV0LlxcbiAqXFxuICogQHBhcmFtIHtCb29sZWFufSBjb2xvcnNcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbG9yc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS51c2VDb2xvcnMgPSBmdW5jdGlvbiAoY29sb3JzKSB7XFxuICBpZiAoY29sb3JzICE9PSB1bmRlZmluZWQpIHtcXG4gICAgdGhpcy5vcHRpb25zLnVzZUNvbG9ycyA9IGNvbG9ycztcXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogVXNlIGlubGluZSBkaWZmcyByYXRoZXIgdGhhbiArLy0uXFxuICpcXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlubGluZURpZmZzXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICogQHBhcmFtIHtib29sZWFufSBpbmxpbmVEaWZmc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS51c2VJbmxpbmVEaWZmcyA9IGZ1bmN0aW9uIChpbmxpbmVEaWZmcykge1xcbiAgdGhpcy5vcHRpb25zLnVzZUlubGluZURpZmZzID0gaW5saW5lRGlmZnMgIT09IHVuZGVmaW5lZCAmJiBpbmxpbmVEaWZmcztcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRG8gbm90IHNob3cgZGlmZnMgYXQgYWxsLlxcbiAqXFxuICogQHBhcmFtIHtCb29sZWFufSBoaWRlRGlmZlxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGlkZURpZmZcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuaGlkZURpZmYgPSBmdW5jdGlvbiAoaGlkZURpZmYpIHtcXG4gIHRoaXMub3B0aW9ucy5oaWRlRGlmZiA9IGhpZGVEaWZmICE9PSB1bmRlZmluZWQgJiYgaGlkZURpZmY7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCB0aGUgdGltZW91dCBpbiBtaWxsaXNlY29uZHMuXFxuICpcXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZW91dFxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xcbiAgdGhpcy5zdWl0ZS50aW1lb3V0KHRpbWVvdXQpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgdGhlIG51bWJlciBvZiB0aW1lcyB0byByZXRyeSBmYWlsZWQgdGVzdHMuXFxuICpcXG4gKiBAcGFyYW0ge051bWJlcn0gcmV0cnkgdGltZXNcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUucmV0cmllcyA9IGZ1bmN0aW9uIChuKSB7XFxuICB0aGlzLnN1aXRlLnJldHJpZXMobik7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBzbG93bmVzcyB0aHJlc2hvbGQgaW4gbWlsbGlzZWNvbmRzLlxcbiAqXFxuICogQHBhcmFtIHtOdW1iZXJ9IHNsb3dcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKiBAcGFyYW0ge251bWJlcn0gc2xvd1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5zbG93ID0gZnVuY3Rpb24gKHNsb3cpIHtcXG4gIHRoaXMuc3VpdGUuc2xvdyhzbG93KTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRW5hYmxlIHRpbWVvdXRzLlxcbiAqXFxuICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLmVuYWJsZVRpbWVvdXRzID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcXG4gIHRoaXMuc3VpdGUuZW5hYmxlVGltZW91dHMoYXJndW1lbnRzLmxlbmd0aCAmJiBlbmFibGVkICE9PSB1bmRlZmluZWQgPyBlbmFibGVkIDogdHJ1ZSk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIE1ha2VzIGFsbCB0ZXN0cyBhc3luYyAoYWNjZXB0aW5nIGEgY2FsbGJhY2spXFxuICpcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuYXN5bmNPbmx5ID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5vcHRpb25zLmFzeW5jT25seSA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIERpc2FibGUgc3ludGF4IGhpZ2hsaWdodGluZyAoaW4gYnJvd3NlcikuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUubm9IaWdobGlnaHRpbmcgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLm9wdGlvbnMubm9IaWdobGlnaHRpbmcgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBFbmFibGUgdW5jYXVnaHQgZXJyb3JzIHRvIHByb3BhZ2F0ZSAoaW4gYnJvd3NlcikuXFxuICpcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuYWxsb3dVbmNhdWdodCA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMub3B0aW9ucy5hbGxvd1VuY2F1Z2h0ID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRGVsYXkgcm9vdCBzdWl0ZSBleGVjdXRpb24uXFxuICogQHJldHVybnMge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uIGRlbGF5ICgpIHtcXG4gIHRoaXMub3B0aW9ucy5kZWxheSA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFRlc3RzIG1hcmtlZCBvbmx5IGZhaWwgdGhlIHN1aXRlXFxuICogQHJldHVybnMge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5mb3JiaWRPbmx5ID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5vcHRpb25zLmZvcmJpZE9ubHkgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBQZW5kaW5nIHRlc3RzIGFuZCB0ZXN0cyBtYXJrZWQgc2tpcCBmYWlsIHRoZSBzdWl0ZVxcbiAqIEByZXR1cm5zIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZm9yYmlkUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMub3B0aW9ucy5mb3JiaWRQZW5kaW5nID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIHRlc3RzIGFuZCBpbnZva2UgYGZuKClgIHdoZW4gY29tcGxldGUuXFxuICpcXG4gKiBOb3RlIHRoYXQgYGxvYWRGaWxlc2AgcmVsaWVzIG9uIE5vZGUncyBgcmVxdWlyZWAgdG8gZXhlY3V0ZVxcbiAqIHRoZSB0ZXN0IGludGVyZmFjZSBmdW5jdGlvbnMgYW5kIHdpbGwgYmUgc3ViamVjdCB0byB0aGVcXG4gKiBjYWNoZSAtIGlmIHRoZSBmaWxlcyBhcmUgYWxyZWFkeSBpbiB0aGUgYHJlcXVpcmVgIGNhY2hlLFxcbiAqIHRoZXkgd2lsbCBlZmZlY3RpdmVseSBiZSBza2lwcGVkLiBUaGVyZWZvcmUsIHRvIHJ1biB0ZXN0c1xcbiAqIG11bHRpcGxlIHRpbWVzIG9yIHRvIHJ1biB0ZXN0cyBpbiBmaWxlcyB0aGF0IGFyZSBhbHJlYWR5XFxuICogaW4gdGhlIGByZXF1aXJlYCBjYWNoZSwgbWFrZSBzdXJlIHRvIGNsZWFyIHRoZW0gZnJvbSB0aGVcXG4gKiBjYWNoZSBmaXJzdCBpbiB3aGljaGV2ZXIgbWFubmVyIGJlc3Qgc3VpdHMgeW91ciBuZWVkcy5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7UnVubmVyfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoZm4pIHtcXG4gIGlmICh0aGlzLmZpbGVzLmxlbmd0aCkge1xcbiAgICB0aGlzLmxvYWRGaWxlcygpO1xcbiAgfVxcbiAgdmFyIHN1aXRlID0gdGhpcy5zdWl0ZTtcXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xcbiAgb3B0aW9ucy5maWxlcyA9IHRoaXMuZmlsZXM7XFxuICB2YXIgcnVubmVyID0gbmV3IGV4cG9ydHMuUnVubmVyKHN1aXRlLCBvcHRpb25zLmRlbGF5KTtcXG4gIHZhciByZXBvcnRlciA9IG5ldyB0aGlzLl9yZXBvcnRlcihydW5uZXIsIG9wdGlvbnMpO1xcbiAgcnVubmVyLmlnbm9yZUxlYWtzID0gb3B0aW9ucy5pZ25vcmVMZWFrcyAhPT0gZmFsc2U7XFxuICBydW5uZXIuZnVsbFN0YWNrVHJhY2UgPSBvcHRpb25zLmZ1bGxTdGFja1RyYWNlO1xcbiAgcnVubmVyLmFzeW5jT25seSA9IG9wdGlvbnMuYXN5bmNPbmx5O1xcbiAgcnVubmVyLmFsbG93VW5jYXVnaHQgPSBvcHRpb25zLmFsbG93VW5jYXVnaHQ7XFxuICBydW5uZXIuZm9yYmlkT25seSA9IG9wdGlvbnMuZm9yYmlkT25seTtcXG4gIHJ1bm5lci5mb3JiaWRQZW5kaW5nID0gb3B0aW9ucy5mb3JiaWRQZW5kaW5nO1xcbiAgaWYgKG9wdGlvbnMuZ3JlcCkge1xcbiAgICBydW5uZXIuZ3JlcChvcHRpb25zLmdyZXAsIG9wdGlvbnMuaW52ZXJ0KTtcXG4gIH1cXG4gIGlmIChvcHRpb25zLmdsb2JhbHMpIHtcXG4gICAgcnVubmVyLmdsb2JhbHMob3B0aW9ucy5nbG9iYWxzKTtcXG4gIH1cXG4gIGlmIChvcHRpb25zLmdyb3dsKSB7XFxuICAgIHRoaXMuX2dyb3dsKHJ1bm5lciwgcmVwb3J0ZXIpO1xcbiAgfVxcbiAgaWYgKG9wdGlvbnMudXNlQ29sb3JzICE9PSB1bmRlZmluZWQpIHtcXG4gICAgZXhwb3J0cy5yZXBvcnRlcnMuQmFzZS51c2VDb2xvcnMgPSBvcHRpb25zLnVzZUNvbG9ycztcXG4gIH1cXG4gIGV4cG9ydHMucmVwb3J0ZXJzLkJhc2UuaW5saW5lRGlmZnMgPSBvcHRpb25zLnVzZUlubGluZURpZmZzO1xcbiAgZXhwb3J0cy5yZXBvcnRlcnMuQmFzZS5oaWRlRGlmZiA9IG9wdGlvbnMuaGlkZURpZmY7XFxuXFxuICBmdW5jdGlvbiBkb25lIChmYWlsdXJlcykge1xcbiAgICBpZiAocmVwb3J0ZXIuZG9uZSkge1xcbiAgICAgIHJlcG9ydGVyLmRvbmUoZmFpbHVyZXMsIGZuKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBmbiAmJiBmbihmYWlsdXJlcyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBydW5uZXIucnVuKGRvbmUpO1xcbn07XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSxcXFwiL2xpYlxcXCIpXFxufSx7XFxcIi4vY29udGV4dFxcXCI6NSxcXFwiLi9ob29rXFxcIjo2LFxcXCIuL2ludGVyZmFjZXNcXFwiOjEwLFxcXCIuL3JlcG9ydGVyc1xcXCI6MjAsXFxcIi4vcnVubmFibGVcXFwiOjMyLFxcXCIuL3J1bm5lclxcXCI6MzMsXFxcIi4vc3VpdGVcXFwiOjM0LFxcXCIuL3Rlc3RcXFwiOjM1LFxcXCIuL3V0aWxzXFxcIjozNixcXFwiX3Byb2Nlc3NcXFwiOjU2LFxcXCJlc2NhcGUtc3RyaW5nLXJlZ2V4cFxcXCI6NDYsXFxcImdyb3dsXFxcIjoyLFxcXCJwYXRoXFxcIjo0MH1dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBtaWxsaXNlY29uZHNcXG4gKi9cXG4vKipcXG4gKiBIZWxwZXJzLlxcbiAqL1xcblxcbnZhciBzID0gMTAwMDtcXG52YXIgbSA9IHMgKiA2MDtcXG52YXIgaCA9IG0gKiA2MDtcXG52YXIgZCA9IGggKiAyNDtcXG52YXIgeSA9IGQgKiAzNjUuMjU7XFxuXFxuLyoqXFxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYVxcbiAqIEBwdWJsaWNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsXFxuICogQHJldHVybiB7c3RyaW5nfG51bWJlcn1cXG4gKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWwpIHtcXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcXG4gIH1cXG4gIHJldHVybiBmb3JtYXQodmFsKTtcXG59O1xcblxcbi8qKlxcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9XFxuICovXFxuZnVuY3Rpb24gcGFyc2UgKHN0cikge1xcbiAgdmFyIG1hdGNoID0gKC9eKCg/OlxcXFxkKyk/XFxcXC4/XFxcXGQrKSAqKG1zfHNlY29uZHM/fHN8bWludXRlcz98bXxob3Vycz98aHxkYXlzP3xkfHllYXJzP3x5KT8kL2kpLmV4ZWMoc3RyKTtcXG4gIGlmICghbWF0Y2gpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcXG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XFxuICBzd2l0Y2ggKHR5cGUpIHtcXG4gICAgY2FzZSAneWVhcnMnOlxcbiAgICBjYXNlICd5ZWFyJzpcXG4gICAgY2FzZSAneSc6XFxuICAgICAgcmV0dXJuIG4gKiB5O1xcbiAgICBjYXNlICdkYXlzJzpcXG4gICAgY2FzZSAnZGF5JzpcXG4gICAgY2FzZSAnZCc6XFxuICAgICAgcmV0dXJuIG4gKiBkO1xcbiAgICBjYXNlICdob3Vycyc6XFxuICAgIGNhc2UgJ2hvdXInOlxcbiAgICBjYXNlICdoJzpcXG4gICAgICByZXR1cm4gbiAqIGg7XFxuICAgIGNhc2UgJ21pbnV0ZXMnOlxcbiAgICBjYXNlICdtaW51dGUnOlxcbiAgICBjYXNlICdtJzpcXG4gICAgICByZXR1cm4gbiAqIG07XFxuICAgIGNhc2UgJ3NlY29uZHMnOlxcbiAgICBjYXNlICdzZWNvbmQnOlxcbiAgICBjYXNlICdzJzpcXG4gICAgICByZXR1cm4gbiAqIHM7XFxuICAgIGNhc2UgJ21zJzpcXG4gICAgICByZXR1cm4gbjtcXG4gICAgZGVmYXVsdDpcXG4gICAgICAvLyBObyBkZWZhdWx0IGNhc2VcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogRm9ybWF0IGZvciBgbXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IG1zXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIGZvcm1hdCAobXMpIHtcXG4gIGlmIChtcyA+PSBkKSB7XFxuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XFxuICB9XFxuICBpZiAobXMgPj0gaCkge1xcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xcbiAgfVxcbiAgaWYgKG1zID49IG0pIHtcXG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcXG4gIH1cXG4gIGlmIChtcyA+PSBzKSB7XFxuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XFxuICB9XFxuICByZXR1cm4gbXMgKyAnbXMnO1xcbn1cXG5cXG59LHt9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgUGVuZGluZ2AuXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBQZW5kaW5nO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFBlbmRpbmdgIGVycm9yIHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxcbiAqL1xcbmZ1bmN0aW9uIFBlbmRpbmcgKG1lc3NhZ2UpIHtcXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XFxufVxcblxcbn0se31dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBCYXNlXFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XFxudmFyIGRpZmYgPSByZXF1aXJlKCdkaWZmJyk7XFxudmFyIG1zID0gcmVxdWlyZSgnLi4vbXMnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xcbnZhciBzdXBwb3J0c0NvbG9yID0gcHJvY2Vzcy5icm93c2VyID8gbnVsbCA6IHJlcXVpcmUoJ3N1cHBvcnRzLWNvbG9yJyk7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBCYXNlYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBCYXNlO1xcblxcbi8qKlxcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZy5cXG4gKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb2NoYWpzL21vY2hhL2lzc3Vlcy8yMzdcXG4gKi9cXG5cXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycywgbm8tbmF0aXZlLXJlYXNzaWduICovXFxudmFyIERhdGUgPSBnbG9iYWwuRGF0ZTtcXG52YXIgc2V0VGltZW91dCA9IGdsb2JhbC5zZXRUaW1lb3V0O1xcbnZhciBzZXRJbnRlcnZhbCA9IGdsb2JhbC5zZXRJbnRlcnZhbDtcXG52YXIgY2xlYXJUaW1lb3V0ID0gZ2xvYmFsLmNsZWFyVGltZW91dDtcXG52YXIgY2xlYXJJbnRlcnZhbCA9IGdsb2JhbC5jbGVhckludGVydmFsO1xcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMsIG5vLW5hdGl2ZS1yZWFzc2lnbiAqL1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIGJvdGggc3RkaW8gc3RyZWFtcyBhcmUgYXNzb2NpYXRlZCB3aXRoIGEgdHR5LlxcbiAqL1xcblxcbnZhciBpc2F0dHkgPSB0dHkuaXNhdHR5KDEpICYmIHR0eS5pc2F0dHkoMik7XFxuXFxuLyoqXFxuICogRW5hYmxlIGNvbG9yaW5nIGJ5IGRlZmF1bHQsIGV4Y2VwdCBpbiB0aGUgYnJvd3NlciBpbnRlcmZhY2UuXFxuICovXFxuXFxuZXhwb3J0cy51c2VDb2xvcnMgPSAhcHJvY2Vzcy5icm93c2VyICYmIChzdXBwb3J0c0NvbG9yIHx8IChwcm9jZXNzLmVudi5NT0NIQV9DT0xPUlMgIT09IHVuZGVmaW5lZCkpO1xcblxcbi8qKlxcbiAqIElubGluZSBkaWZmcyBpbnN0ZWFkIG9mICsvLVxcbiAqL1xcblxcbmV4cG9ydHMuaW5saW5lRGlmZnMgPSBmYWxzZTtcXG5cXG4vKipcXG4gKiBEZWZhdWx0IGNvbG9yIG1hcC5cXG4gKi9cXG5cXG5leHBvcnRzLmNvbG9ycyA9IHtcXG4gIHBhc3M6IDkwLFxcbiAgZmFpbDogMzEsXFxuICAnYnJpZ2h0IHBhc3MnOiA5MixcXG4gICdicmlnaHQgZmFpbCc6IDkxLFxcbiAgJ2JyaWdodCB5ZWxsb3cnOiA5MyxcXG4gIHBlbmRpbmc6IDM2LFxcbiAgc3VpdGU6IDAsXFxuICAnZXJyb3IgdGl0bGUnOiAwLFxcbiAgJ2Vycm9yIG1lc3NhZ2UnOiAzMSxcXG4gICdlcnJvciBzdGFjayc6IDkwLFxcbiAgY2hlY2ttYXJrOiAzMixcXG4gIGZhc3Q6IDkwLFxcbiAgbWVkaXVtOiAzMyxcXG4gIHNsb3c6IDMxLFxcbiAgZ3JlZW46IDMyLFxcbiAgbGlnaHQ6IDkwLFxcbiAgJ2RpZmYgZ3V0dGVyJzogOTAsXFxuICAnZGlmZiBhZGRlZCc6IDMyLFxcbiAgJ2RpZmYgcmVtb3ZlZCc6IDMxXFxufTtcXG5cXG4vKipcXG4gKiBEZWZhdWx0IHN5bWJvbCBtYXAuXFxuICovXFxuXFxuZXhwb3J0cy5zeW1ib2xzID0ge1xcbiAgb2s6ICfinJMnLFxcbiAgZXJyOiAn4pyWJyxcXG4gIGRvdDogJ+KApCcsXFxuICBjb21tYTogJywnLFxcbiAgYmFuZzogJyEnXFxufTtcXG5cXG4vLyBXaXRoIG5vZGUuanMgb24gV2luZG93czogdXNlIHN5bWJvbHMgYXZhaWxhYmxlIGluIHRlcm1pbmFsIGRlZmF1bHQgZm9udHNcXG5pZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xcbiAgZXhwb3J0cy5zeW1ib2xzLm9rID0gJ1xcXFx1MjIxQSc7XFxuICBleHBvcnRzLnN5bWJvbHMuZXJyID0gJ1xcXFx1MDBENyc7XFxuICBleHBvcnRzLnN5bWJvbHMuZG90ID0gJy4nO1xcbn1cXG5cXG4vKipcXG4gKiBDb2xvciBgc3RyYCB3aXRoIHRoZSBnaXZlbiBgdHlwZWAsXFxuICogYWxsb3dpbmcgY29sb3JzIHRvIGJlIGRpc2FibGVkLFxcbiAqIGFzIHdlbGwgYXMgdXNlci1kZWZpbmVkIGNvbG9yXFxuICogc2NoZW1lcy5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG52YXIgY29sb3IgPSBleHBvcnRzLmNvbG9yID0gZnVuY3Rpb24gKHR5cGUsIHN0cikge1xcbiAgaWYgKCFleHBvcnRzLnVzZUNvbG9ycykge1xcbiAgICByZXR1cm4gU3RyaW5nKHN0cik7XFxuICB9XFxuICByZXR1cm4gJ1xcXFx1MDAxYlsnICsgZXhwb3J0cy5jb2xvcnNbdHlwZV0gKyAnbScgKyBzdHIgKyAnXFxcXHUwMDFiWzBtJztcXG59O1xcblxcbi8qKlxcbiAqIEV4cG9zZSB0ZXJtIHdpbmRvdyBzaXplLCB3aXRoIHNvbWUgZGVmYXVsdHMgZm9yIHdoZW4gc3RkZXJyIGlzIG5vdCBhIHR0eS5cXG4gKi9cXG5cXG5leHBvcnRzLndpbmRvdyA9IHtcXG4gIHdpZHRoOiA3NVxcbn07XFxuXFxuaWYgKGlzYXR0eSkge1xcbiAgZXhwb3J0cy53aW5kb3cud2lkdGggPSBwcm9jZXNzLnN0ZG91dC5nZXRXaW5kb3dTaXplXFxuICAgID8gcHJvY2Vzcy5zdGRvdXQuZ2V0V2luZG93U2l6ZSgxKVswXVxcbiAgICA6IHR0eS5nZXRXaW5kb3dTaXplKClbMV07XFxufVxcblxcbi8qKlxcbiAqIEV4cG9zZSBzb21lIGJhc2ljIGN1cnNvciBpbnRlcmFjdGlvbnMgdGhhdCBhcmUgY29tbW9uIGFtb25nIHJlcG9ydGVycy5cXG4gKi9cXG5cXG5leHBvcnRzLmN1cnNvciA9IHtcXG4gIGhpZGU6IGZ1bmN0aW9uICgpIHtcXG4gICAgaXNhdHR5ICYmIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcdTAwMWJbPzI1bCcpO1xcbiAgfSxcXG5cXG4gIHNob3c6IGZ1bmN0aW9uICgpIHtcXG4gICAgaXNhdHR5ICYmIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcdTAwMWJbPzI1aCcpO1xcbiAgfSxcXG5cXG4gIGRlbGV0ZUxpbmU6IGZ1bmN0aW9uICgpIHtcXG4gICAgaXNhdHR5ICYmIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcdTAwMWJbMksnKTtcXG4gIH0sXFxuXFxuICBiZWdpbm5pbmdPZkxpbmU6IGZ1bmN0aW9uICgpIHtcXG4gICAgaXNhdHR5ICYmIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcdTAwMWJbMEcnKTtcXG4gIH0sXFxuXFxuICBDUjogZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoaXNhdHR5KSB7XFxuICAgICAgZXhwb3J0cy5jdXJzb3IuZGVsZXRlTGluZSgpO1xcbiAgICAgIGV4cG9ydHMuY3Vyc29yLmJlZ2lubmluZ09mTGluZSgpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxccicpO1xcbiAgICB9XFxuICB9XFxufTtcXG5cXG5mdW5jdGlvbiBzaG93RGlmZiAoZXJyKSB7XFxuICByZXR1cm4gZXJyICYmIGVyci5zaG93RGlmZiAhPT0gZmFsc2UgJiYgc2FtZVR5cGUoZXJyLmFjdHVhbCwgZXJyLmV4cGVjdGVkKSAmJiBlcnIuZXhwZWN0ZWQgIT09IHVuZGVmaW5lZDtcXG59XFxuXFxuZnVuY3Rpb24gc3RyaW5naWZ5RGlmZk9ianMgKGVycikge1xcbiAgaWYgKCF1dGlscy5pc1N0cmluZyhlcnIuYWN0dWFsKSB8fCAhdXRpbHMuaXNTdHJpbmcoZXJyLmV4cGVjdGVkKSkge1xcbiAgICBlcnIuYWN0dWFsID0gdXRpbHMuc3RyaW5naWZ5KGVyci5hY3R1YWwpO1xcbiAgICBlcnIuZXhwZWN0ZWQgPSB1dGlscy5zdHJpbmdpZnkoZXJyLmV4cGVjdGVkKTtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogUmV0dXJucyBhIGRpZmYgYmV0d2VlbiAyIHN0cmluZ3Mgd2l0aCBjb2xvdXJlZCBBTlNJIG91dHB1dC5cXG4gKlxcbiAqIFRoZSBkaWZmIHdpbGwgYmUgZWl0aGVyIGlubGluZSBvciB1bmlmaWVkIGRlcGVuZGFudCBvbiB0aGUgdmFsdWVcXG4gKiBvZiBgQmFzZS5pbmxpbmVEaWZmYC5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3R1YWxcXG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IERpZmZcXG4gKi9cXG52YXIgZ2VuZXJhdGVEaWZmID0gZXhwb3J0cy5nZW5lcmF0ZURpZmYgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCkge1xcbiAgcmV0dXJuIGV4cG9ydHMuaW5saW5lRGlmZnNcXG4gICAgPyBpbmxpbmVEaWZmKGFjdHVhbCwgZXhwZWN0ZWQpXFxuICAgIDogdW5pZmllZERpZmYoYWN0dWFsLCBleHBlY3RlZCk7XFxufTtcXG5cXG4vKipcXG4gKiBPdXRwdXQgdGhlIGdpdmVuIGBmYWlsdXJlc2AgYXMgYSBsaXN0LlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnMuQmFzZVxcbiAqIEB2YXJpYXRpb24gMVxcbiAqIEBwYXJhbSB7QXJyYXl9IGZhaWx1cmVzXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5cXG5leHBvcnRzLmxpc3QgPSBmdW5jdGlvbiAoZmFpbHVyZXMpIHtcXG4gIGNvbnNvbGUubG9nKCk7XFxuICBmYWlsdXJlcy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXN0LCBpKSB7XFxuICAgIC8vIGZvcm1hdFxcbiAgICB2YXIgZm10ID0gY29sb3IoJ2Vycm9yIHRpdGxlJywgJyAgJXMpICVzOlxcXFxuJykgK1xcbiAgICAgIGNvbG9yKCdlcnJvciBtZXNzYWdlJywgJyAgICAgJXMnKSArXFxuICAgICAgY29sb3IoJ2Vycm9yIHN0YWNrJywgJ1xcXFxuJXNcXFxcbicpO1xcblxcbiAgICAvLyBtc2dcXG4gICAgdmFyIG1zZztcXG4gICAgdmFyIGVyciA9IHRlc3QuZXJyO1xcbiAgICB2YXIgbWVzc2FnZTtcXG4gICAgaWYgKGVyci5tZXNzYWdlICYmIHR5cGVvZiBlcnIubWVzc2FnZS50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIG1lc3NhZ2UgPSBlcnIubWVzc2FnZSArICcnO1xcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlcnIuaW5zcGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIG1lc3NhZ2UgPSBlcnIuaW5zcGVjdCgpICsgJyc7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbWVzc2FnZSA9ICcnO1xcbiAgICB9XFxuICAgIHZhciBzdGFjayA9IGVyci5zdGFjayB8fCBtZXNzYWdlO1xcbiAgICB2YXIgaW5kZXggPSBtZXNzYWdlID8gc3RhY2suaW5kZXhPZihtZXNzYWdlKSA6IC0xO1xcblxcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XFxuICAgICAgbXNnID0gbWVzc2FnZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpbmRleCArPSBtZXNzYWdlLmxlbmd0aDtcXG4gICAgICBtc2cgPSBzdGFjay5zbGljZSgwLCBpbmRleCk7XFxuICAgICAgLy8gcmVtb3ZlIG1zZyBmcm9tIHN0YWNrXFxuICAgICAgc3RhY2sgPSBzdGFjay5zbGljZShpbmRleCArIDEpO1xcbiAgICB9XFxuXFxuICAgIC8vIHVuY2F1Z2h0XFxuICAgIGlmIChlcnIudW5jYXVnaHQpIHtcXG4gICAgICBtc2cgPSAnVW5jYXVnaHQgJyArIG1zZztcXG4gICAgfVxcbiAgICAvLyBleHBsaWNpdGx5IHNob3cgZGlmZlxcbiAgICBpZiAoIWV4cG9ydHMuaGlkZURpZmYgJiYgc2hvd0RpZmYoZXJyKSkge1xcbiAgICAgIHN0cmluZ2lmeURpZmZPYmpzKGVycik7XFxuICAgICAgZm10ID0gY29sb3IoJ2Vycm9yIHRpdGxlJywgJyAgJXMpICVzOlxcXFxuJXMnKSArIGNvbG9yKCdlcnJvciBzdGFjaycsICdcXFxcbiVzXFxcXG4nKTtcXG4gICAgICB2YXIgbWF0Y2ggPSBtZXNzYWdlLm1hdGNoKC9eKFteOl0rKTogZXhwZWN0ZWQvKTtcXG4gICAgICBtc2cgPSAnXFxcXG4gICAgICAnICsgY29sb3IoJ2Vycm9yIG1lc3NhZ2UnLCBtYXRjaCA/IG1hdGNoWzFdIDogbXNnKTtcXG5cXG4gICAgICBtc2cgKz0gZ2VuZXJhdGVEaWZmKGVyci5hY3R1YWwsIGVyci5leHBlY3RlZCk7XFxuICAgIH1cXG5cXG4gICAgLy8gaW5kZW50IHN0YWNrIHRyYWNlXFxuICAgIHN0YWNrID0gc3RhY2sucmVwbGFjZSgvXi9nbSwgJyAgJyk7XFxuXFxuICAgIC8vIGluZGVudGVkIHRlc3QgdGl0bGVcXG4gICAgdmFyIHRlc3RUaXRsZSA9ICcnO1xcbiAgICB0ZXN0LnRpdGxlUGF0aCgpLmZvckVhY2goZnVuY3Rpb24gKHN0ciwgaW5kZXgpIHtcXG4gICAgICBpZiAoaW5kZXggIT09IDApIHtcXG4gICAgICAgIHRlc3RUaXRsZSArPSAnXFxcXG4gICAgICc7XFxuICAgICAgfVxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xcbiAgICAgICAgdGVzdFRpdGxlICs9ICcgICc7XFxuICAgICAgfVxcbiAgICAgIHRlc3RUaXRsZSArPSBzdHI7XFxuICAgIH0pO1xcblxcbiAgICBjb25zb2xlLmxvZyhmbXQsIChpICsgMSksIHRlc3RUaXRsZSwgbXNnLCBzdGFjayk7XFxuICB9KTtcXG59O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYEJhc2VgIHJlcG9ydGVyLlxcbiAqXFxuICogQWxsIG90aGVyIHJlcG9ydGVycyBnZW5lcmFsbHlcXG4gKiBpbmhlcml0IGZyb20gdGhpcyByZXBvcnRlciwgcHJvdmlkaW5nXFxuICogc3RhdHMgc3VjaCBhcyB0ZXN0IGR1cmF0aW9uLCBudW1iZXJcXG4gKiBvZiB0ZXN0cyBwYXNzZWQgLyBmYWlsZWQgZXRjLlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3NcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5cXG5mdW5jdGlvbiBCYXNlIChydW5uZXIpIHtcXG4gIHZhciBzdGF0cyA9IHRoaXMuc3RhdHMgPSB7IHN1aXRlczogMCwgdGVzdHM6IDAsIHBhc3NlczogMCwgcGVuZGluZzogMCwgZmFpbHVyZXM6IDAgfTtcXG4gIHZhciBmYWlsdXJlcyA9IHRoaXMuZmFpbHVyZXMgPSBbXTtcXG5cXG4gIGlmICghcnVubmVyKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIHRoaXMucnVubmVyID0gcnVubmVyO1xcblxcbiAgcnVubmVyLnN0YXRzID0gc3RhdHM7XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xcbiAgICBzdGF0cy5zdGFydCA9IG5ldyBEYXRlKCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignc3VpdGUnLCBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gICAgc3RhdHMuc3VpdGVzID0gc3RhdHMuc3VpdGVzIHx8IDA7XFxuICAgIHN1aXRlLnJvb3QgfHwgc3RhdHMuc3VpdGVzKys7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigndGVzdCBlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHN0YXRzLnRlc3RzID0gc3RhdHMudGVzdHMgfHwgMDtcXG4gICAgc3RhdHMudGVzdHMrKztcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgc3RhdHMucGFzc2VzID0gc3RhdHMucGFzc2VzIHx8IDA7XFxuXFxuICAgIGlmICh0ZXN0LmR1cmF0aW9uID4gdGVzdC5zbG93KCkpIHtcXG4gICAgICB0ZXN0LnNwZWVkID0gJ3Nsb3cnO1xcbiAgICB9IGVsc2UgaWYgKHRlc3QuZHVyYXRpb24gPiB0ZXN0LnNsb3coKSAvIDIpIHtcXG4gICAgICB0ZXN0LnNwZWVkID0gJ21lZGl1bSc7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGVzdC5zcGVlZCA9ICdmYXN0JztcXG4gICAgfVxcblxcbiAgICBzdGF0cy5wYXNzZXMrKztcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24gKHRlc3QsIGVycikge1xcbiAgICBzdGF0cy5mYWlsdXJlcyA9IHN0YXRzLmZhaWx1cmVzIHx8IDA7XFxuICAgIHN0YXRzLmZhaWx1cmVzKys7XFxuICAgIGlmIChzaG93RGlmZihlcnIpKSB7XFxuICAgICAgc3RyaW5naWZ5RGlmZk9ianMoZXJyKTtcXG4gICAgfVxcbiAgICB0ZXN0LmVyciA9IGVycjtcXG4gICAgZmFpbHVyZXMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgc3RhdHMuZW5kID0gbmV3IERhdGUoKTtcXG4gICAgc3RhdHMuZHVyYXRpb24gPSBzdGF0cy5lbmQgLSBzdGF0cy5zdGFydDtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24gKCkge1xcbiAgICBzdGF0cy5wZW5kaW5nKys7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogT3V0cHV0IGNvbW1vbiBlcGlsb2d1ZSB1c2VkIGJ5IG1hbnkgb2ZcXG4gKiB0aGUgYnVuZGxlZCByZXBvcnRlcnMuXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzLkJhc2VcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5CYXNlLnByb3RvdHlwZS5lcGlsb2d1ZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XFxuICB2YXIgZm10O1xcblxcbiAgY29uc29sZS5sb2coKTtcXG5cXG4gIC8vIHBhc3Nlc1xcbiAgZm10ID0gY29sb3IoJ2JyaWdodCBwYXNzJywgJyAnKSArXFxuICAgIGNvbG9yKCdncmVlbicsICcgJWQgcGFzc2luZycpICtcXG4gICAgY29sb3IoJ2xpZ2h0JywgJyAoJXMpJyk7XFxuXFxuICBjb25zb2xlLmxvZyhmbXQsXFxuICAgIHN0YXRzLnBhc3NlcyB8fCAwLFxcbiAgICBtcyhzdGF0cy5kdXJhdGlvbikpO1xcblxcbiAgLy8gcGVuZGluZ1xcbiAgaWYgKHN0YXRzLnBlbmRpbmcpIHtcXG4gICAgZm10ID0gY29sb3IoJ3BlbmRpbmcnLCAnICcpICtcXG4gICAgICBjb2xvcigncGVuZGluZycsICcgJWQgcGVuZGluZycpO1xcblxcbiAgICBjb25zb2xlLmxvZyhmbXQsIHN0YXRzLnBlbmRpbmcpO1xcbiAgfVxcblxcbiAgLy8gZmFpbHVyZXNcXG4gIGlmIChzdGF0cy5mYWlsdXJlcykge1xcbiAgICBmbXQgPSBjb2xvcignZmFpbCcsICcgICVkIGZhaWxpbmcnKTtcXG5cXG4gICAgY29uc29sZS5sb2coZm10LCBzdGF0cy5mYWlsdXJlcyk7XFxuXFxuICAgIEJhc2UubGlzdCh0aGlzLmZhaWx1cmVzKTtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gIH1cXG5cXG4gIGNvbnNvbGUubG9nKCk7XFxufTtcXG5cXG4vKipcXG4gKiBQYWQgdGhlIGdpdmVuIGBzdHJgIHRvIGBsZW5gLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxcbiAqIEBwYXJhbSB7c3RyaW5nfSBsZW5cXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gcGFkIChzdHIsIGxlbikge1xcbiAgc3RyID0gU3RyaW5nKHN0cik7XFxuICByZXR1cm4gQXJyYXkobGVuIC0gc3RyLmxlbmd0aCArIDEpLmpvaW4oJyAnKSArIHN0cjtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJucyBhbiBpbmxpbmUgZGlmZiBiZXR3ZWVuIDIgc3RyaW5ncyB3aXRoIGNvbG91cmVkIEFOU0kgb3V0cHV0LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtTdHJpbmd9IGFjdHVhbFxcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBlY3RlZFxcbiAqIEByZXR1cm4ge3N0cmluZ30gRGlmZlxcbiAqL1xcbmZ1bmN0aW9uIGlubGluZURpZmYgKGFjdHVhbCwgZXhwZWN0ZWQpIHtcXG4gIHZhciBtc2cgPSBlcnJvckRpZmYoYWN0dWFsLCBleHBlY3RlZCk7XFxuXFxuICAvLyBsaW5lbm9zXFxuICB2YXIgbGluZXMgPSBtc2cuc3BsaXQoJ1xcXFxuJyk7XFxuICBpZiAobGluZXMubGVuZ3RoID4gNCkge1xcbiAgICB2YXIgd2lkdGggPSBTdHJpbmcobGluZXMubGVuZ3RoKS5sZW5ndGg7XFxuICAgIG1zZyA9IGxpbmVzLm1hcChmdW5jdGlvbiAoc3RyLCBpKSB7XFxuICAgICAgcmV0dXJuIHBhZCgrK2ksIHdpZHRoKSArICcgfCcgKyAnICcgKyBzdHI7XFxuICAgIH0pLmpvaW4oJ1xcXFxuJyk7XFxuICB9XFxuXFxuICAvLyBsZWdlbmRcXG4gIG1zZyA9ICdcXFxcbicgK1xcbiAgICBjb2xvcignZGlmZiByZW1vdmVkJywgJ2FjdHVhbCcpICtcXG4gICAgJyAnICtcXG4gICAgY29sb3IoJ2RpZmYgYWRkZWQnLCAnZXhwZWN0ZWQnKSArXFxuICAgICdcXFxcblxcXFxuJyArXFxuICAgIG1zZyArXFxuICAgICdcXFxcbic7XFxuXFxuICAvLyBpbmRlbnRcXG4gIG1zZyA9IG1zZy5yZXBsYWNlKC9eL2dtLCAnICAgICAgJyk7XFxuICByZXR1cm4gbXNnO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIGEgdW5pZmllZCBkaWZmIGJldHdlZW4gdHdvIHN0cmluZ3Mgd2l0aCBjb2xvdXJlZCBBTlNJIG91dHB1dC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3R1YWxcXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwZWN0ZWRcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBkaWZmLlxcbiAqL1xcbmZ1bmN0aW9uIHVuaWZpZWREaWZmIChhY3R1YWwsIGV4cGVjdGVkKSB7XFxuICB2YXIgaW5kZW50ID0gJyAgICAgICc7XFxuICBmdW5jdGlvbiBjbGVhblVwIChsaW5lKSB7XFxuICAgIGlmIChsaW5lWzBdID09PSAnKycpIHtcXG4gICAgICByZXR1cm4gaW5kZW50ICsgY29sb3JMaW5lcygnZGlmZiBhZGRlZCcsIGxpbmUpO1xcbiAgICB9XFxuICAgIGlmIChsaW5lWzBdID09PSAnLScpIHtcXG4gICAgICByZXR1cm4gaW5kZW50ICsgY29sb3JMaW5lcygnZGlmZiByZW1vdmVkJywgbGluZSk7XFxuICAgIH1cXG4gICAgaWYgKGxpbmUubWF0Y2goL0BALykpIHtcXG4gICAgICByZXR1cm4gJy0tJztcXG4gICAgfVxcbiAgICBpZiAobGluZS5tYXRjaCgvXFxcXFxcXFwgTm8gbmV3bGluZS8pKSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gICAgcmV0dXJuIGluZGVudCArIGxpbmU7XFxuICB9XFxuICBmdW5jdGlvbiBub3RCbGFuayAobGluZSkge1xcbiAgICByZXR1cm4gdHlwZW9mIGxpbmUgIT09ICd1bmRlZmluZWQnICYmIGxpbmUgIT09IG51bGw7XFxuICB9XFxuICB2YXIgbXNnID0gZGlmZi5jcmVhdGVQYXRjaCgnc3RyaW5nJywgYWN0dWFsLCBleHBlY3RlZCk7XFxuICB2YXIgbGluZXMgPSBtc2cuc3BsaXQoJ1xcXFxuJykuc3BsaWNlKDUpO1xcbiAgcmV0dXJuICdcXFxcbiAgICAgICcgK1xcbiAgICBjb2xvckxpbmVzKCdkaWZmIGFkZGVkJywgJysgZXhwZWN0ZWQnKSArICcgJyArXFxuICAgIGNvbG9yTGluZXMoJ2RpZmYgcmVtb3ZlZCcsICctIGFjdHVhbCcpICtcXG4gICAgJ1xcXFxuXFxcXG4nICtcXG4gICAgbGluZXMubWFwKGNsZWFuVXApLmZpbHRlcihub3RCbGFuaykuam9pbignXFxcXG4nKTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgY2hhcmFjdGVyIGRpZmYgZm9yIGBlcnJgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtTdHJpbmd9IGFjdHVhbFxcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBlY3RlZFxcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGRpZmZcXG4gKi9cXG5mdW5jdGlvbiBlcnJvckRpZmYgKGFjdHVhbCwgZXhwZWN0ZWQpIHtcXG4gIHJldHVybiBkaWZmLmRpZmZXb3Jkc1dpdGhTcGFjZShhY3R1YWwsIGV4cGVjdGVkKS5tYXAoZnVuY3Rpb24gKHN0cikge1xcbiAgICBpZiAoc3RyLmFkZGVkKSB7XFxuICAgICAgcmV0dXJuIGNvbG9yTGluZXMoJ2RpZmYgYWRkZWQnLCBzdHIudmFsdWUpO1xcbiAgICB9XFxuICAgIGlmIChzdHIucmVtb3ZlZCkge1xcbiAgICAgIHJldHVybiBjb2xvckxpbmVzKCdkaWZmIHJlbW92ZWQnLCBzdHIudmFsdWUpO1xcbiAgICB9XFxuICAgIHJldHVybiBzdHIudmFsdWU7XFxuICB9KS5qb2luKCcnKTtcXG59XFxuXFxuLyoqXFxuICogQ29sb3IgbGluZXMgZm9yIGBzdHJgLCB1c2luZyB0aGUgY29sb3IgYG5hbWVgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIGNvbG9yTGluZXMgKG5hbWUsIHN0cikge1xcbiAgcmV0dXJuIHN0ci5zcGxpdCgnXFxcXG4nKS5tYXAoZnVuY3Rpb24gKHN0cikge1xcbiAgICByZXR1cm4gY29sb3IobmFtZSwgc3RyKTtcXG4gIH0pLmpvaW4oJ1xcXFxuJyk7XFxufVxcblxcbi8qKlxcbiAqIE9iamVjdCN0b1N0cmluZyByZWZlcmVuY2UuXFxuICovXFxudmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcXG5cXG4vKipcXG4gKiBDaGVjayB0aGF0IGEgLyBiIGhhdmUgdGhlIHNhbWUgdHlwZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXFxuICogQHBhcmFtIHtPYmplY3R9IGJcXG4gKiBAcmV0dXJuIHtib29sZWFufVxcbiAqL1xcbmZ1bmN0aW9uIHNhbWVUeXBlIChhLCBiKSB7XFxuICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbChhKSA9PT0gb2JqVG9TdHJpbmcuY2FsbChiKTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi4vbXNcXFwiOjE0LFxcXCIuLi91dGlsc1xcXCI6MzYsXFxcIl9wcm9jZXNzXFxcIjo1NixcXFwiZGlmZlxcXCI6NDUsXFxcInN1cHBvcnRzLWNvbG9yXFxcIjo0MCxcXFwidHR5XFxcIjo0fV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIERvY1xcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgRG9jYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBEb2M7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRG9jYCByZXBvcnRlci5cXG4gKlxcbiAqIEBjbGFzc1xcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcXG4gKiBAZXh0ZW5kcyB7QmFzZX1cXG4gKiBAcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuZnVuY3Rpb24gRG9jIChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIGluZGVudHMgPSAyO1xcblxcbiAgZnVuY3Rpb24gaW5kZW50ICgpIHtcXG4gICAgcmV0dXJuIEFycmF5KGluZGVudHMpLmpvaW4oJyAgJyk7XFxuICB9XFxuXFxuICBydW5uZXIub24oJ3N1aXRlJywgZnVuY3Rpb24gKHN1aXRlKSB7XFxuICAgIGlmIChzdWl0ZS5yb290KSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgICsraW5kZW50cztcXG4gICAgY29uc29sZS5sb2coJyVzPHNlY3Rpb24gY2xhc3M9XFxcInN1aXRlXFxcIj4nLCBpbmRlbnQoKSk7XFxuICAgICsraW5kZW50cztcXG4gICAgY29uc29sZS5sb2coJyVzPGgxPiVzPC9oMT4nLCBpbmRlbnQoKSwgdXRpbHMuZXNjYXBlKHN1aXRlLnRpdGxlKSk7XFxuICAgIGNvbnNvbGUubG9nKCclczxkbD4nLCBpbmRlbnQoKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignc3VpdGUgZW5kJywgZnVuY3Rpb24gKHN1aXRlKSB7XFxuICAgIGlmIChzdWl0ZS5yb290KSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGNvbnNvbGUubG9nKCclczwvZGw+JywgaW5kZW50KCkpO1xcbiAgICAtLWluZGVudHM7XFxuICAgIGNvbnNvbGUubG9nKCclczwvc2VjdGlvbj4nLCBpbmRlbnQoKSk7XFxuICAgIC0taW5kZW50cztcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgY29uc29sZS5sb2coJyVzICA8ZHQ+JXM8L2R0PicsIGluZGVudCgpLCB1dGlscy5lc2NhcGUodGVzdC50aXRsZSkpO1xcbiAgICB2YXIgY29kZSA9IHV0aWxzLmVzY2FwZSh1dGlscy5jbGVhbih0ZXN0LmJvZHkpKTtcXG4gICAgY29uc29sZS5sb2coJyVzICA8ZGQ+PHByZT48Y29kZT4lczwvY29kZT48L3ByZT48L2RkPicsIGluZGVudCgpLCBjb2RlKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24gKHRlc3QsIGVycikge1xcbiAgICBjb25zb2xlLmxvZygnJXMgIDxkdCBjbGFzcz1cXFwiZXJyb3JcXFwiPiVzPC9kdD4nLCBpbmRlbnQoKSwgdXRpbHMuZXNjYXBlKHRlc3QudGl0bGUpKTtcXG4gICAgdmFyIGNvZGUgPSB1dGlscy5lc2NhcGUodXRpbHMuY2xlYW4odGVzdC5ib2R5KSk7XFxuICAgIGNvbnNvbGUubG9nKCclcyAgPGRkIGNsYXNzPVxcXCJlcnJvclxcXCI+PHByZT48Y29kZT4lczwvY29kZT48L3ByZT48L2RkPicsIGluZGVudCgpLCBjb2RlKTtcXG4gICAgY29uc29sZS5sb2coJyVzICA8ZGQgY2xhc3M9XFxcImVycm9yXFxcIj4lczwvZGQ+JywgaW5kZW50KCksIHV0aWxzLmVzY2FwZShlcnIpKTtcXG4gIH0pO1xcbn1cXG5cXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM2LFxcXCIuL2Jhc2VcXFwiOjE2fV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgRG90XFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuaW5oZXJpdHM7XFxudmFyIGNvbG9yID0gQmFzZS5jb2xvcjtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYERvdGAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRG90O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYERvdGAgbWF0cml4IHRlc3QgcmVwb3J0ZXIuXFxuICpcXG4gKiBAY2xhc3NcXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXFxuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gRG90IChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHdpZHRoID0gQmFzZS53aW5kb3cud2lkdGggKiAwLjc1IHwgMDtcXG4gIHZhciBuID0gLTE7XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXG4nKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoKytuICUgd2lkdGggPT09IDApIHtcXG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXG4gICcpO1xcbiAgICB9XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdwZW5kaW5nJywgQmFzZS5zeW1ib2xzLmNvbW1hKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIGlmICgrK24gJSB3aWR0aCA9PT0gMCkge1xcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcbiAgJyk7XFxuICAgIH1cXG4gICAgaWYgKHRlc3Quc3BlZWQgPT09ICdzbG93Jykge1xcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdicmlnaHQgeWVsbG93JywgQmFzZS5zeW1ib2xzLmRvdCkpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKHRlc3Quc3BlZWQsIEJhc2Uuc3ltYm9scy5kb3QpKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICgrK24gJSB3aWR0aCA9PT0gMCkge1xcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcbiAgJyk7XFxuICAgIH1cXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ2ZhaWwnLCBCYXNlLnN5bWJvbHMuYmFuZykpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub25jZSgnZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBjb25zb2xlLmxvZygpO1xcbiAgICBzZWxmLmVwaWxvZ3VlKCk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoRG90LCBCYXNlKTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM2LFxcXCIuL2Jhc2VcXFwiOjE2LFxcXCJfcHJvY2Vzc1xcXCI6NTZ9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChnbG9iYWwpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cXG4vKipcXG4gKiBAbW9kdWxlIEhUTUxcXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcXG52YXIgUHJvZ3Jlc3MgPSByZXF1aXJlKCcuLi9icm93c2VyL3Byb2dyZXNzJyk7XFxudmFyIGVzY2FwZVJlID0gcmVxdWlyZSgnZXNjYXBlLXN0cmluZy1yZWdleHAnKTtcXG52YXIgZXNjYXBlID0gdXRpbHMuZXNjYXBlO1xcblxcbi8qKlxcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZyAoc2VlIEdILTIzNykuXFxuICovXFxuXFxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIG5vLW5hdGl2ZS1yZWFzc2lnbiAqL1xcbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XFxudmFyIHNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcXG52YXIgc2V0SW50ZXJ2YWwgPSBnbG9iYWwuc2V0SW50ZXJ2YWw7XFxudmFyIGNsZWFyVGltZW91dCA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XFxudmFyIGNsZWFySW50ZXJ2YWwgPSBnbG9iYWwuY2xlYXJJbnRlcnZhbDtcXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG5cXG4vKipcXG4gKiBFeHBvc2UgYEhUTUxgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEhUTUw7XFxuXFxuLyoqXFxuICogU3RhdHMgdGVtcGxhdGUuXFxuICovXFxuXFxudmFyIHN0YXRzVGVtcGxhdGUgPSAnPHVsIGlkPVxcXCJtb2NoYS1zdGF0c1xcXCI+JyArXFxuICAnPGxpIGNsYXNzPVxcXCJwcm9ncmVzc1xcXCI+PGNhbnZhcyB3aWR0aD1cXFwiNDBcXFwiIGhlaWdodD1cXFwiNDBcXFwiPjwvY2FudmFzPjwvbGk+JyArXFxuICAnPGxpIGNsYXNzPVxcXCJwYXNzZXNcXFwiPjxhIGhyZWY9XFxcImphdmFzY3JpcHQ6dm9pZCgwKTtcXFwiPnBhc3Nlczo8L2E+IDxlbT4wPC9lbT48L2xpPicgK1xcbiAgJzxsaSBjbGFzcz1cXFwiZmFpbHVyZXNcXFwiPjxhIGhyZWY9XFxcImphdmFzY3JpcHQ6dm9pZCgwKTtcXFwiPmZhaWx1cmVzOjwvYT4gPGVtPjA8L2VtPjwvbGk+JyArXFxuICAnPGxpIGNsYXNzPVxcXCJkdXJhdGlvblxcXCI+ZHVyYXRpb246IDxlbT4wPC9lbT5zPC9saT4nICtcXG4gICc8L3VsPic7XFxuXFxudmFyIHBsYXlJY29uID0gJyYjeDIwMjM7JztcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBIVE1MYCByZXBvcnRlci5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3NcXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXFxuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBIVE1MIChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcXG4gIHZhciBzdGF0ID0gZnJhZ21lbnQoc3RhdHNUZW1wbGF0ZSk7XFxuICB2YXIgaXRlbXMgPSBzdGF0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaScpO1xcbiAgdmFyIHBhc3NlcyA9IGl0ZW1zWzFdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdlbScpWzBdO1xcbiAgdmFyIHBhc3Nlc0xpbmsgPSBpdGVtc1sxXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpWzBdO1xcbiAgdmFyIGZhaWx1cmVzID0gaXRlbXNbMl0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2VtJylbMF07XFxuICB2YXIgZmFpbHVyZXNMaW5rID0gaXRlbXNbMl0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2EnKVswXTtcXG4gIHZhciBkdXJhdGlvbiA9IGl0ZW1zWzNdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdlbScpWzBdO1xcbiAgdmFyIGNhbnZhcyA9IHN0YXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2NhbnZhcycpWzBdO1xcbiAgdmFyIHJlcG9ydCA9IGZyYWdtZW50KCc8dWwgaWQ9XFxcIm1vY2hhLXJlcG9ydFxcXCI+PC91bD4nKTtcXG4gIHZhciBzdGFjayA9IFtyZXBvcnRdO1xcbiAgdmFyIHByb2dyZXNzO1xcbiAgdmFyIGN0eDtcXG4gIHZhciByb290ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vY2hhJyk7XFxuXFxuICBpZiAoY2FudmFzLmdldENvbnRleHQpIHtcXG4gICAgdmFyIHJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcXG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gY2FudmFzLndpZHRoO1xcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcXG4gICAgY2FudmFzLndpZHRoICo9IHJhdGlvO1xcbiAgICBjYW52YXMuaGVpZ2h0ICo9IHJhdGlvO1xcbiAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcXG4gICAgY3R4LnNjYWxlKHJhdGlvLCByYXRpbyk7XFxuICAgIHByb2dyZXNzID0gbmV3IFByb2dyZXNzKCk7XFxuICB9XFxuXFxuICBpZiAoIXJvb3QpIHtcXG4gICAgcmV0dXJuIGVycm9yKCcjbW9jaGEgZGl2IG1pc3NpbmcsIGFkZCBpdCB0byB5b3VyIGRvY3VtZW50Jyk7XFxuICB9XFxuXFxuICAvLyBwYXNzIHRvZ2dsZVxcbiAgb24ocGFzc2VzTGluaywgJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgdW5oaWRlKCk7XFxuICAgIHZhciBuYW1lID0gKC9wYXNzLykudGVzdChyZXBvcnQuY2xhc3NOYW1lKSA/ICcnIDogJyBwYXNzJztcXG4gICAgcmVwb3J0LmNsYXNzTmFtZSA9IHJlcG9ydC5jbGFzc05hbWUucmVwbGFjZSgvZmFpbHxwYXNzL2csICcnKSArIG5hbWU7XFxuICAgIGlmIChyZXBvcnQuY2xhc3NOYW1lLnRyaW0oKSkge1xcbiAgICAgIGhpZGVTdWl0ZXNXaXRob3V0KCd0ZXN0IHBhc3MnKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyBmYWlsdXJlIHRvZ2dsZVxcbiAgb24oZmFpbHVyZXNMaW5rLCAnY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICB1bmhpZGUoKTtcXG4gICAgdmFyIG5hbWUgPSAoL2ZhaWwvKS50ZXN0KHJlcG9ydC5jbGFzc05hbWUpID8gJycgOiAnIGZhaWwnO1xcbiAgICByZXBvcnQuY2xhc3NOYW1lID0gcmVwb3J0LmNsYXNzTmFtZS5yZXBsYWNlKC9mYWlsfHBhc3MvZywgJycpICsgbmFtZTtcXG4gICAgaWYgKHJlcG9ydC5jbGFzc05hbWUudHJpbSgpKSB7XFxuICAgICAgaGlkZVN1aXRlc1dpdGhvdXQoJ3Rlc3QgZmFpbCcpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJvb3QuYXBwZW5kQ2hpbGQoc3RhdCk7XFxuICByb290LmFwcGVuZENoaWxkKHJlcG9ydCk7XFxuXFxuICBpZiAocHJvZ3Jlc3MpIHtcXG4gICAgcHJvZ3Jlc3Muc2l6ZSg0MCk7XFxuICB9XFxuXFxuICBydW5uZXIub24oJ3N1aXRlJywgZnVuY3Rpb24gKHN1aXRlKSB7XFxuICAgIGlmIChzdWl0ZS5yb290KSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIC8vIHN1aXRlXFxuICAgIHZhciB1cmwgPSBzZWxmLnN1aXRlVVJMKHN1aXRlKTtcXG4gICAgdmFyIGVsID0gZnJhZ21lbnQoJzxsaSBjbGFzcz1cXFwic3VpdGVcXFwiPjxoMT48YSBocmVmPVxcXCIlc1xcXCI+JXM8L2E+PC9oMT48L2xpPicsIHVybCwgZXNjYXBlKHN1aXRlLnRpdGxlKSk7XFxuXFxuICAgIC8vIGNvbnRhaW5lclxcbiAgICBzdGFja1swXS5hcHBlbmRDaGlsZChlbCk7XFxuICAgIHN0YWNrLnVuc2hpZnQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKSk7XFxuICAgIGVsLmFwcGVuZENoaWxkKHN0YWNrWzBdKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdzdWl0ZSBlbmQnLCBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gICAgaWYgKHN1aXRlLnJvb3QpIHtcXG4gICAgICB1cGRhdGVTdGF0cygpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBzdGFjay5zaGlmdCgpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICB2YXIgdXJsID0gc2VsZi50ZXN0VVJMKHRlc3QpO1xcbiAgICB2YXIgbWFya3VwID0gJzxsaSBjbGFzcz1cXFwidGVzdCBwYXNzICVlXFxcIj48aDI+JWU8c3BhbiBjbGFzcz1cXFwiZHVyYXRpb25cXFwiPiVlbXM8L3NwYW4+ICcgK1xcbiAgICAgICc8YSBocmVmPVxcXCIlc1xcXCIgY2xhc3M9XFxcInJlcGxheVxcXCI+JyArIHBsYXlJY29uICsgJzwvYT48L2gyPjwvbGk+JztcXG4gICAgdmFyIGVsID0gZnJhZ21lbnQobWFya3VwLCB0ZXN0LnNwZWVkLCB0ZXN0LnRpdGxlLCB0ZXN0LmR1cmF0aW9uLCB1cmwpO1xcbiAgICBzZWxmLmFkZENvZGVUb2dnbGUoZWwsIHRlc3QuYm9keSk7XFxuICAgIGFwcGVuZFRvU3RhY2soZWwpO1xcbiAgICB1cGRhdGVTdGF0cygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICB2YXIgZWwgPSBmcmFnbWVudCgnPGxpIGNsYXNzPVxcXCJ0ZXN0IGZhaWxcXFwiPjxoMj4lZSA8YSBocmVmPVxcXCIlZVxcXCIgY2xhc3M9XFxcInJlcGxheVxcXCI+JyArIHBsYXlJY29uICsgJzwvYT48L2gyPjwvbGk+JyxcXG4gICAgICB0ZXN0LnRpdGxlLCBzZWxmLnRlc3RVUkwodGVzdCkpO1xcbiAgICB2YXIgc3RhY2tTdHJpbmc7IC8vIE5vdGU6IEluY2x1ZGVzIGxlYWRpbmcgbmV3bGluZVxcbiAgICB2YXIgbWVzc2FnZSA9IHRlc3QuZXJyLnRvU3RyaW5nKCk7XFxuXFxuICAgIC8vIDw9SUU3IHN0cmluZ2lmaWVzIHRvIFtPYmplY3QgRXJyb3JdLiBTaW5jZSBpdCBjYW4gYmUgb3ZlcmxvYWRlZCwgd2VcXG4gICAgLy8gY2hlY2sgZm9yIHRoZSByZXN1bHQgb2YgdGhlIHN0cmluZ2lmeWluZy5cXG4gICAgaWYgKG1lc3NhZ2UgPT09ICdbb2JqZWN0IEVycm9yXScpIHtcXG4gICAgICBtZXNzYWdlID0gdGVzdC5lcnIubWVzc2FnZTtcXG4gICAgfVxcblxcbiAgICBpZiAodGVzdC5lcnIuc3RhY2spIHtcXG4gICAgICB2YXIgaW5kZXhPZk1lc3NhZ2UgPSB0ZXN0LmVyci5zdGFjay5pbmRleE9mKHRlc3QuZXJyLm1lc3NhZ2UpO1xcbiAgICAgIGlmIChpbmRleE9mTWVzc2FnZSA9PT0gLTEpIHtcXG4gICAgICAgIHN0YWNrU3RyaW5nID0gdGVzdC5lcnIuc3RhY2s7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHN0YWNrU3RyaW5nID0gdGVzdC5lcnIuc3RhY2suc3Vic3RyKHRlc3QuZXJyLm1lc3NhZ2UubGVuZ3RoICsgaW5kZXhPZk1lc3NhZ2UpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmICh0ZXN0LmVyci5zb3VyY2VVUkwgJiYgdGVzdC5lcnIubGluZSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgLy8gU2FmYXJpIGRvZXNuJ3QgZ2l2ZSB5b3UgYSBzdGFjay4gTGV0J3MgYXQgbGVhc3QgcHJvdmlkZSBhIHNvdXJjZSBsaW5lLlxcbiAgICAgIHN0YWNrU3RyaW5nID0gJ1xcXFxuKCcgKyB0ZXN0LmVyci5zb3VyY2VVUkwgKyAnOicgKyB0ZXN0LmVyci5saW5lICsgJyknO1xcbiAgICB9XFxuXFxuICAgIHN0YWNrU3RyaW5nID0gc3RhY2tTdHJpbmcgfHwgJyc7XFxuXFxuICAgIGlmICh0ZXN0LmVyci5odG1sTWVzc2FnZSAmJiBzdGFja1N0cmluZykge1xcbiAgICAgIGVsLmFwcGVuZENoaWxkKGZyYWdtZW50KCc8ZGl2IGNsYXNzPVxcXCJodG1sLWVycm9yXFxcIj4lc1xcXFxuPHByZSBjbGFzcz1cXFwiZXJyb3JcXFwiPiVlPC9wcmU+PC9kaXY+JyxcXG4gICAgICAgIHRlc3QuZXJyLmh0bWxNZXNzYWdlLCBzdGFja1N0cmluZykpO1xcbiAgICB9IGVsc2UgaWYgKHRlc3QuZXJyLmh0bWxNZXNzYWdlKSB7XFxuICAgICAgZWwuYXBwZW5kQ2hpbGQoZnJhZ21lbnQoJzxkaXYgY2xhc3M9XFxcImh0bWwtZXJyb3JcXFwiPiVzPC9kaXY+JywgdGVzdC5lcnIuaHRtbE1lc3NhZ2UpKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBlbC5hcHBlbmRDaGlsZChmcmFnbWVudCgnPHByZSBjbGFzcz1cXFwiZXJyb3JcXFwiPiVlJWU8L3ByZT4nLCBtZXNzYWdlLCBzdGFja1N0cmluZykpO1xcbiAgICB9XFxuXFxuICAgIHNlbGYuYWRkQ29kZVRvZ2dsZShlbCwgdGVzdC5ib2R5KTtcXG4gICAgYXBwZW5kVG9TdGFjayhlbCk7XFxuICAgIHVwZGF0ZVN0YXRzKCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHZhciBlbCA9IGZyYWdtZW50KCc8bGkgY2xhc3M9XFxcInRlc3QgcGFzcyBwZW5kaW5nXFxcIj48aDI+JWU8L2gyPjwvbGk+JywgdGVzdC50aXRsZSk7XFxuICAgIGFwcGVuZFRvU3RhY2soZWwpO1xcbiAgICB1cGRhdGVTdGF0cygpO1xcbiAgfSk7XFxuXFxuICBmdW5jdGlvbiBhcHBlbmRUb1N0YWNrIChlbCkge1xcbiAgICAvLyBEb24ndCBjYWxsIC5hcHBlbmRDaGlsZCBpZiAjbW9jaGEtcmVwb3J0IHdhcyBhbHJlYWR5IC5zaGlmdCgpJ2VkIG9mZiB0aGUgc3RhY2suXFxuICAgIGlmIChzdGFja1swXSkge1xcbiAgICAgIHN0YWNrWzBdLmFwcGVuZENoaWxkKGVsKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gdXBkYXRlU3RhdHMgKCkge1xcbiAgICAvLyBUT0RPOiBhZGQgdG8gc3RhdHNcXG4gICAgdmFyIHBlcmNlbnQgPSBzdGF0cy50ZXN0cyAvIHJ1bm5lci50b3RhbCAqIDEwMCB8IDA7XFxuICAgIGlmIChwcm9ncmVzcykge1xcbiAgICAgIHByb2dyZXNzLnVwZGF0ZShwZXJjZW50KS5kcmF3KGN0eCk7XFxuICAgIH1cXG5cXG4gICAgLy8gdXBkYXRlIHN0YXRzXFxuICAgIHZhciBtcyA9IG5ldyBEYXRlKCkgLSBzdGF0cy5zdGFydDtcXG4gICAgdGV4dChwYXNzZXMsIHN0YXRzLnBhc3Nlcyk7XFxuICAgIHRleHQoZmFpbHVyZXMsIHN0YXRzLmZhaWx1cmVzKTtcXG4gICAgdGV4dChkdXJhdGlvbiwgKG1zIC8gMTAwMCkudG9GaXhlZCgyKSk7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIE1ha2VzIGEgVVJMLCBwcmVzZXJ2aW5nIHF1ZXJ5c3RyaW5nIChcXFwic2VhcmNoXFxcIikgcGFyYW1ldGVycy5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXFxuICogQHJldHVybiB7c3RyaW5nfSBBIG5ldyBVUkwuXFxuICovXFxuZnVuY3Rpb24gbWFrZVVybCAocykge1xcbiAgdmFyIHNlYXJjaCA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7XFxuXFxuICAvLyBSZW1vdmUgcHJldmlvdXMgZ3JlcCBxdWVyeSBwYXJhbWV0ZXIgaWYgcHJlc2VudFxcbiAgaWYgKHNlYXJjaCkge1xcbiAgICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgvWz8mXWdyZXA9W14mXFxcXHNdKi9nLCAnJykucmVwbGFjZSgvXiYvLCAnPycpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIChzZWFyY2ggPyBzZWFyY2ggKyAnJicgOiAnPycpICsgJ2dyZXA9JyArIGVuY29kZVVSSUNvbXBvbmVudChlc2NhcGVSZShzKSk7XFxufVxcblxcbi8qKlxcbiAqIFByb3ZpZGUgc3VpdGUgVVJMLlxcbiAqXFxuICogQHBhcmFtIHtPYmplY3R9IFtzdWl0ZV1cXG4gKi9cXG5IVE1MLnByb3RvdHlwZS5zdWl0ZVVSTCA9IGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgcmV0dXJuIG1ha2VVcmwoc3VpdGUuZnVsbFRpdGxlKCkpO1xcbn07XFxuXFxuLyoqXFxuICogUHJvdmlkZSB0ZXN0IFVSTC5cXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbdGVzdF1cXG4gKi9cXG5IVE1MLnByb3RvdHlwZS50ZXN0VVJMID0gZnVuY3Rpb24gKHRlc3QpIHtcXG4gIHJldHVybiBtYWtlVXJsKHRlc3QuZnVsbFRpdGxlKCkpO1xcbn07XFxuXFxuLyoqXFxuICogQWRkcyBjb2RlIHRvZ2dsZSBmdW5jdGlvbmFsaXR5IGZvciB0aGUgcHJvdmlkZWQgdGVzdCdzIGxpc3QgZWxlbWVudC5cXG4gKlxcbiAqIEBwYXJhbSB7SFRNTExJRWxlbWVudH0gZWxcXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudHNcXG4gKi9cXG5IVE1MLnByb3RvdHlwZS5hZGRDb2RlVG9nZ2xlID0gZnVuY3Rpb24gKGVsLCBjb250ZW50cykge1xcbiAgdmFyIGgyID0gZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2gyJylbMF07XFxuXFxuICBvbihoMiwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xcbiAgICBwcmUuc3R5bGUuZGlzcGxheSA9IHByZS5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnYmxvY2snIDogJ25vbmUnO1xcbiAgfSk7XFxuXFxuICB2YXIgcHJlID0gZnJhZ21lbnQoJzxwcmU+PGNvZGU+JWU8L2NvZGU+PC9wcmU+JywgdXRpbHMuY2xlYW4oY29udGVudHMpKTtcXG4gIGVsLmFwcGVuZENoaWxkKHByZSk7XFxuICBwcmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcXG59O1xcblxcbi8qKlxcbiAqIERpc3BsYXkgZXJyb3IgYG1zZ2AuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gbXNnXFxuICovXFxuZnVuY3Rpb24gZXJyb3IgKG1zZykge1xcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmcmFnbWVudCgnPGRpdiBpZD1cXFwibW9jaGEtZXJyb3JcXFwiPiVzPC9kaXY+JywgbXNnKSk7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybiBhIERPTSBmcmFnbWVudCBmcm9tIGBodG1sYC5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXFxuICovXFxuZnVuY3Rpb24gZnJhZ21lbnQgKGh0bWwpIHtcXG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xcbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xcbiAgdmFyIGkgPSAxO1xcblxcbiAgZGl2LmlubmVySFRNTCA9IGh0bWwucmVwbGFjZSgvJShbc2VdKS9nLCBmdW5jdGlvbiAoXywgdHlwZSkge1xcbiAgICBzd2l0Y2ggKHR5cGUpIHtcXG4gICAgICBjYXNlICdzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xcbiAgICAgIGNhc2UgJ2UnOiByZXR1cm4gZXNjYXBlKGFyZ3NbaSsrXSk7XFxuICAgICAgLy8gbm8gZGVmYXVsdFxcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJldHVybiBkaXYuZmlyc3RDaGlsZDtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2sgZm9yIHN1aXRlcyB0aGF0IGRvIG5vdCBoYXZlIGVsZW1lbnRzXFxuICogd2l0aCBgY2xhc3NuYW1lYCwgYW5kIGhpZGUgdGhlbS5cXG4gKlxcbiAqIEBwYXJhbSB7dGV4dH0gY2xhc3NuYW1lXFxuICovXFxuZnVuY3Rpb24gaGlkZVN1aXRlc1dpdGhvdXQgKGNsYXNzbmFtZSkge1xcbiAgdmFyIHN1aXRlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3N1aXRlJyk7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1aXRlcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgZWxzID0gc3VpdGVzW2ldLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NuYW1lKTtcXG4gICAgaWYgKCFlbHMubGVuZ3RoKSB7XFxuICAgICAgc3VpdGVzW2ldLmNsYXNzTmFtZSArPSAnIGhpZGRlbic7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLyoqXFxuICogVW5oaWRlIC5oaWRkZW4gc3VpdGVzLlxcbiAqL1xcbmZ1bmN0aW9uIHVuaGlkZSAoKSB7XFxuICB2YXIgZWxzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc3VpdGUgaGlkZGVuJyk7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVscy5sZW5ndGg7ICsraSkge1xcbiAgICBlbHNbaV0uY2xhc3NOYW1lID0gZWxzW2ldLmNsYXNzTmFtZS5yZXBsYWNlKCdzdWl0ZSBoaWRkZW4nLCAnc3VpdGUnKTtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogU2V0IGFuIGVsZW1lbnQncyB0ZXh0IGNvbnRlbnRzLlxcbiAqXFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudHNcXG4gKi9cXG5mdW5jdGlvbiB0ZXh0IChlbCwgY29udGVudHMpIHtcXG4gIGlmIChlbC50ZXh0Q29udGVudCkge1xcbiAgICBlbC50ZXh0Q29udGVudCA9IGNvbnRlbnRzO1xcbiAgfSBlbHNlIHtcXG4gICAgZWwuaW5uZXJUZXh0ID0gY29udGVudHM7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIExpc3RlbiBvbiBgZXZlbnRgIHdpdGggY2FsbGJhY2sgYGZuYC5cXG4gKi9cXG5mdW5jdGlvbiBvbiAoZWwsIGV2ZW50LCBmbikge1xcbiAgaWYgKGVsLmFkZEV2ZW50TGlzdGVuZXIpIHtcXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZm4sIGZhbHNlKTtcXG4gIH0gZWxzZSB7XFxuICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgZm4pO1xcbiAgfVxcbn1cXG5cXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi4vYnJvd3Nlci9wcm9ncmVzc1xcXCI6MyxcXFwiLi4vdXRpbHNcXFwiOjM2LFxcXCIuL2Jhc2VcXFwiOjE2LFxcXCJlc2NhcGUtc3RyaW5nLXJlZ2V4cFxcXCI6NDZ9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8vIEFsaWFzIGV4cG9ydHMgdG8gYSB0aGVpciBub3JtYWxpemVkIGZvcm1hdCBNb2NoYSNyZXBvcnRlciB0byBwcmV2ZW50IGEgbmVlZFxcbi8vIGZvciBkeW5hbWljICh0cnkvY2F0Y2gpIHJlcXVpcmVzLCB3aGljaCBCcm93c2VyaWZ5IGRvZXNuJ3QgaGFuZGxlLlxcbmV4cG9ydHMuQmFzZSA9IGV4cG9ydHMuYmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbmV4cG9ydHMuRG90ID0gZXhwb3J0cy5kb3QgPSByZXF1aXJlKCcuL2RvdCcpO1xcbmV4cG9ydHMuRG9jID0gZXhwb3J0cy5kb2MgPSByZXF1aXJlKCcuL2RvYycpO1xcbmV4cG9ydHMuVEFQID0gZXhwb3J0cy50YXAgPSByZXF1aXJlKCcuL3RhcCcpO1xcbmV4cG9ydHMuSlNPTiA9IGV4cG9ydHMuanNvbiA9IHJlcXVpcmUoJy4vanNvbicpO1xcbmV4cG9ydHMuSFRNTCA9IGV4cG9ydHMuaHRtbCA9IHJlcXVpcmUoJy4vaHRtbCcpO1xcbmV4cG9ydHMuTGlzdCA9IGV4cG9ydHMubGlzdCA9IHJlcXVpcmUoJy4vbGlzdCcpO1xcbmV4cG9ydHMuTWluID0gZXhwb3J0cy5taW4gPSByZXF1aXJlKCcuL21pbicpO1xcbmV4cG9ydHMuU3BlYyA9IGV4cG9ydHMuc3BlYyA9IHJlcXVpcmUoJy4vc3BlYycpO1xcbmV4cG9ydHMuTnlhbiA9IGV4cG9ydHMubnlhbiA9IHJlcXVpcmUoJy4vbnlhbicpO1xcbmV4cG9ydHMuWFVuaXQgPSBleHBvcnRzLnh1bml0ID0gcmVxdWlyZSgnLi94dW5pdCcpO1xcbmV4cG9ydHMuTWFya2Rvd24gPSBleHBvcnRzLm1hcmtkb3duID0gcmVxdWlyZSgnLi9tYXJrZG93bicpO1xcbmV4cG9ydHMuUHJvZ3Jlc3MgPSBleHBvcnRzLnByb2dyZXNzID0gcmVxdWlyZSgnLi9wcm9ncmVzcycpO1xcbmV4cG9ydHMuTGFuZGluZyA9IGV4cG9ydHMubGFuZGluZyA9IHJlcXVpcmUoJy4vbGFuZGluZycpO1xcbmV4cG9ydHMuSlNPTlN0cmVhbSA9IGV4cG9ydHNbJ2pzb24tc3RyZWFtJ10gPSByZXF1aXJlKCcuL2pzb24tc3RyZWFtJyk7XFxuXFxufSx7XFxcIi4vYmFzZVxcXCI6MTYsXFxcIi4vZG9jXFxcIjoxNyxcXFwiLi9kb3RcXFwiOjE4LFxcXCIuL2h0bWxcXFwiOjE5LFxcXCIuL2pzb25cXFwiOjIyLFxcXCIuL2pzb24tc3RyZWFtXFxcIjoyMSxcXFwiLi9sYW5kaW5nXFxcIjoyMyxcXFwiLi9saXN0XFxcIjoyNCxcXFwiLi9tYXJrZG93blxcXCI6MjUsXFxcIi4vbWluXFxcIjoyNixcXFwiLi9ueWFuXFxcIjoyNyxcXFwiLi9wcm9ncmVzc1xcXCI6MjgsXFxcIi4vc3BlY1xcXCI6MjksXFxcIi4vdGFwXFxcIjozMCxcXFwiLi94dW5pdFxcXCI6MzF9XSwyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBKU09OU3RyZWFtXFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgTGlzdGAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTGlzdDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBKU09OU3RyZWFtYCB0ZXN0IHJlcG9ydGVyLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBuYW1lIEpTT05TdHJlYW1cXG4gKiBAY2xhc3MgSlNPTlN0cmVhbVxcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIExpc3QgKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgdG90YWwgPSBydW5uZXIudG90YWw7XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xcbiAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShbJ3N0YXJ0JywgeyB0b3RhbDogdG90YWwgfV0pKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoWydwYXNzJywgY2xlYW4odGVzdCldKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uICh0ZXN0LCBlcnIpIHtcXG4gICAgdGVzdCA9IGNsZWFuKHRlc3QpO1xcbiAgICB0ZXN0LmVyciA9IGVyci5tZXNzYWdlO1xcbiAgICB0ZXN0LnN0YWNrID0gZXJyLnN0YWNrIHx8IG51bGw7XFxuICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KFsnZmFpbCcsIHRlc3RdKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKEpTT04uc3RyaW5naWZ5KFsnZW5kJywgc2VsZi5zdGF0c10pKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBwbGFpbi1vYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYHRlc3RgXFxuICogZnJlZSBvZiBjeWNsaWMgcHJvcGVydGllcyBldGMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gdGVzdFxcbiAqIEByZXR1cm4ge09iamVjdH1cXG4gKi9cXG5mdW5jdGlvbiBjbGVhbiAodGVzdCkge1xcbiAgcmV0dXJuIHtcXG4gICAgdGl0bGU6IHRlc3QudGl0bGUsXFxuICAgIGZ1bGxUaXRsZTogdGVzdC5mdWxsVGl0bGUoKSxcXG4gICAgZHVyYXRpb246IHRlc3QuZHVyYXRpb24sXFxuICAgIGN1cnJlbnRSZXRyeTogdGVzdC5jdXJyZW50UmV0cnkoKVxcbiAgfTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4vYmFzZVxcXCI6MTYsXFxcIl9wcm9jZXNzXFxcIjo1Nn1dLDIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIEpTT05cXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBKU09OYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBKU09OUmVwb3J0ZXI7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgSlNPTmAgcmVwb3J0ZXIuXFxuICpcXG4gKiBAcHVibGljXFxuICogQGNsYXNzIEpTT05cXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXFxuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBKU09OUmVwb3J0ZXIgKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgdGVzdHMgPSBbXTtcXG4gIHZhciBwZW5kaW5nID0gW107XFxuICB2YXIgZmFpbHVyZXMgPSBbXTtcXG4gIHZhciBwYXNzZXMgPSBbXTtcXG5cXG4gIHJ1bm5lci5vbigndGVzdCBlbmQnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICB0ZXN0cy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBwYXNzZXMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgZmFpbHVyZXMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgcGVuZGluZy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub25jZSgnZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgb2JqID0ge1xcbiAgICAgIHN0YXRzOiBzZWxmLnN0YXRzLFxcbiAgICAgIHRlc3RzOiB0ZXN0cy5tYXAoY2xlYW4pLFxcbiAgICAgIHBlbmRpbmc6IHBlbmRpbmcubWFwKGNsZWFuKSxcXG4gICAgICBmYWlsdXJlczogZmFpbHVyZXMubWFwKGNsZWFuKSxcXG4gICAgICBwYXNzZXM6IHBhc3Nlcy5tYXAoY2xlYW4pXFxuICAgIH07XFxuXFxuICAgIHJ1bm5lci50ZXN0UmVzdWx0cyA9IG9iajtcXG5cXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKSk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgcGxhaW4tb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGB0ZXN0YFxcbiAqIGZyZWUgb2YgY3ljbGljIHByb3BlcnRpZXMgZXRjLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IHRlc3RcXG4gKiBAcmV0dXJuIHtPYmplY3R9XFxuICovXFxuZnVuY3Rpb24gY2xlYW4gKHRlc3QpIHtcXG4gIHZhciBlcnIgPSB0ZXN0LmVyciB8fCB7fTtcXG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xcbiAgICBlcnIgPSBlcnJvckpTT04oZXJyKTtcXG4gIH1cXG5cXG4gIHJldHVybiB7XFxuICAgIHRpdGxlOiB0ZXN0LnRpdGxlLFxcbiAgICBmdWxsVGl0bGU6IHRlc3QuZnVsbFRpdGxlKCksXFxuICAgIGR1cmF0aW9uOiB0ZXN0LmR1cmF0aW9uLFxcbiAgICBjdXJyZW50UmV0cnk6IHRlc3QuY3VycmVudFJldHJ5KCksXFxuICAgIGVycjogY2xlYW5DeWNsZXMoZXJyKVxcbiAgfTtcXG59XFxuXFxuLyoqXFxuICogUmVwbGFjZXMgYW55IGNpcmN1bGFyIHJlZmVyZW5jZXMgaW5zaWRlIGBvYmpgIHdpdGggJ1tvYmplY3QgT2JqZWN0XSdcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcXG4gKiBAcmV0dXJuIHtPYmplY3R9XFxuICovXFxuZnVuY3Rpb24gY2xlYW5DeWNsZXMgKG9iaikge1xcbiAgdmFyIGNhY2hlID0gW107XFxuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmosIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XFxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XFxuICAgICAgaWYgKGNhY2hlLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xcbiAgICAgICAgLy8gSW5zdGVhZCBvZiBnb2luZyBpbiBhIGNpcmNsZSwgd2UnbGwgcHJpbnQgW29iamVjdCBPYmplY3RdXFxuICAgICAgICByZXR1cm4gJycgKyB2YWx1ZTtcXG4gICAgICB9XFxuICAgICAgY2FjaGUucHVzaCh2YWx1ZSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHZhbHVlO1xcbiAgfSkpO1xcbn1cXG5cXG4vKipcXG4gKiBUcmFuc2Zvcm0gYW4gRXJyb3Igb2JqZWN0IGludG8gYSBKU09OIG9iamVjdC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxcbiAqIEByZXR1cm4ge09iamVjdH1cXG4gKi9cXG5mdW5jdGlvbiBlcnJvckpTT04gKGVycikge1xcbiAgdmFyIHJlcyA9IHt9O1xcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZXJyKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgcmVzW2tleV0gPSBlcnJba2V5XTtcXG4gIH0sIGVycik7XFxuICByZXR1cm4gcmVzO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi9iYXNlXFxcIjoxNixcXFwiX3Byb2Nlc3NcXFwiOjU2fV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgTGFuZGluZ1xcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcbnZhciBjdXJzb3IgPSBCYXNlLmN1cnNvcjtcXG52YXIgY29sb3IgPSBCYXNlLmNvbG9yO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgTGFuZGluZ2AuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTGFuZGluZztcXG5cXG4vKipcXG4gKiBBaXJwbGFuZSBjb2xvci5cXG4gKi9cXG5cXG5CYXNlLmNvbG9ycy5wbGFuZSA9IDA7XFxuXFxuLyoqXFxuICogQWlycGxhbmUgY3Jhc2ggY29sb3IuXFxuICovXFxuXFxuQmFzZS5jb2xvcnNbJ3BsYW5lIGNyYXNoJ10gPSAzMTtcXG5cXG4vKipcXG4gKiBSdW53YXkgY29sb3IuXFxuICovXFxuXFxuQmFzZS5jb2xvcnMucnVud2F5ID0gOTA7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgTGFuZGluZ2AgcmVwb3J0ZXIuXFxuICpcXG4gKiBAcHVibGljXFxuICogQGNsYXNzXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gTGFuZGluZyAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB3aWR0aCA9IEJhc2Uud2luZG93LndpZHRoICogMC43NSB8IDA7XFxuICB2YXIgdG90YWwgPSBydW5uZXIudG90YWw7XFxuICB2YXIgc3RyZWFtID0gcHJvY2Vzcy5zdGRvdXQ7XFxuICB2YXIgcGxhbmUgPSBjb2xvcigncGxhbmUnLCAn4pyIJyk7XFxuICB2YXIgY3Jhc2hlZCA9IC0xO1xcbiAgdmFyIG4gPSAwO1xcblxcbiAgZnVuY3Rpb24gcnVud2F5ICgpIHtcXG4gICAgdmFyIGJ1ZiA9IEFycmF5KHdpZHRoKS5qb2luKCctJyk7XFxuICAgIHJldHVybiAnICAnICsgY29sb3IoJ3J1bndheScsIGJ1Zik7XFxuICB9XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xcbiAgICBzdHJlYW0ud3JpdGUoJ1xcXFxuXFxcXG5cXFxcbiAgJyk7XFxuICAgIGN1cnNvci5oaWRlKCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigndGVzdCBlbmQnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICAvLyBjaGVjayBpZiB0aGUgcGxhbmUgY3Jhc2hlZFxcbiAgICB2YXIgY29sID0gY3Jhc2hlZCA9PT0gLTEgPyB3aWR0aCAqICsrbiAvIHRvdGFsIHwgMCA6IGNyYXNoZWQ7XFxuXFxuICAgIC8vIHNob3cgdGhlIGNyYXNoXFxuICAgIGlmICh0ZXN0LnN0YXRlID09PSAnZmFpbGVkJykge1xcbiAgICAgIHBsYW5lID0gY29sb3IoJ3BsYW5lIGNyYXNoJywgJ+KciCcpO1xcbiAgICAgIGNyYXNoZWQgPSBjb2w7XFxuICAgIH1cXG5cXG4gICAgLy8gcmVuZGVyIGxhbmRpbmcgc3RyaXBcXG4gICAgc3RyZWFtLndyaXRlKCdcXFxcdTAwMWJbJyArICh3aWR0aCArIDEpICsgJ0RcXFxcdTAwMWJbMkEnKTtcXG4gICAgc3RyZWFtLndyaXRlKHJ1bndheSgpKTtcXG4gICAgc3RyZWFtLndyaXRlKCdcXFxcbiAgJyk7XFxuICAgIHN0cmVhbS53cml0ZShjb2xvcigncnVud2F5JywgQXJyYXkoY29sKS5qb2luKCfii4UnKSkpO1xcbiAgICBzdHJlYW0ud3JpdGUocGxhbmUpO1xcbiAgICBzdHJlYW0ud3JpdGUoY29sb3IoJ3J1bndheScsIEFycmF5KHdpZHRoIC0gY29sKS5qb2luKCfii4UnKSArICdcXFxcbicpKTtcXG4gICAgc3RyZWFtLndyaXRlKHJ1bndheSgpKTtcXG4gICAgc3RyZWFtLndyaXRlKCdcXFxcdTAwMWJbMG0nKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgY3Vyc29yLnNob3coKTtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gICAgc2VsZi5lcGlsb2d1ZSgpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKExhbmRpbmcsIEJhc2UpO1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzYsXFxcIi4vYmFzZVxcXCI6MTYsXFxcIl9wcm9jZXNzXFxcIjo1Nn1dLDI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIExpc3RcXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG52YXIgY29sb3IgPSBCYXNlLmNvbG9yO1xcbnZhciBjdXJzb3IgPSBCYXNlLmN1cnNvcjtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYExpc3RgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IExpc3Q7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgTGlzdGAgdGVzdCByZXBvcnRlci5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3NcXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXFxuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBMaXN0IChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIG4gPSAwO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCd0ZXN0JywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3Bhc3MnLCAnICAgICcgKyB0ZXN0LmZ1bGxUaXRsZSgpICsgJzogJykpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICB2YXIgZm10ID0gY29sb3IoJ2NoZWNrbWFyaycsICcgIC0nKSArXFxuICAgICAgY29sb3IoJ3BlbmRpbmcnLCAnICVzJyk7XFxuICAgIGNvbnNvbGUubG9nKGZtdCwgdGVzdC5mdWxsVGl0bGUoKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHZhciBmbXQgPSBjb2xvcignY2hlY2ttYXJrJywgJyAgJyArIEJhc2Uuc3ltYm9scy5vaykgK1xcbiAgICAgIGNvbG9yKCdwYXNzJywgJyAlczogJykgK1xcbiAgICAgIGNvbG9yKHRlc3Quc3BlZWQsICclZG1zJyk7XFxuICAgIGN1cnNvci5DUigpO1xcbiAgICBjb25zb2xlLmxvZyhmbXQsIHRlc3QuZnVsbFRpdGxlKCksIHRlc3QuZHVyYXRpb24pO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBjdXJzb3IuQ1IoKTtcXG4gICAgY29uc29sZS5sb2coY29sb3IoJ2ZhaWwnLCAnICAlZCkgJXMnKSwgKytuLCB0ZXN0LmZ1bGxUaXRsZSgpKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uY2UoJ2VuZCcsIHNlbGYuZXBpbG9ndWUuYmluZChzZWxmKSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKExpc3QsIEJhc2UpO1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzYsXFxcIi4vYmFzZVxcXCI6MTYsXFxcIl9wcm9jZXNzXFxcIjo1Nn1dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIE1hcmtkb3duXFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XFxuXFxuLyoqXFxuICogQ29uc3RhbnRzXFxuICovXFxuXFxudmFyIFNVSVRFX1BSRUZJWCA9ICckJztcXG5cXG4vKipcXG4gKiBFeHBvc2UgYE1hcmtkb3duYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBNYXJrZG93bjtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBNYXJrZG93bmAgcmVwb3J0ZXIuXFxuICpcXG4gKiBAcHVibGljXFxuICogQGNsYXNzXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gTWFya2Rvd24gKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgbGV2ZWwgPSAwO1xcbiAgdmFyIGJ1ZiA9ICcnO1xcblxcbiAgZnVuY3Rpb24gdGl0bGUgKHN0cikge1xcbiAgICByZXR1cm4gQXJyYXkobGV2ZWwpLmpvaW4oJyMnKSArICcgJyArIHN0cjtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG1hcFRPQyAoc3VpdGUsIG9iaikge1xcbiAgICB2YXIgcmV0ID0gb2JqO1xcbiAgICB2YXIga2V5ID0gU1VJVEVfUFJFRklYICsgc3VpdGUudGl0bGU7XFxuXFxuICAgIG9iaiA9IG9ialtrZXldID0gb2JqW2tleV0gfHwgeyBzdWl0ZTogc3VpdGUgfTtcXG4gICAgc3VpdGUuc3VpdGVzLmZvckVhY2goZnVuY3Rpb24gKHN1aXRlKSB7XFxuICAgICAgbWFwVE9DKHN1aXRlLCBvYmopO1xcbiAgICB9KTtcXG5cXG4gICAgcmV0dXJuIHJldDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeVRPQyAob2JqLCBsZXZlbCkge1xcbiAgICArK2xldmVsO1xcbiAgICB2YXIgYnVmID0gJyc7XFxuICAgIHZhciBsaW5rO1xcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XFxuICAgICAgaWYgKGtleSA9PT0gJ3N1aXRlJykge1xcbiAgICAgICAgY29udGludWU7XFxuICAgICAgfVxcbiAgICAgIGlmIChrZXkgIT09IFNVSVRFX1BSRUZJWCkge1xcbiAgICAgICAgbGluayA9ICcgLSBbJyArIGtleS5zdWJzdHJpbmcoMSkgKyAnXSc7XFxuICAgICAgICBsaW5rICs9ICcoIycgKyB1dGlscy5zbHVnKG9ialtrZXldLnN1aXRlLmZ1bGxUaXRsZSgpKSArICcpXFxcXG4nO1xcbiAgICAgICAgYnVmICs9IEFycmF5KGxldmVsKS5qb2luKCcgICcpICsgbGluaztcXG4gICAgICB9XFxuICAgICAgYnVmICs9IHN0cmluZ2lmeVRPQyhvYmpba2V5XSwgbGV2ZWwpO1xcbiAgICB9XFxuICAgIHJldHVybiBidWY7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBnZW5lcmF0ZVRPQyAoc3VpdGUpIHtcXG4gICAgdmFyIG9iaiA9IG1hcFRPQyhzdWl0ZSwge30pO1xcbiAgICByZXR1cm4gc3RyaW5naWZ5VE9DKG9iaiwgMCk7XFxuICB9XFxuXFxuICBnZW5lcmF0ZVRPQyhydW5uZXIuc3VpdGUpO1xcblxcbiAgcnVubmVyLm9uKCdzdWl0ZScsIGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgICArK2xldmVsO1xcbiAgICB2YXIgc2x1ZyA9IHV0aWxzLnNsdWcoc3VpdGUuZnVsbFRpdGxlKCkpO1xcbiAgICBidWYgKz0gJzxhIG5hbWU9XFxcIicgKyBzbHVnICsgJ1xcXCI+PC9hPicgKyAnXFxcXG4nO1xcbiAgICBidWYgKz0gdGl0bGUoc3VpdGUudGl0bGUpICsgJ1xcXFxuJztcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdzdWl0ZSBlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIC0tbGV2ZWw7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHZhciBjb2RlID0gdXRpbHMuY2xlYW4odGVzdC5ib2R5KTtcXG4gICAgYnVmICs9IHRlc3QudGl0bGUgKyAnLlxcXFxuJztcXG4gICAgYnVmICs9ICdcXFxcbmBgYGpzXFxcXG4nO1xcbiAgICBidWYgKz0gY29kZSArICdcXFxcbic7XFxuICAgIGJ1ZiArPSAnYGBgXFxcXG5cXFxcbic7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCcjIFRPQ1xcXFxuJyk7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGdlbmVyYXRlVE9DKHJ1bm5lci5zdWl0ZSkpO1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShidWYpO1xcbiAgfSk7XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzYsXFxcIi4vYmFzZVxcXCI6MTYsXFxcIl9wcm9jZXNzXFxcIjo1Nn1dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIE1pblxcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgTWluYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBNaW47XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgTWluYCBtaW5pbWFsIHRlc3QgcmVwb3J0ZXIgKGJlc3QgdXNlZCB3aXRoIC0td2F0Y2gpLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzc1xcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIE1pbiAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIC8vIGNsZWFyIHNjcmVlblxcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXHUwMDFiWzJKJyk7XFxuICAgIC8vIHNldCBjdXJzb3IgcG9zaXRpb25cXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYlsxOzNIJyk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbmNlKCdlbmQnLCB0aGlzLmVwaWxvZ3VlLmJpbmQodGhpcykpO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhNaW4sIEJhc2UpO1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzYsXFxcIi4vYmFzZVxcXCI6MTYsXFxcIl9wcm9jZXNzXFxcIjo1Nn1dLDI3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIE55YW5cXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG5cXG4vKipcXG4gKiBFeHBvc2UgYERvdGAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTnlhbkNhdDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBEb3RgIG1hdHJpeCB0ZXN0IHJlcG9ydGVyLlxcbiAqXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzcyBOeWFuXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICovXFxuXFxuZnVuY3Rpb24gTnlhbkNhdCAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB3aWR0aCA9IEJhc2Uud2luZG93LndpZHRoICogMC43NSB8IDA7XFxuICB2YXIgbnlhbkNhdFdpZHRoID0gdGhpcy5ueWFuQ2F0V2lkdGggPSAxMTtcXG5cXG4gIHRoaXMuY29sb3JJbmRleCA9IDA7XFxuICB0aGlzLm51bWJlck9mTGluZXMgPSA0O1xcbiAgdGhpcy5yYWluYm93Q29sb3JzID0gc2VsZi5nZW5lcmF0ZUNvbG9ycygpO1xcbiAgdGhpcy5zY29yZWJvYXJkV2lkdGggPSA1O1xcbiAgdGhpcy50aWNrID0gMDtcXG4gIHRoaXMudHJhamVjdG9yaWVzID0gW1tdLCBbXSwgW10sIFtdXTtcXG4gIHRoaXMudHJhamVjdG9yeVdpZHRoTWF4ID0gKHdpZHRoIC0gbnlhbkNhdFdpZHRoKTtcXG5cXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIEJhc2UuY3Vyc29yLmhpZGUoKTtcXG4gICAgc2VsZi5kcmF3KCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uICgpIHtcXG4gICAgc2VsZi5kcmF3KCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uICgpIHtcXG4gICAgc2VsZi5kcmF3KCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgc2VsZi5kcmF3KCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIEJhc2UuY3Vyc29yLnNob3coKTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLm51bWJlck9mTGluZXM7IGkrKykge1xcbiAgICAgIHdyaXRlKCdcXFxcbicpO1xcbiAgICB9XFxuICAgIHNlbGYuZXBpbG9ndWUoKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhOeWFuQ2F0LCBCYXNlKTtcXG5cXG4vKipcXG4gKiBEcmF3IHRoZSBueWFuIGNhdFxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMuYXBwZW5kUmFpbmJvdygpO1xcbiAgdGhpcy5kcmF3U2NvcmVib2FyZCgpO1xcbiAgdGhpcy5kcmF3UmFpbmJvdygpO1xcbiAgdGhpcy5kcmF3TnlhbkNhdCgpO1xcbiAgdGhpcy50aWNrID0gIXRoaXMudGljaztcXG59O1xcblxcbi8qKlxcbiAqIERyYXcgdGhlIFxcXCJzY29yZWJvYXJkXFxcIiBzaG93aW5nIHRoZSBudW1iZXJcXG4gKiBvZiBwYXNzZXMsIGZhaWx1cmVzIGFuZCBwZW5kaW5nIHRlc3RzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuZHJhd1Njb3JlYm9hcmQgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xcblxcbiAgZnVuY3Rpb24gZHJhdyAodHlwZSwgbikge1xcbiAgICB3cml0ZSgnICcpO1xcbiAgICB3cml0ZShCYXNlLmNvbG9yKHR5cGUsIG4pKTtcXG4gICAgd3JpdGUoJ1xcXFxuJyk7XFxuICB9XFxuXFxuICBkcmF3KCdncmVlbicsIHN0YXRzLnBhc3Nlcyk7XFxuICBkcmF3KCdmYWlsJywgc3RhdHMuZmFpbHVyZXMpO1xcbiAgZHJhdygncGVuZGluZycsIHN0YXRzLnBlbmRpbmcpO1xcbiAgd3JpdGUoJ1xcXFxuJyk7XFxuXFxuICB0aGlzLmN1cnNvclVwKHRoaXMubnVtYmVyT2ZMaW5lcyk7XFxufTtcXG5cXG4vKipcXG4gKiBBcHBlbmQgdGhlIHJhaW5ib3cuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5OeWFuQ2F0LnByb3RvdHlwZS5hcHBlbmRSYWluYm93ID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHNlZ21lbnQgPSB0aGlzLnRpY2sgPyAnXycgOiAnLSc7XFxuICB2YXIgcmFpbmJvd2lmaWVkID0gdGhpcy5yYWluYm93aWZ5KHNlZ21lbnQpO1xcblxcbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMubnVtYmVyT2ZMaW5lczsgaW5kZXgrKykge1xcbiAgICB2YXIgdHJhamVjdG9yeSA9IHRoaXMudHJhamVjdG9yaWVzW2luZGV4XTtcXG4gICAgaWYgKHRyYWplY3RvcnkubGVuZ3RoID49IHRoaXMudHJhamVjdG9yeVdpZHRoTWF4KSB7XFxuICAgICAgdHJhamVjdG9yeS5zaGlmdCgpO1xcbiAgICB9XFxuICAgIHRyYWplY3RvcnkucHVzaChyYWluYm93aWZpZWQpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogRHJhdyB0aGUgcmFpbmJvdy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbk55YW5DYXQucHJvdG90eXBlLmRyYXdSYWluYm93ID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgdGhpcy50cmFqZWN0b3JpZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xcbiAgICB3cml0ZSgnXFxcXHUwMDFiWycgKyBzZWxmLnNjb3JlYm9hcmRXaWR0aCArICdDJyk7XFxuICAgIHdyaXRlKGxpbmUuam9pbignJykpO1xcbiAgICB3cml0ZSgnXFxcXG4nKTtcXG4gIH0pO1xcblxcbiAgdGhpcy5jdXJzb3JVcCh0aGlzLm51bWJlck9mTGluZXMpO1xcbn07XFxuXFxuLyoqXFxuICogRHJhdyB0aGUgbnlhbiBjYXRcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbk55YW5DYXQucHJvdG90eXBlLmRyYXdOeWFuQ2F0ID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHN0YXJ0V2lkdGggPSB0aGlzLnNjb3JlYm9hcmRXaWR0aCArIHRoaXMudHJhamVjdG9yaWVzWzBdLmxlbmd0aDtcXG4gIHZhciBkaXN0ID0gJ1xcXFx1MDAxYlsnICsgc3RhcnRXaWR0aCArICdDJztcXG4gIHZhciBwYWRkaW5nID0gJyc7XFxuXFxuICB3cml0ZShkaXN0KTtcXG4gIHdyaXRlKCdfLC0tLS0tLSwnKTtcXG4gIHdyaXRlKCdcXFxcbicpO1xcblxcbiAgd3JpdGUoZGlzdCk7XFxuICBwYWRkaW5nID0gc2VsZi50aWNrID8gJyAgJyA6ICcgICAnO1xcbiAgd3JpdGUoJ198JyArIHBhZGRpbmcgKyAnL1xcXFxcXFxcXy9cXFxcXFxcXCAnKTtcXG4gIHdyaXRlKCdcXFxcbicpO1xcblxcbiAgd3JpdGUoZGlzdCk7XFxuICBwYWRkaW5nID0gc2VsZi50aWNrID8gJ18nIDogJ19fJztcXG4gIHZhciB0YWlsID0gc2VsZi50aWNrID8gJ34nIDogJ14nO1xcbiAgd3JpdGUodGFpbCArICd8JyArIHBhZGRpbmcgKyB0aGlzLmZhY2UoKSArICcgJyk7XFxuICB3cml0ZSgnXFxcXG4nKTtcXG5cXG4gIHdyaXRlKGRpc3QpO1xcbiAgcGFkZGluZyA9IHNlbGYudGljayA/ICcgJyA6ICcgICc7XFxuICB3cml0ZShwYWRkaW5nICsgJ1xcXCJcXFwiICBcXFwiXFxcIiAnKTtcXG4gIHdyaXRlKCdcXFxcbicpO1xcblxcbiAgdGhpcy5jdXJzb3JVcCh0aGlzLm51bWJlck9mTGluZXMpO1xcbn07XFxuXFxuLyoqXFxuICogRHJhdyBueWFuIGNhdCBmYWNlLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcblxcbk55YW5DYXQucHJvdG90eXBlLmZhY2UgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xcbiAgaWYgKHN0YXRzLmZhaWx1cmVzKSB7XFxuICAgIHJldHVybiAnKCB4IC54KSc7XFxuICB9IGVsc2UgaWYgKHN0YXRzLnBlbmRpbmcpIHtcXG4gICAgcmV0dXJuICcoIG8gLm8pJztcXG4gIH0gZWxzZSBpZiAoc3RhdHMucGFzc2VzKSB7XFxuICAgIHJldHVybiAnKCBeIC5eKSc7XFxuICB9XFxuICByZXR1cm4gJyggLSAuLSknO1xcbn07XFxuXFxuLyoqXFxuICogTW92ZSBjdXJzb3IgdXAgYG5gLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IG5cXG4gKi9cXG5cXG5OeWFuQ2F0LnByb3RvdHlwZS5jdXJzb3JVcCA9IGZ1bmN0aW9uIChuKSB7XFxuICB3cml0ZSgnXFxcXHUwMDFiWycgKyBuICsgJ0EnKTtcXG59O1xcblxcbi8qKlxcbiAqIE1vdmUgY3Vyc29yIGRvd24gYG5gLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IG5cXG4gKi9cXG5cXG5OeWFuQ2F0LnByb3RvdHlwZS5jdXJzb3JEb3duID0gZnVuY3Rpb24gKG4pIHtcXG4gIHdyaXRlKCdcXFxcdTAwMWJbJyArIG4gKyAnQicpO1xcbn07XFxuXFxuLyoqXFxuICogR2VuZXJhdGUgcmFpbmJvdyBjb2xvcnMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcmV0dXJuIHtBcnJheX1cXG4gKi9cXG5OeWFuQ2F0LnByb3RvdHlwZS5nZW5lcmF0ZUNvbG9ycyA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBjb2xvcnMgPSBbXTtcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgKDYgKiA3KTsgaSsrKSB7XFxuICAgIHZhciBwaTMgPSBNYXRoLmZsb29yKE1hdGguUEkgLyAzKTtcXG4gICAgdmFyIG4gPSAoaSAqICgxLjAgLyA2KSk7XFxuICAgIHZhciByID0gTWF0aC5mbG9vcigzICogTWF0aC5zaW4obikgKyAzKTtcXG4gICAgdmFyIGcgPSBNYXRoLmZsb29yKDMgKiBNYXRoLnNpbihuICsgMiAqIHBpMykgKyAzKTtcXG4gICAgdmFyIGIgPSBNYXRoLmZsb29yKDMgKiBNYXRoLnNpbihuICsgNCAqIHBpMykgKyAzKTtcXG4gICAgY29sb3JzLnB1c2goMzYgKiByICsgNiAqIGcgKyBiICsgMTYpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGNvbG9ycztcXG59O1xcblxcbi8qKlxcbiAqIEFwcGx5IHJhaW5ib3cgdG8gdGhlIGdpdmVuIGBzdHJgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5OeWFuQ2F0LnByb3RvdHlwZS5yYWluYm93aWZ5ID0gZnVuY3Rpb24gKHN0cikge1xcbiAgaWYgKCFCYXNlLnVzZUNvbG9ycykge1xcbiAgICByZXR1cm4gc3RyO1xcbiAgfVxcbiAgdmFyIGNvbG9yID0gdGhpcy5yYWluYm93Q29sb3JzW3RoaXMuY29sb3JJbmRleCAlIHRoaXMucmFpbmJvd0NvbG9ycy5sZW5ndGhdO1xcbiAgdGhpcy5jb2xvckluZGV4ICs9IDE7XFxuICByZXR1cm4gJ1xcXFx1MDAxYlszODs1OycgKyBjb2xvciArICdtJyArIHN0ciArICdcXFxcdTAwMWJbMG0nO1xcbn07XFxuXFxuLyoqXFxuICogU3Rkb3V0IGhlbHBlci5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgQSBtZXNzYWdlIHRvIHdyaXRlIHRvIHN0ZG91dC5cXG4gKi9cXG5mdW5jdGlvbiB3cml0ZSAoc3RyaW5nKSB7XFxuICBwcm9jZXNzLnN0ZG91dC53cml0ZShzdHJpbmcpO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM2LFxcXCIuL2Jhc2VcXFwiOjE2LFxcXCJfcHJvY2Vzc1xcXCI6NTZ9XSwyODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBQcm9ncmVzc1xcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XFxudmFyIGN1cnNvciA9IEJhc2UuY3Vyc29yO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgUHJvZ3Jlc3NgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFByb2dyZXNzO1xcblxcbi8qKlxcbiAqIEdlbmVyYWwgcHJvZ3Jlc3MgYmFyIGNvbG9yLlxcbiAqL1xcblxcbkJhc2UuY29sb3JzLnByb2dyZXNzID0gOTA7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUHJvZ3Jlc3NgIGJhciB0ZXN0IHJlcG9ydGVyLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzc1xcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXFxuICovXFxuZnVuY3Rpb24gUHJvZ3Jlc3MgKHJ1bm5lciwgb3B0aW9ucykge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgd2lkdGggPSBCYXNlLndpbmRvdy53aWR0aCAqIDAuNTAgfCAwO1xcbiAgdmFyIHRvdGFsID0gcnVubmVyLnRvdGFsO1xcbiAgdmFyIGNvbXBsZXRlID0gMDtcXG4gIHZhciBsYXN0TiA9IC0xO1xcblxcbiAgLy8gZGVmYXVsdCBjaGFyc1xcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuICB2YXIgcmVwb3J0ZXJPcHRpb25zID0gb3B0aW9ucy5yZXBvcnRlck9wdGlvbnMgfHwge307XFxuXFxuICBvcHRpb25zLm9wZW4gPSByZXBvcnRlck9wdGlvbnMub3BlbiB8fCAnWyc7XFxuICBvcHRpb25zLmNvbXBsZXRlID0gcmVwb3J0ZXJPcHRpb25zLmNvbXBsZXRlIHx8ICfilqwnO1xcbiAgb3B0aW9ucy5pbmNvbXBsZXRlID0gcmVwb3J0ZXJPcHRpb25zLmluY29tcGxldGUgfHwgQmFzZS5zeW1ib2xzLmRvdDtcXG4gIG9wdGlvbnMuY2xvc2UgPSByZXBvcnRlck9wdGlvbnMuY2xvc2UgfHwgJ10nO1xcbiAgb3B0aW9ucy52ZXJib3NlID0gcmVwb3J0ZXJPcHRpb25zLnZlcmJvc2UgfHwgZmFsc2U7XFxuXFxuICAvLyB0ZXN0cyBzdGFydGVkXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xcbiAgICBjb25zb2xlLmxvZygpO1xcbiAgICBjdXJzb3IuaGlkZSgpO1xcbiAgfSk7XFxuXFxuICAvLyB0ZXN0cyBjb21wbGV0ZVxcbiAgcnVubmVyLm9uKCd0ZXN0IGVuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgY29tcGxldGUrKztcXG5cXG4gICAgdmFyIHBlcmNlbnQgPSBjb21wbGV0ZSAvIHRvdGFsO1xcbiAgICB2YXIgbiA9IHdpZHRoICogcGVyY2VudCB8IDA7XFxuICAgIHZhciBpID0gd2lkdGggLSBuO1xcblxcbiAgICBpZiAobiA9PT0gbGFzdE4gJiYgIW9wdGlvbnMudmVyYm9zZSkge1xcbiAgICAgIC8vIERvbid0IHJlLXJlbmRlciB0aGUgbGluZSBpZiBpdCBoYXNuJ3QgY2hhbmdlZFxcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBsYXN0TiA9IG47XFxuXFxuICAgIGN1cnNvci5DUigpO1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXHUwMDFiW0onKTtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3Byb2dyZXNzJywgJyAgJyArIG9wdGlvbnMub3BlbikpO1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShBcnJheShuKS5qb2luKG9wdGlvbnMuY29tcGxldGUpKTtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoQXJyYXkoaSkuam9pbihvcHRpb25zLmluY29tcGxldGUpKTtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3Byb2dyZXNzJywgb3B0aW9ucy5jbG9zZSkpO1xcbiAgICBpZiAob3B0aW9ucy52ZXJib3NlKSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3Byb2dyZXNzJywgJyAnICsgY29tcGxldGUgKyAnIG9mICcgKyB0b3RhbCkpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIHRlc3RzIGFyZSBjb21wbGV0ZSwgb3V0cHV0IHNvbWUgc3RhdHNcXG4gIC8vIGFuZCB0aGUgZmFpbHVyZXMgaWYgYW55XFxuICBydW5uZXIub25jZSgnZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBjdXJzb3Iuc2hvdygpO1xcbiAgICBjb25zb2xlLmxvZygpO1xcbiAgICBzZWxmLmVwaWxvZ3VlKCk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoUHJvZ3Jlc3MsIEJhc2UpO1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzYsXFxcIi4vYmFzZVxcXCI6MTYsXFxcIl9wcm9jZXNzXFxcIjo1Nn1dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBTcGVjXFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuaW5oZXJpdHM7XFxudmFyIGNvbG9yID0gQmFzZS5jb2xvcjtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFNwZWNgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFNwZWM7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgU3BlY2AgdGVzdCByZXBvcnRlci5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3NcXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXFxuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBTcGVjIChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIGluZGVudHMgPSAwO1xcbiAgdmFyIG4gPSAwO1xcblxcbiAgZnVuY3Rpb24gaW5kZW50ICgpIHtcXG4gICAgcmV0dXJuIEFycmF5KGluZGVudHMpLmpvaW4oJyAgJyk7XFxuICB9XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xcbiAgICBjb25zb2xlLmxvZygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3N1aXRlJywgZnVuY3Rpb24gKHN1aXRlKSB7XFxuICAgICsraW5kZW50cztcXG4gICAgY29uc29sZS5sb2coY29sb3IoJ3N1aXRlJywgJyVzJXMnKSwgaW5kZW50KCksIHN1aXRlLnRpdGxlKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdzdWl0ZSBlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIC0taW5kZW50cztcXG4gICAgaWYgKGluZGVudHMgPT09IDEpIHtcXG4gICAgICBjb25zb2xlLmxvZygpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHZhciBmbXQgPSBpbmRlbnQoKSArIGNvbG9yKCdwZW5kaW5nJywgJyAgLSAlcycpO1xcbiAgICBjb25zb2xlLmxvZyhmbXQsIHRlc3QudGl0bGUpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICB2YXIgZm10O1xcbiAgICBpZiAodGVzdC5zcGVlZCA9PT0gJ2Zhc3QnKSB7XFxuICAgICAgZm10ID0gaW5kZW50KCkgK1xcbiAgICAgICAgY29sb3IoJ2NoZWNrbWFyaycsICcgICcgKyBCYXNlLnN5bWJvbHMub2spICtcXG4gICAgICAgIGNvbG9yKCdwYXNzJywgJyAlcycpO1xcbiAgICAgIGNvbnNvbGUubG9nKGZtdCwgdGVzdC50aXRsZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZm10ID0gaW5kZW50KCkgK1xcbiAgICAgICAgY29sb3IoJ2NoZWNrbWFyaycsICcgICcgKyBCYXNlLnN5bWJvbHMub2spICtcXG4gICAgICAgIGNvbG9yKCdwYXNzJywgJyAlcycpICtcXG4gICAgICAgIGNvbG9yKHRlc3Quc3BlZWQsICcgKCVkbXMpJyk7XFxuICAgICAgY29uc29sZS5sb2coZm10LCB0ZXN0LnRpdGxlLCB0ZXN0LmR1cmF0aW9uKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBjb25zb2xlLmxvZyhpbmRlbnQoKSArIGNvbG9yKCdmYWlsJywgJyAgJWQpICVzJyksICsrbiwgdGVzdC50aXRsZSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbmNlKCdlbmQnLCBzZWxmLmVwaWxvZ3VlLmJpbmQoc2VsZikpO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhTcGVjLCBCYXNlKTtcXG5cXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM2LFxcXCIuL2Jhc2VcXFwiOjE2fV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIFRBUFxcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFRBUGAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gVEFQO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFRBUGAgcmVwb3J0ZXIuXFxuICpcXG4gKiBAcHVibGljXFxuICogQGNsYXNzXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gVEFQIChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIG4gPSAxO1xcbiAgdmFyIHBhc3NlcyA9IDA7XFxuICB2YXIgZmFpbHVyZXMgPSAwO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHRvdGFsID0gcnVubmVyLmdyZXBUb3RhbChydW5uZXIuc3VpdGUpO1xcbiAgICBjb25zb2xlLmxvZygnJWQuLiVkJywgMSwgdG90YWwpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Rlc3QgZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICArK247XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIGNvbnNvbGUubG9nKCdvayAlZCAlcyAjIFNLSVAgLScsIG4sIHRpdGxlKHRlc3QpKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgcGFzc2VzKys7XFxuICAgIGNvbnNvbGUubG9nKCdvayAlZCAlcycsIG4sIHRpdGxlKHRlc3QpKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24gKHRlc3QsIGVycikge1xcbiAgICBmYWlsdXJlcysrO1xcbiAgICBjb25zb2xlLmxvZygnbm90IG9rICVkICVzJywgbiwgdGl0bGUodGVzdCkpO1xcbiAgICBpZiAoZXJyLnN0YWNrKSB7XFxuICAgICAgY29uc29sZS5sb2coZXJyLnN0YWNrLnJlcGxhY2UoL14vZ20sICcgICcpKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICBydW5uZXIub25jZSgnZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBjb25zb2xlLmxvZygnIyB0ZXN0cyAnICsgKHBhc3NlcyArIGZhaWx1cmVzKSk7XFxuICAgIGNvbnNvbGUubG9nKCcjIHBhc3MgJyArIHBhc3Nlcyk7XFxuICAgIGNvbnNvbGUubG9nKCcjIGZhaWwgJyArIGZhaWx1cmVzKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBUQVAtc2FmZSB0aXRsZSBvZiBgdGVzdGBcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSB0ZXN0XFxuICogQHJldHVybiB7U3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIHRpdGxlICh0ZXN0KSB7XFxuICByZXR1cm4gdGVzdC5mdWxsVGl0bGUoKS5yZXBsYWNlKC8jL2csICcnKTtcXG59XFxuXFxufSx7XFxcIi4vYmFzZVxcXCI6MTZ9XSwzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgWFVuaXRcXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcXG52YXIgaW5oZXJpdHMgPSB1dGlscy5pbmhlcml0cztcXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xcbnZhciBlc2NhcGUgPSB1dGlscy5lc2NhcGU7XFxudmFyIG1rZGlycCA9IHJlcXVpcmUoJ21rZGlycCcpO1xcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xcblxcbi8qKlxcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZyAoc2VlIEdILTIzNykuXFxuICovXFxuXFxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIG5vLW5hdGl2ZS1yZWFzc2lnbiAqL1xcbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XFxudmFyIHNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcXG52YXIgc2V0SW50ZXJ2YWwgPSBnbG9iYWwuc2V0SW50ZXJ2YWw7XFxudmFyIGNsZWFyVGltZW91dCA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XFxudmFyIGNsZWFySW50ZXJ2YWwgPSBnbG9iYWwuY2xlYXJJbnRlcnZhbDtcXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG5cXG4vKipcXG4gKiBFeHBvc2UgYFhVbml0YC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBYVW5pdDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBYVW5pdGAgcmVwb3J0ZXIuXFxuICpcXG4gKiBAcHVibGljXFxuICogQGNsYXNzXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gWFVuaXQgKHJ1bm5lciwgb3B0aW9ucykge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xcbiAgdmFyIHRlc3RzID0gW107XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAvLyB0aGUgbmFtZSBvZiB0aGUgdGVzdCBzdWl0ZSwgYXMgaXQgd2lsbCBhcHBlYXIgaW4gdGhlIHJlc3VsdGluZyBYTUwgZmlsZVxcbiAgdmFyIHN1aXRlTmFtZTtcXG5cXG4gIC8vIHRoZSBkZWZhdWx0IG5hbWUgb2YgdGhlIHRlc3Qgc3VpdGUgaWYgbm9uZSBpcyBwcm92aWRlZFxcbiAgdmFyIERFRkFVTFRfU1VJVEVfTkFNRSA9ICdNb2NoYSBUZXN0cyc7XFxuXFxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcG9ydGVyT3B0aW9ucykge1xcbiAgICBpZiAob3B0aW9ucy5yZXBvcnRlck9wdGlvbnMub3V0cHV0KSB7XFxuICAgICAgaWYgKCFmcy5jcmVhdGVXcml0ZVN0cmVhbSkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWxlIG91dHB1dCBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXInKTtcXG4gICAgICB9XFxuXFxuICAgICAgbWtkaXJwLnN5bmMocGF0aC5kaXJuYW1lKG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zLm91dHB1dCkpO1xcbiAgICAgIHNlbGYuZmlsZVN0cmVhbSA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zLm91dHB1dCk7XFxuICAgIH1cXG5cXG4gICAgLy8gZ2V0IHRoZSBzdWl0ZSBuYW1lIGZyb20gdGhlIHJlcG9ydGVyIG9wdGlvbnMgKGlmIHByb3ZpZGVkKVxcbiAgICBzdWl0ZU5hbWUgPSBvcHRpb25zLnJlcG9ydGVyT3B0aW9ucy5zdWl0ZU5hbWU7XFxuICB9XFxuXFxuICAvLyBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgc3VpdGUgbmFtZVxcbiAgc3VpdGVOYW1lID0gc3VpdGVOYW1lIHx8IERFRkFVTFRfU1VJVEVfTkFNRTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHRlc3RzLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHRlc3RzLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHRlc3RzLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHNlbGYud3JpdGUodGFnKCd0ZXN0c3VpdGUnLCB7XFxuICAgICAgbmFtZTogc3VpdGVOYW1lLFxcbiAgICAgIHRlc3RzOiBzdGF0cy50ZXN0cyxcXG4gICAgICBmYWlsdXJlczogc3RhdHMuZmFpbHVyZXMsXFxuICAgICAgZXJyb3JzOiBzdGF0cy5mYWlsdXJlcyxcXG4gICAgICBza2lwcGVkOiBzdGF0cy50ZXN0cyAtIHN0YXRzLmZhaWx1cmVzIC0gc3RhdHMucGFzc2VzLFxcbiAgICAgIHRpbWVzdGFtcDogKG5ldyBEYXRlKCkpLnRvVVRDU3RyaW5nKCksXFxuICAgICAgdGltZTogKHN0YXRzLmR1cmF0aW9uIC8gMTAwMCkgfHwgMFxcbiAgICB9LCBmYWxzZSkpO1xcblxcbiAgICB0ZXN0cy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XFxuICAgICAgc2VsZi50ZXN0KHQpO1xcbiAgICB9KTtcXG5cXG4gICAgc2VsZi53cml0ZSgnPC90ZXN0c3VpdGU+Jyk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoWFVuaXQsIEJhc2UpO1xcblxcbi8qKlxcbiAqIE92ZXJyaWRlIGRvbmUgdG8gY2xvc2UgdGhlIHN0cmVhbSAoaWYgaXQncyBhIGZpbGUpLlxcbiAqXFxuICogQHBhcmFtIGZhaWx1cmVzXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKi9cXG5YVW5pdC5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uIChmYWlsdXJlcywgZm4pIHtcXG4gIGlmICh0aGlzLmZpbGVTdHJlYW0pIHtcXG4gICAgdGhpcy5maWxlU3RyZWFtLmVuZChmdW5jdGlvbiAoKSB7XFxuICAgICAgZm4oZmFpbHVyZXMpO1xcbiAgICB9KTtcXG4gIH0gZWxzZSB7XFxuICAgIGZuKGZhaWx1cmVzKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIFdyaXRlIG91dCB0aGUgZ2l2ZW4gbGluZS5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBsaW5lXFxuICovXFxuWFVuaXQucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGxpbmUpIHtcXG4gIGlmICh0aGlzLmZpbGVTdHJlYW0pIHtcXG4gICAgdGhpcy5maWxlU3RyZWFtLndyaXRlKGxpbmUgKyAnXFxcXG4nKTtcXG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3Muc3Rkb3V0KSB7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGxpbmUgKyAnXFxcXG4nKTtcXG4gIH0gZWxzZSB7XFxuICAgIGNvbnNvbGUubG9nKGxpbmUpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogT3V0cHV0IHRhZyBmb3IgdGhlIGdpdmVuIGB0ZXN0LmBcXG4gKlxcbiAqIEBwYXJhbSB7VGVzdH0gdGVzdFxcbiAqL1xcblhVbml0LnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gKHRlc3QpIHtcXG4gIHZhciBhdHRycyA9IHtcXG4gICAgY2xhc3NuYW1lOiB0ZXN0LnBhcmVudC5mdWxsVGl0bGUoKSxcXG4gICAgbmFtZTogdGVzdC50aXRsZSxcXG4gICAgdGltZTogKHRlc3QuZHVyYXRpb24gLyAxMDAwKSB8fCAwXFxuICB9O1xcblxcbiAgaWYgKHRlc3Quc3RhdGUgPT09ICdmYWlsZWQnKSB7XFxuICAgIHZhciBlcnIgPSB0ZXN0LmVycjtcXG4gICAgdGhpcy53cml0ZSh0YWcoJ3Rlc3RjYXNlJywgYXR0cnMsIGZhbHNlLCB0YWcoJ2ZhaWx1cmUnLCB7fSwgZmFsc2UsIGVzY2FwZShlcnIubWVzc2FnZSkgKyAnXFxcXG4nICsgZXNjYXBlKGVyci5zdGFjaykpKSk7XFxuICB9IGVsc2UgaWYgKHRlc3QuaXNQZW5kaW5nKCkpIHtcXG4gICAgdGhpcy53cml0ZSh0YWcoJ3Rlc3RjYXNlJywgYXR0cnMsIGZhbHNlLCB0YWcoJ3NraXBwZWQnLCB7fSwgdHJ1ZSkpKTtcXG4gIH0gZWxzZSB7XFxuICAgIHRoaXMud3JpdGUodGFnKCd0ZXN0Y2FzZScsIGF0dHJzLCB0cnVlKSk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBIVE1MIHRhZyBoZWxwZXIuXFxuICpcXG4gKiBAcGFyYW0gbmFtZVxcbiAqIEBwYXJhbSBhdHRyc1xcbiAqIEBwYXJhbSBjbG9zZVxcbiAqIEBwYXJhbSBjb250ZW50XFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIHRhZyAobmFtZSwgYXR0cnMsIGNsb3NlLCBjb250ZW50KSB7XFxuICB2YXIgZW5kID0gY2xvc2UgPyAnLz4nIDogJz4nO1xcbiAgdmFyIHBhaXJzID0gW107XFxuICB2YXIgdGFnO1xcblxcbiAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XFxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cnMsIGtleSkpIHtcXG4gICAgICBwYWlycy5wdXNoKGtleSArICc9XFxcIicgKyBlc2NhcGUoYXR0cnNba2V5XSkgKyAnXFxcIicpO1xcbiAgICB9XFxuICB9XFxuXFxuICB0YWcgPSAnPCcgKyBuYW1lICsgKHBhaXJzLmxlbmd0aCA/ICcgJyArIHBhaXJzLmpvaW4oJyAnKSA6ICcnKSArIGVuZDtcXG4gIGlmIChjb250ZW50KSB7XFxuICAgIHRhZyArPSBjb250ZW50ICsgJzwvJyArIG5hbWUgKyBlbmQ7XFxuICB9XFxuICByZXR1cm4gdGFnO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzYsXFxcIi4vYmFzZVxcXCI6MTYsXFxcIl9wcm9jZXNzXFxcIjo1NixcXFwiZnNcXFwiOjQwLFxcXCJta2RpcnBcXFwiOjUzLFxcXCJwYXRoXFxcIjo0MH1dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKGdsb2JhbCl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgUnVubmFibGVcXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XFxudmFyIFBlbmRpbmcgPSByZXF1aXJlKCcuL3BlbmRpbmcnKTtcXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb2NoYTpydW5uYWJsZScpO1xcbnZhciBtaWxsaXNlY29uZHMgPSByZXF1aXJlKCcuL21zJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xcblxcbi8qKlxcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZyAoc2VlIEdILTIzNykuXFxuICovXFxuXFxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIG5vLW5hdGl2ZS1yZWFzc2lnbiAqL1xcbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XFxudmFyIHNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcXG52YXIgc2V0SW50ZXJ2YWwgPSBnbG9iYWwuc2V0SW50ZXJ2YWw7XFxudmFyIGNsZWFyVGltZW91dCA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XFxudmFyIGNsZWFySW50ZXJ2YWwgPSBnbG9iYWwuY2xlYXJJbnRlcnZhbDtcXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG5cXG4vKipcXG4gKiBPYmplY3QjdG9TdHJpbmcoKS5cXG4gKi9cXG5cXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgUnVubmFibGVgLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gUnVubmFibGU7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUnVubmFibGVgIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmAuICBEZXJpdmVkIGZyb20gW0V2ZW50RW1pdHRlcl0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNldmVudHNfY2xhc3NfZXZlbnRlbWl0dGVyKVxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzc1xcbiAqIEBwYXJhbSB7U3RyaW5nfSB0aXRsZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuZnVuY3Rpb24gUnVubmFibGUgKHRpdGxlLCBmbikge1xcbiAgdGhpcy50aXRsZSA9IHRpdGxlO1xcbiAgdGhpcy5mbiA9IGZuO1xcbiAgdGhpcy5ib2R5ID0gKGZuIHx8ICcnKS50b1N0cmluZygpO1xcbiAgdGhpcy5hc3luYyA9IGZuICYmIGZuLmxlbmd0aDtcXG4gIHRoaXMuc3luYyA9ICF0aGlzLmFzeW5jO1xcbiAgdGhpcy5fdGltZW91dCA9IDIwMDA7XFxuICB0aGlzLl9zbG93ID0gNzU7XFxuICB0aGlzLl9lbmFibGVUaW1lb3V0cyA9IHRydWU7XFxuICB0aGlzLnRpbWVkT3V0ID0gZmFsc2U7XFxuICB0aGlzLl9yZXRyaWVzID0gLTE7XFxuICB0aGlzLl9jdXJyZW50UmV0cnkgPSAwO1xcbiAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgRXZlbnRFbWl0dGVyLnByb3RvdHlwZWAuXFxuICovXFxudXRpbHMuaW5oZXJpdHMoUnVubmFibGUsIEV2ZW50RW1pdHRlcik7XFxuXFxuLyoqXFxuICogU2V0ICYgZ2V0IHRpbWVvdXQgYG1zYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbXNcXG4gKiBAcmV0dXJuIHtSdW5uYWJsZXxudW1iZXJ9IG1zIG9yIFJ1bm5hYmxlIGluc3RhbmNlLlxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XFxuICB9XFxuICAvLyBzZWUgIzE2NTIgZm9yIHJlYXNvbmluZ1xcbiAgaWYgKG1zID09PSAwIHx8IG1zID4gTWF0aC5wb3coMiwgMzEpKSB7XFxuICAgIHRoaXMuX2VuYWJsZVRpbWVvdXRzID0gZmFsc2U7XFxuICB9XFxuICBpZiAodHlwZW9mIG1zID09PSAnc3RyaW5nJykge1xcbiAgICBtcyA9IG1pbGxpc2Vjb25kcyhtcyk7XFxuICB9XFxuICBkZWJ1ZygndGltZW91dCAlZCcsIG1zKTtcXG4gIHRoaXMuX3RpbWVvdXQgPSBtcztcXG4gIGlmICh0aGlzLnRpbWVyKSB7XFxuICAgIHRoaXMucmVzZXRUaW1lb3V0KCk7XFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBvciBnZXQgc2xvdyBgbXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBtc1xcbiAqIEByZXR1cm4ge1J1bm5hYmxlfG51bWJlcn0gbXMgb3IgUnVubmFibGUgaW5zdGFuY2UuXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLnNsb3cgPSBmdW5jdGlvbiAobXMpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCB8fCB0eXBlb2YgbXMgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgIHJldHVybiB0aGlzLl9zbG93O1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBtcyA9PT0gJ3N0cmluZycpIHtcXG4gICAgbXMgPSBtaWxsaXNlY29uZHMobXMpO1xcbiAgfVxcbiAgZGVidWcoJ3Nsb3cgJWQnLCBtcyk7XFxuICB0aGlzLl9zbG93ID0gbXM7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBhbmQgZ2V0IHdoZXRoZXIgdGltZW91dCBpcyBgZW5hYmxlZGAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcXG4gKiBAcmV0dXJuIHtSdW5uYWJsZXxib29sZWFufSBlbmFibGVkIG9yIFJ1bm5hYmxlIGluc3RhbmNlLlxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5lbmFibGVUaW1lb3V0cyA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2VuYWJsZVRpbWVvdXRzO1xcbiAgfVxcbiAgZGVidWcoJ2VuYWJsZVRpbWVvdXRzICVzJywgZW5hYmxlZCk7XFxuICB0aGlzLl9lbmFibGVUaW1lb3V0cyA9IGVuYWJsZWQ7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEhhbHQgYW5kIG1hcmsgYXMgcGVuZGluZy5cXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYS5SdW5uYWJsZVxcbiAqIEBwdWJsaWNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gKCkge1xcbiAgdGhyb3cgbmV3IFBlbmRpbmcoJ3N5bmMgc2tpcCcpO1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdGhpcyBydW5uYWJsZSBvciBpdHMgcGFyZW50IHN1aXRlIGlzIG1hcmtlZCBhcyBwZW5kaW5nLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmlzUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiB0aGlzLnBlbmRpbmcgfHwgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmlzUGVuZGluZygpKTtcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhpcyBSdW5uYWJsZSBoYXMgZmFpbGVkLlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XFxuICogQHByaXZhdGVcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuaXNGYWlsZWQgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gIXRoaXMuaXNQZW5kaW5nKCkgJiYgdGhpcy5zdGF0ZSA9PT0gJ2ZhaWxlZCc7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoaXMgUnVubmFibGUgaGFzIHBhc3NlZC5cXG4gKiBAcmV0dXJuIHtib29sZWFufVxcbiAqIEBwcml2YXRlXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmlzUGFzc2VkID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuICF0aGlzLmlzUGVuZGluZygpICYmIHRoaXMuc3RhdGUgPT09ICdwYXNzZWQnO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IG9yIGdldCBudW1iZXIgb2YgcmV0cmllcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5yZXRyaWVzID0gZnVuY3Rpb24gKG4pIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fcmV0cmllcztcXG4gIH1cXG4gIHRoaXMuX3JldHJpZXMgPSBuO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IG9yIGdldCBjdXJyZW50IHJldHJ5XFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuY3VycmVudFJldHJ5ID0gZnVuY3Rpb24gKG4pIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFJldHJ5O1xcbiAgfVxcbiAgdGhpcy5fY3VycmVudFJldHJ5ID0gbjtcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybiB0aGUgZnVsbCB0aXRsZSBnZW5lcmF0ZWQgYnkgcmVjdXJzaXZlbHkgY29uY2F0ZW5hdGluZyB0aGUgcGFyZW50J3NcXG4gKiBmdWxsIHRpdGxlLlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhLlJ1bm5hYmxlXFxuICogQHB1YmxpY1xcbiAqIEBhcGkgcHVibGljXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5mdWxsVGl0bGUgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gdGhpcy50aXRsZVBhdGgoKS5qb2luKCcgJyk7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gdGhlIHRpdGxlIHBhdGggZ2VuZXJhdGVkIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIHBhcmVudCdzIHRpdGxlIHBhdGggd2l0aCB0aGUgdGl0bGUuXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGEuUnVubmFibGVcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLnRpdGxlUGF0aCA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiB0aGlzLnBhcmVudC50aXRsZVBhdGgoKS5jb25jYXQoW3RoaXMudGl0bGVdKTtcXG59O1xcblxcbi8qKlxcbiAqIENsZWFyIHRoZSB0aW1lb3V0LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcXG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcXG59O1xcblxcbi8qKlxcbiAqIEluc3BlY3QgdGhlIHJ1bm5hYmxlIHZvaWQgb2YgcHJpdmF0ZSBwcm9wZXJ0aWVzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xcbiAgICBpZiAoa2V5WzBdID09PSAnXycpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgaWYgKGtleSA9PT0gJ3BhcmVudCcpIHtcXG4gICAgICByZXR1cm4gJyM8U3VpdGU+JztcXG4gICAgfVxcbiAgICBpZiAoa2V5ID09PSAnY3R4Jykge1xcbiAgICAgIHJldHVybiAnIzxDb250ZXh0Pic7XFxuICAgIH1cXG4gICAgcmV0dXJuIHZhbDtcXG4gIH0sIDIpO1xcbn07XFxuXFxuLyoqXFxuICogUmVzZXQgdGhlIHRpbWVvdXQuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUucmVzZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIG1zID0gdGhpcy50aW1lb3V0KCkgfHwgMWU5O1xcblxcbiAgaWYgKCF0aGlzLl9lbmFibGVUaW1lb3V0cykge1xcbiAgICByZXR1cm47XFxuICB9XFxuICB0aGlzLmNsZWFyVGltZW91dCgpO1xcbiAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoIXNlbGYuX2VuYWJsZVRpbWVvdXRzKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHNlbGYuY2FsbGJhY2soc2VsZi5fdGltZW91dEVycm9yKG1zKSk7XFxuICAgIHNlbGYudGltZWRPdXQgPSB0cnVlO1xcbiAgfSwgbXMpO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IG9yIGdldCBhIGxpc3Qgb2Ygd2hpdGVsaXN0ZWQgZ2xvYmFscyBmb3IgdGhpcyB0ZXN0IHJ1bi5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nW119IGdsb2JhbHNcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuZ2xvYmFscyA9IGZ1bmN0aW9uIChnbG9iYWxzKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2FsbG93ZWRHbG9iYWxzO1xcbiAgfVxcbiAgdGhpcy5fYWxsb3dlZEdsb2JhbHMgPSBnbG9iYWxzO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIHRoZSB0ZXN0IGFuZCBpbnZva2UgYGZuKGVycilgLlxcbiAqXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKGZuKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpO1xcbiAgdmFyIGN0eCA9IHRoaXMuY3R4O1xcbiAgdmFyIGZpbmlzaGVkO1xcbiAgdmFyIGVtaXR0ZWQ7XFxuXFxuICAvLyBTb21ldGltZXMgdGhlIGN0eCBleGlzdHMsIGJ1dCBpdCBpcyBub3QgcnVubmFibGVcXG4gIGlmIChjdHggJiYgY3R4LnJ1bm5hYmxlKSB7XFxuICAgIGN0eC5ydW5uYWJsZSh0aGlzKTtcXG4gIH1cXG5cXG4gIC8vIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xcbiAgZnVuY3Rpb24gbXVsdGlwbGUgKGVycikge1xcbiAgICBpZiAoZW1pdHRlZCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBlbWl0dGVkID0gdHJ1ZTtcXG4gICAgdmFyIG1zZyA9ICdkb25lKCkgY2FsbGVkIG11bHRpcGxlIHRpbWVzJztcXG4gICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSkge1xcbiAgICAgIGVyci5tZXNzYWdlICs9IFxcXCIgKGFuZCBNb2NoYSdzIFxcXCIgKyBtc2cgKyAnKSc7XFxuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihtc2cpKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gZmluaXNoZWRcXG4gIGZ1bmN0aW9uIGRvbmUgKGVycikge1xcbiAgICB2YXIgbXMgPSBzZWxmLnRpbWVvdXQoKTtcXG4gICAgaWYgKHNlbGYudGltZWRPdXQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYgKGZpbmlzaGVkKSB7XFxuICAgICAgcmV0dXJuIG11bHRpcGxlKGVycik7XFxuICAgIH1cXG5cXG4gICAgc2VsZi5jbGVhclRpbWVvdXQoKTtcXG4gICAgc2VsZi5kdXJhdGlvbiA9IG5ldyBEYXRlKCkgLSBzdGFydDtcXG4gICAgZmluaXNoZWQgPSB0cnVlO1xcbiAgICBpZiAoIWVyciAmJiBzZWxmLmR1cmF0aW9uID4gbXMgJiYgc2VsZi5fZW5hYmxlVGltZW91dHMpIHtcXG4gICAgICBlcnIgPSBzZWxmLl90aW1lb3V0RXJyb3IobXMpO1xcbiAgICB9XFxuICAgIGZuKGVycik7XFxuICB9XFxuXFxuICAvLyBmb3IgLnJlc2V0VGltZW91dCgpXFxuICB0aGlzLmNhbGxiYWNrID0gZG9uZTtcXG5cXG4gIC8vIGV4cGxpY2l0IGFzeW5jIHdpdGggYGRvbmVgIGFyZ3VtZW50XFxuICBpZiAodGhpcy5hc3luYykge1xcbiAgICB0aGlzLnJlc2V0VGltZW91dCgpO1xcblxcbiAgICAvLyBhbGxvd3Mgc2tpcCgpIHRvIGJlIHVzZWQgaW4gYW4gZXhwbGljaXQgYXN5bmMgY29udGV4dFxcbiAgICB0aGlzLnNraXAgPSBmdW5jdGlvbiBhc3luY1NraXAgKCkge1xcbiAgICAgIGRvbmUobmV3IFBlbmRpbmcoJ2FzeW5jIHNraXAgY2FsbCcpKTtcXG4gICAgICAvLyBoYWx0IGV4ZWN1dGlvbi4gIHRoZSBSdW5uYWJsZSB3aWxsIGJlIG1hcmtlZCBwZW5kaW5nXFxuICAgICAgLy8gYnkgdGhlIHByZXZpb3VzIGNhbGwsIGFuZCB0aGUgdW5jYXVnaHQgaGFuZGxlciB3aWxsIGlnbm9yZVxcbiAgICAgIC8vIHRoZSBmYWlsdXJlLlxcbiAgICAgIHRocm93IG5ldyBQZW5kaW5nKCdhc3luYyBza2lwOyBhYm9ydGluZyBleGVjdXRpb24nKTtcXG4gICAgfTtcXG5cXG4gICAgaWYgKHRoaXMuYWxsb3dVbmNhdWdodCkge1xcbiAgICAgIHJldHVybiBjYWxsRm5Bc3luYyh0aGlzLmZuKTtcXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgIGNhbGxGbkFzeW5jKHRoaXMuZm4pO1xcbiAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICBlbWl0dGVkID0gdHJ1ZTtcXG4gICAgICBkb25lKHV0aWxzLmdldEVycm9yKGVycikpO1xcbiAgICB9XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGlmICh0aGlzLmFsbG93VW5jYXVnaHQpIHtcXG4gICAgaWYgKHRoaXMuaXNQZW5kaW5nKCkpIHtcXG4gICAgICBkb25lKCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY2FsbEZuKHRoaXMuZm4pO1xcbiAgICB9XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIC8vIHN5bmMgb3IgcHJvbWlzZS1yZXR1cm5pbmdcXG4gIHRyeSB7XFxuICAgIGlmICh0aGlzLmlzUGVuZGluZygpKSB7XFxuICAgICAgZG9uZSgpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGNhbGxGbih0aGlzLmZuKTtcXG4gICAgfVxcbiAgfSBjYXRjaCAoZXJyKSB7XFxuICAgIGVtaXR0ZWQgPSB0cnVlO1xcbiAgICBkb25lKHV0aWxzLmdldEVycm9yKGVycikpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY2FsbEZuIChmbikge1xcbiAgICB2YXIgcmVzdWx0ID0gZm4uY2FsbChjdHgpO1xcbiAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIHNlbGYucmVzZXRUaW1lb3V0KCk7XFxuICAgICAgcmVzdWx0XFxuICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGRvbmUoKTtcXG4gICAgICAgICAgLy8gUmV0dXJuIG51bGwgc28gbGlicmFyaWVzIGxpa2UgYmx1ZWJpcmQgZG8gbm90IHdhcm4gYWJvdXRcXG4gICAgICAgICAgLy8gc3Vic2VxdWVudGx5IGNvbnN0cnVjdGVkIFByb21pc2VzLlxcbiAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH0sXFxuICAgICAgICBmdW5jdGlvbiAocmVhc29uKSB7XFxuICAgICAgICAgIGRvbmUocmVhc29uIHx8IG5ldyBFcnJvcignUHJvbWlzZSByZWplY3RlZCB3aXRoIG5vIG9yIGZhbHN5IHJlYXNvbicpKTtcXG4gICAgICAgIH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGlmIChzZWxmLmFzeW5jT25seSkge1xcbiAgICAgICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCctLWFzeW5jLW9ubHkgb3B0aW9uIGluIHVzZSB3aXRob3V0IGRlY2xhcmluZyBgZG9uZSgpYCBvciByZXR1cm5pbmcgYSBwcm9taXNlJykpO1xcbiAgICAgIH1cXG5cXG4gICAgICBkb25lKCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNhbGxGbkFzeW5jIChmbikge1xcbiAgICB2YXIgcmVzdWx0ID0gZm4uY2FsbChjdHgsIGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgfHwgdG9TdHJpbmcuY2FsbChlcnIpID09PSAnW29iamVjdCBFcnJvcl0nKSB7XFxuICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoZXJyKSB7XFxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVycikgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XFxuICAgICAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignZG9uZSgpIGludm9rZWQgd2l0aCBub24tRXJyb3I6ICcgK1xcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGVycikpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignZG9uZSgpIGludm9rZWQgd2l0aCBub24tRXJyb3I6ICcgKyBlcnIpKTtcXG4gICAgICB9XFxuICAgICAgaWYgKHJlc3VsdCAmJiB1dGlscy5pc1Byb21pc2UocmVzdWx0KSkge1xcbiAgICAgICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCdSZXNvbHV0aW9uIG1ldGhvZCBpcyBvdmVyc3BlY2lmaWVkLiBTcGVjaWZ5IGEgY2FsbGJhY2sgKm9yKiByZXR1cm4gYSBQcm9taXNlOyBub3QgYm90aC4nKSk7XFxuICAgICAgfVxcblxcbiAgICAgIGRvbmUoKTtcXG4gICAgfSk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBJbnN0YW50aWF0ZXMgYSBcXFwidGltZW91dFxcXCIgZXJyb3JcXG4gKlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtcyAtIFRpbWVvdXQgKGluIG1pbGxpc2Vjb25kcylcXG4gKiBAcmV0dXJucyB7RXJyb3J9IGEgXFxcInRpbWVvdXRcXFwiIGVycm9yXFxuICogQHByaXZhdGVcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuX3RpbWVvdXRFcnJvciA9IGZ1bmN0aW9uIChtcykge1xcbiAgdmFyIG1zZyA9ICdUaW1lb3V0IG9mICcgKyBtcyArICdtcyBleGNlZWRlZC4gRm9yIGFzeW5jIHRlc3RzIGFuZCBob29rcywgZW5zdXJlIFxcXCJkb25lKClcXFwiIGlzIGNhbGxlZDsgaWYgcmV0dXJuaW5nIGEgUHJvbWlzZSwgZW5zdXJlIGl0IHJlc29sdmVzLic7XFxuICBpZiAodGhpcy5maWxlKSB7XFxuICAgIG1zZyArPSAnICgnICsgdGhpcy5maWxlICsgJyknO1xcbiAgfVxcbiAgcmV0dXJuIG5ldyBFcnJvcihtc2cpO1xcbn07XFxuXFxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4vbXNcXFwiOjE0LFxcXCIuL3BlbmRpbmdcXFwiOjE1LFxcXCIuL3V0aWxzXFxcIjozNixcXFwiZGVidWdcXFwiOjQzLFxcXCJldmVudHNcXFwiOjQ3fV0sMzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBAbW9kdWxlIFJ1bm5lclxcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcXG52YXIgUGVuZGluZyA9IHJlcXVpcmUoJy4vcGVuZGluZycpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcXG52YXIgaW5oZXJpdHMgPSB1dGlscy5pbmhlcml0cztcXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb2NoYTpydW5uZXInKTtcXG52YXIgUnVubmFibGUgPSByZXF1aXJlKCcuL3J1bm5hYmxlJyk7XFxudmFyIHN0YWNrRmlsdGVyID0gdXRpbHMuc3RhY2tUcmFjZUZpbHRlcigpO1xcbnZhciBzdHJpbmdpZnkgPSB1dGlscy5zdHJpbmdpZnk7XFxudmFyIHR5cGUgPSB1dGlscy50eXBlO1xcbnZhciB1bmRlZmluZWRFcnJvciA9IHV0aWxzLnVuZGVmaW5lZEVycm9yO1xcblxcbi8qKlxcbiAqIE5vbi1lbnVtZXJhYmxlIGdsb2JhbHMuXFxuICovXFxuXFxudmFyIGdsb2JhbHMgPSBbXFxuICAnc2V0VGltZW91dCcsXFxuICAnY2xlYXJUaW1lb3V0JyxcXG4gICdzZXRJbnRlcnZhbCcsXFxuICAnY2xlYXJJbnRlcnZhbCcsXFxuICAnWE1MSHR0cFJlcXVlc3QnLFxcbiAgJ0RhdGUnLFxcbiAgJ3NldEltbWVkaWF0ZScsXFxuICAnY2xlYXJJbW1lZGlhdGUnXFxuXTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFJ1bm5lcmAuXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBSdW5uZXI7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIGBSdW5uZXJgIGZvciB0aGUgZ2l2ZW4gYHN1aXRlYC4gRGVyaXZlZCBmcm9tIFtFdmVudEVtaXR0ZXJdKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWwjZXZlbnRzX2NsYXNzX2V2ZW50ZW1pdHRlcilcXG4gKlxcbiAqIEV2ZW50czpcXG4gKlxcbiAqICAgLSBgc3RhcnRgICBleGVjdXRpb24gc3RhcnRlZFxcbiAqICAgLSBgZW5kYCAgZXhlY3V0aW9uIGNvbXBsZXRlXFxuICogICAtIGBzdWl0ZWAgIChzdWl0ZSkgdGVzdCBzdWl0ZSBleGVjdXRpb24gc3RhcnRlZFxcbiAqICAgLSBgc3VpdGUgZW5kYCAgKHN1aXRlKSBhbGwgdGVzdHMgKGFuZCBzdWItc3VpdGVzKSBoYXZlIGZpbmlzaGVkXFxuICogICAtIGB0ZXN0YCAgKHRlc3QpIHRlc3QgZXhlY3V0aW9uIHN0YXJ0ZWRcXG4gKiAgIC0gYHRlc3QgZW5kYCAgKHRlc3QpIHRlc3QgY29tcGxldGVkXFxuICogICAtIGBob29rYCAgKGhvb2spIGhvb2sgZXhlY3V0aW9uIHN0YXJ0ZWRcXG4gKiAgIC0gYGhvb2sgZW5kYCAgKGhvb2spIGhvb2sgY29tcGxldGVcXG4gKiAgIC0gYHBhc3NgICAodGVzdCkgdGVzdCBwYXNzZWRcXG4gKiAgIC0gYGZhaWxgICAodGVzdCwgZXJyKSB0ZXN0IGZhaWxlZFxcbiAqICAgLSBgcGVuZGluZ2AgICh0ZXN0KSB0ZXN0IHBlbmRpbmdcXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYVxcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3NcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7U3VpdGV9IFtzdWl0ZV0gUm9vdCBzdWl0ZVxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlbGF5XSBXaGV0aGVyIG9yIG5vdCB0byBkZWxheSBleGVjdXRpb24gb2Ygcm9vdCBzdWl0ZVxcbiAqIHVudGlsIHJlYWR5LlxcbiAqL1xcbmZ1bmN0aW9uIFJ1bm5lciAoc3VpdGUsIGRlbGF5KSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB0aGlzLl9nbG9iYWxzID0gW107XFxuICB0aGlzLl9hYm9ydCA9IGZhbHNlO1xcbiAgdGhpcy5fZGVsYXkgPSBkZWxheTtcXG4gIHRoaXMuc3VpdGUgPSBzdWl0ZTtcXG4gIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xcbiAgdGhpcy50b3RhbCA9IHN1aXRlLnRvdGFsKCk7XFxuICB0aGlzLmZhaWx1cmVzID0gMDtcXG4gIHRoaXMub24oJ3Rlc3QgZW5kJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgc2VsZi5jaGVja0dsb2JhbHModGVzdCk7XFxuICB9KTtcXG4gIHRoaXMub24oJ2hvb2sgZW5kJywgZnVuY3Rpb24gKGhvb2spIHtcXG4gICAgc2VsZi5jaGVja0dsb2JhbHMoaG9vayk7XFxuICB9KTtcXG4gIHRoaXMuX2RlZmF1bHRHcmVwID0gLy4qLztcXG4gIHRoaXMuZ3JlcCh0aGlzLl9kZWZhdWx0R3JlcCk7XFxuICB0aGlzLmdsb2JhbHModGhpcy5nbG9iYWxQcm9wcygpLmNvbmNhdChleHRyYUdsb2JhbHMoKSkpO1xcbn1cXG5cXG4vKipcXG4gKiBXcmFwcGVyIGZvciBzZXRJbW1lZGlhdGUsIHByb2Nlc3MubmV4dFRpY2ssIG9yIGJyb3dzZXIgcG9seWZpbGwuXFxuICpcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5lci5pbW1lZGlhdGVseSA9IGdsb2JhbC5zZXRJbW1lZGlhdGUgfHwgcHJvY2Vzcy5uZXh0VGljaztcXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEV2ZW50RW1pdHRlci5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKFJ1bm5lciwgRXZlbnRFbWl0dGVyKTtcXG5cXG4vKipcXG4gKiBSdW4gdGVzdHMgd2l0aCBmdWxsIHRpdGxlcyBtYXRjaGluZyBgcmVgLiBVcGRhdGVzIHJ1bm5lci50b3RhbFxcbiAqIHdpdGggbnVtYmVyIG9mIHRlc3RzIG1hdGNoZWQuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKiBAbWVtYmVyb2YgTW9jaGEuUnVubmVyXFxuICogQHBhcmFtIHtSZWdFeHB9IHJlXFxuICogQHBhcmFtIHtib29sZWFufSBpbnZlcnRcXG4gKiBAcmV0dXJuIHtSdW5uZXJ9IFJ1bm5lciBpbnN0YW5jZS5cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmdyZXAgPSBmdW5jdGlvbiAocmUsIGludmVydCkge1xcbiAgZGVidWcoJ2dyZXAgJXMnLCByZSk7XFxuICB0aGlzLl9ncmVwID0gcmU7XFxuICB0aGlzLl9pbnZlcnQgPSBpbnZlcnQ7XFxuICB0aGlzLnRvdGFsID0gdGhpcy5ncmVwVG90YWwodGhpcy5zdWl0ZSk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiB0ZXN0cyBtYXRjaGluZyB0aGUgZ3JlcCBzZWFyY2ggZm9yIHRoZVxcbiAqIGdpdmVuIHN1aXRlLlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhLlJ1bm5lclxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXFxuICogQHJldHVybiB7bnVtYmVyfVxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuZ3JlcFRvdGFsID0gZnVuY3Rpb24gKHN1aXRlKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgdG90YWwgPSAwO1xcblxcbiAgc3VpdGUuZWFjaFRlc3QoZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdmFyIG1hdGNoID0gc2VsZi5fZ3JlcC50ZXN0KHRlc3QuZnVsbFRpdGxlKCkpO1xcbiAgICBpZiAoc2VsZi5faW52ZXJ0KSB7XFxuICAgICAgbWF0Y2ggPSAhbWF0Y2g7XFxuICAgIH1cXG4gICAgaWYgKG1hdGNoKSB7XFxuICAgICAgdG90YWwrKztcXG4gICAgfVxcbiAgfSk7XFxuXFxuICByZXR1cm4gdG90YWw7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBsaXN0IG9mIGdsb2JhbCBwcm9wZXJ0aWVzLlxcbiAqXFxuICogQHJldHVybiB7QXJyYXl9XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5nbG9iYWxQcm9wcyA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBwcm9wcyA9IE9iamVjdC5rZXlzKGdsb2JhbCk7XFxuXFxuICAvLyBub24tZW51bWVyYWJsZXNcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ2xvYmFscy5sZW5ndGg7ICsraSkge1xcbiAgICBpZiAofnByb3BzLmluZGV4T2YoZ2xvYmFsc1tpXSkpIHtcXG4gICAgICBjb250aW51ZTtcXG4gICAgfVxcbiAgICBwcm9wcy5wdXNoKGdsb2JhbHNbaV0pO1xcbiAgfVxcblxcbiAgcmV0dXJuIHByb3BzO1xcbn07XFxuXFxuLyoqXFxuICogQWxsb3cgdGhlIGdpdmVuIGBhcnJgIG9mIGdsb2JhbHMuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKiBAbWVtYmVyb2YgTW9jaGEuUnVubmVyXFxuICogQHBhcmFtIHtBcnJheX0gYXJyXFxuICogQHJldHVybiB7UnVubmVyfSBSdW5uZXIgaW5zdGFuY2UuXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5nbG9iYWxzID0gZnVuY3Rpb24gKGFycikge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9nbG9iYWxzO1xcbiAgfVxcbiAgZGVidWcoJ2dsb2JhbHMgJWonLCBhcnIpO1xcbiAgdGhpcy5fZ2xvYmFscyA9IHRoaXMuX2dsb2JhbHMuY29uY2F0KGFycik7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIENoZWNrIGZvciBnbG9iYWwgdmFyaWFibGUgbGVha3MuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmNoZWNrR2xvYmFscyA9IGZ1bmN0aW9uICh0ZXN0KSB7XFxuICBpZiAodGhpcy5pZ25vcmVMZWFrcykge1xcbiAgICByZXR1cm47XFxuICB9XFxuICB2YXIgb2sgPSB0aGlzLl9nbG9iYWxzO1xcblxcbiAgdmFyIGdsb2JhbHMgPSB0aGlzLmdsb2JhbFByb3BzKCk7XFxuICB2YXIgbGVha3M7XFxuXFxuICBpZiAodGVzdCkge1xcbiAgICBvayA9IG9rLmNvbmNhdCh0ZXN0Ll9hbGxvd2VkR2xvYmFscyB8fCBbXSk7XFxuICB9XFxuXFxuICBpZiAodGhpcy5wcmV2R2xvYmFsc0xlbmd0aCA9PT0gZ2xvYmFscy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgdGhpcy5wcmV2R2xvYmFsc0xlbmd0aCA9IGdsb2JhbHMubGVuZ3RoO1xcblxcbiAgbGVha3MgPSBmaWx0ZXJMZWFrcyhvaywgZ2xvYmFscyk7XFxuICB0aGlzLl9nbG9iYWxzID0gdGhpcy5fZ2xvYmFscy5jb25jYXQobGVha3MpO1xcblxcbiAgaWYgKGxlYWtzLmxlbmd0aCA+IDEpIHtcXG4gICAgdGhpcy5mYWlsKHRlc3QsIG5ldyBFcnJvcignZ2xvYmFsIGxlYWtzIGRldGVjdGVkOiAnICsgbGVha3Muam9pbignLCAnKSArICcnKSk7XFxuICB9IGVsc2UgaWYgKGxlYWtzLmxlbmd0aCkge1xcbiAgICB0aGlzLmZhaWwodGVzdCwgbmV3IEVycm9yKCdnbG9iYWwgbGVhayBkZXRlY3RlZDogJyArIGxlYWtzWzBdKSk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBGYWlsIHRoZSBnaXZlbiBgdGVzdGAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1Rlc3R9IHRlc3RcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmZhaWwgPSBmdW5jdGlvbiAodGVzdCwgZXJyKSB7XFxuICBpZiAodGVzdC5pc1BlbmRpbmcoKSkge1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICArK3RoaXMuZmFpbHVyZXM7XFxuICB0ZXN0LnN0YXRlID0gJ2ZhaWxlZCc7XFxuXFxuICBpZiAoIShlcnIgaW5zdGFuY2VvZiBFcnJvciB8fCAoZXJyICYmIHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gJ3N0cmluZycpKSkge1xcbiAgICBlcnIgPSBuZXcgRXJyb3IoJ3RoZSAnICsgdHlwZShlcnIpICsgJyAnICsgc3RyaW5naWZ5KGVycikgKyAnIHdhcyB0aHJvd24sIHRocm93IGFuIEVycm9yIDopJyk7XFxuICB9XFxuXFxuICB0cnkge1xcbiAgICBlcnIuc3RhY2sgPSAodGhpcy5mdWxsU3RhY2tUcmFjZSB8fCAhZXJyLnN0YWNrKVxcbiAgICAgID8gZXJyLnN0YWNrXFxuICAgICAgOiBzdGFja0ZpbHRlcihlcnIuc3RhY2spO1xcbiAgfSBjYXRjaCAoaWdub3JlZCkge1xcbiAgICAvLyBzb21lIGVudmlyb25tZW50cyBkbyBub3QgdGFrZSBraW5kbHkgdG8gbW9ua2V5aW5nIHdpdGggdGhlIHN0YWNrXFxuICB9XFxuXFxuICB0aGlzLmVtaXQoJ2ZhaWwnLCB0ZXN0LCBlcnIpO1xcbn07XFxuXFxuLyoqXFxuICogRmFpbCB0aGUgZ2l2ZW4gYGhvb2tgIHdpdGggYGVycmAuXFxuICpcXG4gKiBIb29rIGZhaWx1cmVzIHdvcmsgaW4gdGhlIGZvbGxvd2luZyBwYXR0ZXJuOlxcbiAqIC0gSWYgYmFpbCwgdGhlbiBleGl0XFxuICogLSBGYWlsZWQgYGJlZm9yZWAgaG9vayBza2lwcyBhbGwgdGVzdHMgaW4gYSBzdWl0ZSBhbmQgc3Vic3VpdGVzLFxcbiAqICAgYnV0IGp1bXBzIHRvIGNvcnJlc3BvbmRpbmcgYGFmdGVyYCBob29rXFxuICogLSBGYWlsZWQgYGJlZm9yZSBlYWNoYCBob29rIHNraXBzIHJlbWFpbmluZyB0ZXN0cyBpbiBhXFxuICogICBzdWl0ZSBhbmQganVtcHMgdG8gY29ycmVzcG9uZGluZyBgYWZ0ZXIgZWFjaGAgaG9vayxcXG4gKiAgIHdoaWNoIGlzIHJ1biBvbmx5IG9uY2VcXG4gKiAtIEZhaWxlZCBgYWZ0ZXJgIGhvb2sgZG9lcyBub3QgYWx0ZXJcXG4gKiAgIGV4ZWN1dGlvbiBvcmRlclxcbiAqIC0gRmFpbGVkIGBhZnRlciBlYWNoYCBob29rIHNraXBzIHJlbWFpbmluZyB0ZXN0cyBpbiBhXFxuICogICBzdWl0ZSBhbmQgc3Vic3VpdGVzLCBidXQgZXhlY3V0ZXMgb3RoZXIgYGFmdGVyIGVhY2hgXFxuICogICBob29rc1xcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtIb29rfSBob29rXFxuICogQHBhcmFtIHtFcnJvcn0gZXJyXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5mYWlsSG9vayA9IGZ1bmN0aW9uIChob29rLCBlcnIpIHtcXG4gIGlmIChob29rLmN0eCAmJiBob29rLmN0eC5jdXJyZW50VGVzdCkge1xcbiAgICBob29rLm9yaWdpbmFsVGl0bGUgPSBob29rLm9yaWdpbmFsVGl0bGUgfHwgaG9vay50aXRsZTtcXG4gICAgaG9vay50aXRsZSA9IGhvb2sub3JpZ2luYWxUaXRsZSArICcgZm9yIFxcXCInICsgaG9vay5jdHguY3VycmVudFRlc3QudGl0bGUgKyAnXFxcIic7XFxuICB9XFxuXFxuICBpZiAodGhpcy5zdWl0ZS5iYWlsKCkpIHtcXG4gICAgdGhpcy5lbWl0KCdlbmQnKTtcXG4gIH1cXG4gIHRoaXMuZmFpbChob29rLCBlcnIpO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIGhvb2sgYG5hbWVgIGNhbGxiYWNrcyBhbmQgdGhlbiBpbnZva2UgYGZuKClgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcblxcblJ1bm5lci5wcm90b3R5cGUuaG9vayA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xcbiAgdmFyIHN1aXRlID0gdGhpcy5zdWl0ZTtcXG4gIHZhciBob29rcyA9IHN1aXRlWydfJyArIG5hbWVdO1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgZnVuY3Rpb24gbmV4dCAoaSkge1xcbiAgICB2YXIgaG9vayA9IGhvb2tzW2ldO1xcbiAgICBpZiAoIWhvb2spIHtcXG4gICAgICByZXR1cm4gZm4oKTtcXG4gICAgfVxcbiAgICBzZWxmLmN1cnJlbnRSdW5uYWJsZSA9IGhvb2s7XFxuXFxuICAgIGhvb2suY3R4LmN1cnJlbnRUZXN0ID0gc2VsZi50ZXN0O1xcblxcbiAgICBzZWxmLmVtaXQoJ2hvb2snLCBob29rKTtcXG5cXG4gICAgaWYgKCFob29rLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGgpIHtcXG4gICAgICBob29rLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgICAgIHNlbGYuZmFpbEhvb2soaG9vaywgZXJyKTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBob29rLnJ1bihmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgdmFyIHRlc3RFcnJvciA9IGhvb2suZXJyb3IoKTtcXG4gICAgICBpZiAodGVzdEVycm9yKSB7XFxuICAgICAgICBzZWxmLmZhaWwoc2VsZi50ZXN0LCB0ZXN0RXJyb3IpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoZXJyKSB7XFxuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgUGVuZGluZykge1xcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ2JlZm9yZUVhY2gnIHx8IG5hbWUgPT09ICdhZnRlckVhY2gnKSB7XFxuICAgICAgICAgICAgc2VsZi50ZXN0LnBlbmRpbmcgPSB0cnVlO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHN1aXRlLnRlc3RzLmZvckVhY2goZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgICAgICAgICAgIHRlc3QucGVuZGluZyA9IHRydWU7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgLy8gYSBwZW5kaW5nIGhvb2sgd29uJ3QgYmUgZXhlY3V0ZWQgdHdpY2UuXFxuICAgICAgICAgICAgaG9vay5wZW5kaW5nID0gdHJ1ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc2VsZi5mYWlsSG9vayhob29rLCBlcnIpO1xcblxcbiAgICAgICAgICAvLyBzdG9wIGV4ZWN1dGluZyBob29rcywgbm90aWZ5IGNhbGxlZSBvZiBob29rIGVyclxcbiAgICAgICAgICByZXR1cm4gZm4oZXJyKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgc2VsZi5lbWl0KCdob29rIGVuZCcsIGhvb2spO1xcbiAgICAgIGRlbGV0ZSBob29rLmN0eC5jdXJyZW50VGVzdDtcXG4gICAgICBuZXh0KCsraSk7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgUnVubmVyLmltbWVkaWF0ZWx5KGZ1bmN0aW9uICgpIHtcXG4gICAgbmV4dCgwKTtcXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIGhvb2sgYG5hbWVgIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHN1aXRlc2BcXG4gKiBpbiBvcmRlciwgYW5kIGNhbGxiYWNrIGBmbihlcnIsIGVyclN1aXRlKWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAqIEBwYXJhbSB7QXJyYXl9IHN1aXRlc1xcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ob29rcyA9IGZ1bmN0aW9uIChuYW1lLCBzdWl0ZXMsIGZuKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgb3JpZyA9IHRoaXMuc3VpdGU7XFxuXFxuICBmdW5jdGlvbiBuZXh0IChzdWl0ZSkge1xcbiAgICBzZWxmLnN1aXRlID0gc3VpdGU7XFxuXFxuICAgIGlmICghc3VpdGUpIHtcXG4gICAgICBzZWxmLnN1aXRlID0gb3JpZztcXG4gICAgICByZXR1cm4gZm4oKTtcXG4gICAgfVxcblxcbiAgICBzZWxmLmhvb2sobmFtZSwgZnVuY3Rpb24gKGVycikge1xcbiAgICAgIGlmIChlcnIpIHtcXG4gICAgICAgIHZhciBlcnJTdWl0ZSA9IHNlbGYuc3VpdGU7XFxuICAgICAgICBzZWxmLnN1aXRlID0gb3JpZztcXG4gICAgICAgIHJldHVybiBmbihlcnIsIGVyclN1aXRlKTtcXG4gICAgICB9XFxuXFxuICAgICAgbmV4dChzdWl0ZXMucG9wKCkpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIG5leHQoc3VpdGVzLnBvcCgpKTtcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBob29rcyBmcm9tIHRoZSB0b3AgbGV2ZWwgZG93bi5cXG4gKlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmhvb2tVcCA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xcbiAgdmFyIHN1aXRlcyA9IFt0aGlzLnN1aXRlXS5jb25jYXQodGhpcy5wYXJlbnRzKCkpLnJldmVyc2UoKTtcXG4gIHRoaXMuaG9va3MobmFtZSwgc3VpdGVzLCBmbik7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gaG9va3MgZnJvbSB0aGUgYm90dG9tIHVwLlxcbiAqXFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuaG9va0Rvd24gPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcXG4gIHZhciBzdWl0ZXMgPSBbdGhpcy5zdWl0ZV0uY29uY2F0KHRoaXMucGFyZW50cygpKTtcXG4gIHRoaXMuaG9va3MobmFtZSwgc3VpdGVzLCBmbik7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYW4gYXJyYXkgb2YgcGFyZW50IFN1aXRlcyBmcm9tXFxuICogY2xvc2VzdCB0byBmdXJ0aGVzdC5cXG4gKlxcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUucGFyZW50cyA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdWl0ZSA9IHRoaXMuc3VpdGU7XFxuICB2YXIgc3VpdGVzID0gW107XFxuICB3aGlsZSAoc3VpdGUucGFyZW50KSB7XFxuICAgIHN1aXRlID0gc3VpdGUucGFyZW50O1xcbiAgICBzdWl0ZXMucHVzaChzdWl0ZSk7XFxuICB9XFxuICByZXR1cm4gc3VpdGVzO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIHRoZSBjdXJyZW50IHRlc3QgYW5kIGNhbGxiYWNrIGBmbihlcnIpYC5cXG4gKlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ydW5UZXN0ID0gZnVuY3Rpb24gKGZuKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgdGVzdCA9IHRoaXMudGVzdDtcXG5cXG4gIGlmICghdGVzdCkge1xcbiAgICByZXR1cm47XFxuICB9XFxuICBpZiAodGhpcy5mb3JiaWRPbmx5ICYmIGhhc09ubHkodGhpcy5wYXJlbnRzKCkucmV2ZXJzZSgpWzBdIHx8IHRoaXMuc3VpdGUpKSB7XFxuICAgIGZuKG5ldyBFcnJvcignYC5vbmx5YCBmb3JiaWRkZW4nKSk7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIGlmICh0aGlzLmFzeW5jT25seSkge1xcbiAgICB0ZXN0LmFzeW5jT25seSA9IHRydWU7XFxuICB9XFxuICB0ZXN0Lm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgc2VsZi5mYWlsKHRlc3QsIGVycik7XFxuICB9KTtcXG4gIGlmICh0aGlzLmFsbG93VW5jYXVnaHQpIHtcXG4gICAgdGVzdC5hbGxvd1VuY2F1Z2h0ID0gdHJ1ZTtcXG4gICAgcmV0dXJuIHRlc3QucnVuKGZuKTtcXG4gIH1cXG4gIHRyeSB7XFxuICAgIHRlc3QucnVuKGZuKTtcXG4gIH0gY2F0Y2ggKGVycikge1xcbiAgICBmbihlcnIpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogUnVuIHRlc3RzIGluIHRoZSBnaXZlbiBgc3VpdGVgIGFuZCBpbnZva2UgdGhlIGNhbGxiYWNrIGBmbigpYCB3aGVuIGNvbXBsZXRlLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUucnVuVGVzdHMgPSBmdW5jdGlvbiAoc3VpdGUsIGZuKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgdGVzdHMgPSBzdWl0ZS50ZXN0cy5zbGljZSgpO1xcbiAgdmFyIHRlc3Q7XFxuXFxuICBmdW5jdGlvbiBob29rRXJyIChfLCBlcnJTdWl0ZSwgYWZ0ZXIpIHtcXG4gICAgLy8gYmVmb3JlL2FmdGVyIEVhY2ggaG9vayBmb3IgZXJyU3VpdGUgZmFpbGVkOlxcbiAgICB2YXIgb3JpZyA9IHNlbGYuc3VpdGU7XFxuXFxuICAgIC8vIGZvciBmYWlsZWQgJ2FmdGVyIGVhY2gnIGhvb2sgc3RhcnQgZnJvbSBlcnJTdWl0ZSBwYXJlbnQsXFxuICAgIC8vIG90aGVyd2lzZSBzdGFydCBmcm9tIGVyclN1aXRlIGl0c2VsZlxcbiAgICBzZWxmLnN1aXRlID0gYWZ0ZXIgPyBlcnJTdWl0ZS5wYXJlbnQgOiBlcnJTdWl0ZTtcXG5cXG4gICAgaWYgKHNlbGYuc3VpdGUpIHtcXG4gICAgICAvLyBjYWxsIGhvb2tVcCBhZnRlckVhY2hcXG4gICAgICBzZWxmLmhvb2tVcCgnYWZ0ZXJFYWNoJywgZnVuY3Rpb24gKGVycjIsIGVyclN1aXRlMikge1xcbiAgICAgICAgc2VsZi5zdWl0ZSA9IG9yaWc7XFxuICAgICAgICAvLyBzb21lIGhvb2tzIG1heSBmYWlsIGV2ZW4gbm93XFxuICAgICAgICBpZiAoZXJyMikge1xcbiAgICAgICAgICByZXR1cm4gaG9va0VycihlcnIyLCBlcnJTdWl0ZTIsIHRydWUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gcmVwb3J0IGVycm9yIHN1aXRlXFxuICAgICAgICBmbihlcnJTdWl0ZSk7XFxuICAgICAgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gdGhlcmUgaXMgbm8gbmVlZCBjYWxsaW5nIG90aGVyICdhZnRlciBlYWNoJyBob29rc1xcbiAgICAgIHNlbGYuc3VpdGUgPSBvcmlnO1xcbiAgICAgIGZuKGVyclN1aXRlKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gbmV4dCAoZXJyLCBlcnJTdWl0ZSkge1xcbiAgICAvLyBpZiB3ZSBiYWlsIGFmdGVyIGZpcnN0IGVyclxcbiAgICBpZiAoc2VsZi5mYWlsdXJlcyAmJiBzdWl0ZS5fYmFpbCkge1xcbiAgICAgIHJldHVybiBmbigpO1xcbiAgICB9XFxuXFxuICAgIGlmIChzZWxmLl9hYm9ydCkge1xcbiAgICAgIHJldHVybiBmbigpO1xcbiAgICB9XFxuXFxuICAgIGlmIChlcnIpIHtcXG4gICAgICByZXR1cm4gaG9va0VycihlcnIsIGVyclN1aXRlLCB0cnVlKTtcXG4gICAgfVxcblxcbiAgICAvLyBuZXh0IHRlc3RcXG4gICAgdGVzdCA9IHRlc3RzLnNoaWZ0KCk7XFxuXFxuICAgIC8vIGFsbCBkb25lXFxuICAgIGlmICghdGVzdCkge1xcbiAgICAgIHJldHVybiBmbigpO1xcbiAgICB9XFxuXFxuICAgIC8vIGdyZXBcXG4gICAgdmFyIG1hdGNoID0gc2VsZi5fZ3JlcC50ZXN0KHRlc3QuZnVsbFRpdGxlKCkpO1xcbiAgICBpZiAoc2VsZi5faW52ZXJ0KSB7XFxuICAgICAgbWF0Y2ggPSAhbWF0Y2g7XFxuICAgIH1cXG4gICAgaWYgKCFtYXRjaCkge1xcbiAgICAgIC8vIFJ1biBpbW1lZGlhdGVseSBvbmx5IGlmIHdlIGhhdmUgZGVmaW5lZCBhIGdyZXAuIFdoZW4gd2VcXG4gICAgICAvLyBkZWZpbmUgYSBncmVwIOKAlCBJdCBjYW4gY2F1c2UgbWF4aW11bSBjYWxsc3RhY2sgZXJyb3IgaWZcXG4gICAgICAvLyB0aGUgZ3JlcCBpcyBkb2luZyBhIGxhcmdlIHJlY3Vyc2l2ZSBsb29wIGJ5IG5lZ2xlY3RpbmdcXG4gICAgICAvLyBhbGwgdGVzdHMuIFRoZSBydW4gaW1tZWRpYXRlbHkgZnVuY3Rpb24gYWxzbyBjb21lcyB3aXRoXFxuICAgICAgLy8gYSBwZXJmb3JtYW5jZSBjb3N0LiBTbyB3ZSBkb24ndCB3YW50IHRvIHJ1biBpbW1lZGlhdGVseVxcbiAgICAgIC8vIGlmIHdlIHJ1biB0aGUgd2hvbGUgdGVzdCBzdWl0ZSwgYmVjYXVzZSBydW5uaW5nIHRoZSB3aG9sZVxcbiAgICAgIC8vIHRlc3Qgc3VpdGUgZG9uJ3QgZG8gYW55IGltbWVkaWF0ZSByZWN1cnNpdmUgbG9vcHMuIFRodXMsXFxuICAgICAgLy8gYWxsb3dpbmcgYSBKUyBydW50aW1lIHRvIGJyZWF0aGUuXFxuICAgICAgaWYgKHNlbGYuX2dyZXAgIT09IHNlbGYuX2RlZmF1bHRHcmVwKSB7XFxuICAgICAgICBSdW5uZXIuaW1tZWRpYXRlbHkobmV4dCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG5leHQoKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmICh0ZXN0LmlzUGVuZGluZygpKSB7XFxuICAgICAgaWYgKHNlbGYuZm9yYmlkUGVuZGluZykge1xcbiAgICAgICAgdGVzdC5pc1BlbmRpbmcgPSBhbHdheXNGYWxzZTtcXG4gICAgICAgIHNlbGYuZmFpbCh0ZXN0LCBuZXcgRXJyb3IoJ1BlbmRpbmcgdGVzdCBmb3JiaWRkZW4nKSk7XFxuICAgICAgICBkZWxldGUgdGVzdC5pc1BlbmRpbmc7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHNlbGYuZW1pdCgncGVuZGluZycsIHRlc3QpO1xcbiAgICAgIH1cXG4gICAgICBzZWxmLmVtaXQoJ3Rlc3QgZW5kJywgdGVzdCk7XFxuICAgICAgcmV0dXJuIG5leHQoKTtcXG4gICAgfVxcblxcbiAgICAvLyBleGVjdXRlIHRlc3QgYW5kIGhvb2socylcXG4gICAgc2VsZi5lbWl0KCd0ZXN0Jywgc2VsZi50ZXN0ID0gdGVzdCk7XFxuICAgIHNlbGYuaG9va0Rvd24oJ2JlZm9yZUVhY2gnLCBmdW5jdGlvbiAoZXJyLCBlcnJTdWl0ZSkge1xcbiAgICAgIGlmICh0ZXN0LmlzUGVuZGluZygpKSB7XFxuICAgICAgICBpZiAoc2VsZi5mb3JiaWRQZW5kaW5nKSB7XFxuICAgICAgICAgIHRlc3QuaXNQZW5kaW5nID0gYWx3YXlzRmFsc2U7XFxuICAgICAgICAgIHNlbGYuZmFpbCh0ZXN0LCBuZXcgRXJyb3IoJ1BlbmRpbmcgdGVzdCBmb3JiaWRkZW4nKSk7XFxuICAgICAgICAgIGRlbGV0ZSB0ZXN0LmlzUGVuZGluZztcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHNlbGYuZW1pdCgncGVuZGluZycsIHRlc3QpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2VsZi5lbWl0KCd0ZXN0IGVuZCcsIHRlc3QpO1xcbiAgICAgICAgcmV0dXJuIG5leHQoKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGVycikge1xcbiAgICAgICAgcmV0dXJuIGhvb2tFcnIoZXJyLCBlcnJTdWl0ZSwgZmFsc2UpO1xcbiAgICAgIH1cXG4gICAgICBzZWxmLmN1cnJlbnRSdW5uYWJsZSA9IHNlbGYudGVzdDtcXG4gICAgICBzZWxmLnJ1blRlc3QoZnVuY3Rpb24gKGVycikge1xcbiAgICAgICAgdGVzdCA9IHNlbGYudGVzdDtcXG4gICAgICAgIGlmIChlcnIpIHtcXG4gICAgICAgICAgdmFyIHJldHJ5ID0gdGVzdC5jdXJyZW50UmV0cnkoKTtcXG4gICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFBlbmRpbmcgJiYgc2VsZi5mb3JiaWRQZW5kaW5nKSB7XFxuICAgICAgICAgICAgc2VsZi5mYWlsKHRlc3QsIG5ldyBFcnJvcignUGVuZGluZyB0ZXN0IGZvcmJpZGRlbicpKTtcXG4gICAgICAgICAgfSBlbHNlIGlmIChlcnIgaW5zdGFuY2VvZiBQZW5kaW5nKSB7XFxuICAgICAgICAgICAgdGVzdC5wZW5kaW5nID0gdHJ1ZTtcXG4gICAgICAgICAgICBzZWxmLmVtaXQoJ3BlbmRpbmcnLCB0ZXN0KTtcXG4gICAgICAgICAgfSBlbHNlIGlmIChyZXRyeSA8IHRlc3QucmV0cmllcygpKSB7XFxuICAgICAgICAgICAgdmFyIGNsb25lZFRlc3QgPSB0ZXN0LmNsb25lKCk7XFxuICAgICAgICAgICAgY2xvbmVkVGVzdC5jdXJyZW50UmV0cnkocmV0cnkgKyAxKTtcXG4gICAgICAgICAgICB0ZXN0cy51bnNoaWZ0KGNsb25lZFRlc3QpO1xcblxcbiAgICAgICAgICAgIC8vIEVhcmx5IHJldHVybiArIGhvb2sgdHJpZ2dlciBzbyB0aGF0IGl0IGRvZXNuJ3RcXG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIGNvdW50IHdyb25nXFxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaG9va1VwKCdhZnRlckVhY2gnLCBuZXh0KTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzZWxmLmZhaWwodGVzdCwgZXJyKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZWxmLmVtaXQoJ3Rlc3QgZW5kJywgdGVzdCk7XFxuXFxuICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBQZW5kaW5nKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gc2VsZi5ob29rVXAoJ2FmdGVyRWFjaCcsIG5leHQpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGVzdC5zdGF0ZSA9ICdwYXNzZWQnO1xcbiAgICAgICAgc2VsZi5lbWl0KCdwYXNzJywgdGVzdCk7XFxuICAgICAgICBzZWxmLmVtaXQoJ3Rlc3QgZW5kJywgdGVzdCk7XFxuICAgICAgICBzZWxmLmhvb2tVcCgnYWZ0ZXJFYWNoJywgbmV4dCk7XFxuICAgICAgfSk7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgdGhpcy5uZXh0ID0gbmV4dDtcXG4gIHRoaXMuaG9va0VyciA9IGhvb2tFcnI7XFxuICBuZXh0KCk7XFxufTtcXG5cXG5mdW5jdGlvbiBhbHdheXNGYWxzZSAoKSB7XFxuICByZXR1cm4gZmFsc2U7XFxufVxcblxcbi8qKlxcbiAqIFJ1biB0aGUgZ2l2ZW4gYHN1aXRlYCBhbmQgaW52b2tlIHRoZSBjYWxsYmFjayBgZm4oKWAgd2hlbiBjb21wbGV0ZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLnJ1blN1aXRlID0gZnVuY3Rpb24gKHN1aXRlLCBmbikge1xcbiAgdmFyIGkgPSAwO1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHRvdGFsID0gdGhpcy5ncmVwVG90YWwoc3VpdGUpO1xcbiAgdmFyIGFmdGVyQWxsSG9va0NhbGxlZCA9IGZhbHNlO1xcblxcbiAgZGVidWcoJ3J1biBzdWl0ZSAlcycsIHN1aXRlLmZ1bGxUaXRsZSgpKTtcXG5cXG4gIGlmICghdG90YWwgfHwgKHNlbGYuZmFpbHVyZXMgJiYgc3VpdGUuX2JhaWwpKSB7XFxuICAgIHJldHVybiBmbigpO1xcbiAgfVxcblxcbiAgdGhpcy5lbWl0KCdzdWl0ZScsIHRoaXMuc3VpdGUgPSBzdWl0ZSk7XFxuXFxuICBmdW5jdGlvbiBuZXh0IChlcnJTdWl0ZSkge1xcbiAgICBpZiAoZXJyU3VpdGUpIHtcXG4gICAgICAvLyBjdXJyZW50IHN1aXRlIGZhaWxlZCBvbiBhIGhvb2sgZnJvbSBlcnJTdWl0ZVxcbiAgICAgIGlmIChlcnJTdWl0ZSA9PT0gc3VpdGUpIHtcXG4gICAgICAgIC8vIGlmIGVyclN1aXRlIGlzIGN1cnJlbnQgc3VpdGVcXG4gICAgICAgIC8vIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHNpYmxpbmcgc3VpdGVcXG4gICAgICAgIHJldHVybiBkb25lKCk7XFxuICAgICAgfVxcbiAgICAgIC8vIGVyclN1aXRlIGlzIGFtb25nIHRoZSBwYXJlbnRzIG9mIGN1cnJlbnQgc3VpdGVcXG4gICAgICAvLyBzdG9wIGV4ZWN1dGlvbiBvZiBlcnJTdWl0ZSBhbmQgYWxsIHN1Yi1zdWl0ZXNcXG4gICAgICByZXR1cm4gZG9uZShlcnJTdWl0ZSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHNlbGYuX2Fib3J0KSB7XFxuICAgICAgcmV0dXJuIGRvbmUoKTtcXG4gICAgfVxcblxcbiAgICB2YXIgY3VyciA9IHN1aXRlLnN1aXRlc1tpKytdO1xcbiAgICBpZiAoIWN1cnIpIHtcXG4gICAgICByZXR1cm4gZG9uZSgpO1xcbiAgICB9XFxuXFxuICAgIC8vIEF2b2lkIGdyZXAgbmVnbGVjdGluZyBsYXJnZSBudW1iZXIgb2YgdGVzdHMgY2F1c2luZyBhXFxuICAgIC8vIGh1Z2UgcmVjdXJzaXZlIGxvb3AgYW5kIHRodXMgYSBtYXhpbXVtIGNhbGwgc3RhY2sgZXJyb3IuXFxuICAgIC8vIFNlZSBjb21tZW50IGluIGB0aGlzLnJ1blRlc3RzKClgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxcbiAgICBpZiAoc2VsZi5fZ3JlcCAhPT0gc2VsZi5fZGVmYXVsdEdyZXApIHtcXG4gICAgICBSdW5uZXIuaW1tZWRpYXRlbHkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgc2VsZi5ydW5TdWl0ZShjdXJyLCBuZXh0KTtcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzZWxmLnJ1blN1aXRlKGN1cnIsIG5leHQpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBkb25lIChlcnJTdWl0ZSkge1xcbiAgICBzZWxmLnN1aXRlID0gc3VpdGU7XFxuICAgIHNlbGYubmV4dFN1aXRlID0gbmV4dDtcXG5cXG4gICAgaWYgKGFmdGVyQWxsSG9va0NhbGxlZCkge1xcbiAgICAgIGZuKGVyclN1aXRlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBtYXJrIHRoYXQgdGhlIGFmdGVyQWxsIGJsb2NrIGhhcyBiZWVuIGNhbGxlZCBvbmNlXFxuICAgICAgLy8gYW5kIHNvIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGlzIGFuIGVycm9yIGluIGl0LlxcbiAgICAgIGFmdGVyQWxsSG9va0NhbGxlZCA9IHRydWU7XFxuXFxuICAgICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byB0ZXN0XFxuICAgICAgZGVsZXRlIHNlbGYudGVzdDtcXG5cXG4gICAgICBzZWxmLmhvb2soJ2FmdGVyQWxsJywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgc2VsZi5lbWl0KCdzdWl0ZSBlbmQnLCBzdWl0ZSk7XFxuICAgICAgICBmbihlcnJTdWl0ZSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHRoaXMubmV4dFN1aXRlID0gbmV4dDtcXG5cXG4gIHRoaXMuaG9vaygnYmVmb3JlQWxsJywgZnVuY3Rpb24gKGVycikge1xcbiAgICBpZiAoZXJyKSB7XFxuICAgICAgcmV0dXJuIGRvbmUoKTtcXG4gICAgfVxcbiAgICBzZWxmLnJ1blRlc3RzKHN1aXRlLCBuZXh0KTtcXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogSGFuZGxlIHVuY2F1Z2h0IGV4Y2VwdGlvbnMuXFxuICpcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLnVuY2F1Z2h0ID0gZnVuY3Rpb24gKGVycikge1xcbiAgaWYgKGVycikge1xcbiAgICBkZWJ1ZygndW5jYXVnaHQgZXhjZXB0aW9uICVzJywgZXJyID09PSAoZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LmNhbGwoZXJyKSkgPyAoZXJyLm1lc3NhZ2UgfHwgZXJyKSA6IGVycik7XFxuICB9IGVsc2Uge1xcbiAgICBkZWJ1ZygndW5jYXVnaHQgdW5kZWZpbmVkIGV4Y2VwdGlvbicpO1xcbiAgICBlcnIgPSB1bmRlZmluZWRFcnJvcigpO1xcbiAgfVxcbiAgZXJyLnVuY2F1Z2h0ID0gdHJ1ZTtcXG5cXG4gIHZhciBydW5uYWJsZSA9IHRoaXMuY3VycmVudFJ1bm5hYmxlO1xcblxcbiAgaWYgKCFydW5uYWJsZSkge1xcbiAgICBydW5uYWJsZSA9IG5ldyBSdW5uYWJsZSgnVW5jYXVnaHQgZXJyb3Igb3V0c2lkZSB0ZXN0IHN1aXRlJyk7XFxuICAgIHJ1bm5hYmxlLnBhcmVudCA9IHRoaXMuc3VpdGU7XFxuXFxuICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcXG4gICAgICB0aGlzLmZhaWwocnVubmFibGUsIGVycik7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gQ2FuJ3QgcmVjb3ZlciBmcm9tIHRoaXMgZmFpbHVyZVxcbiAgICAgIHRoaXMuZW1pdCgnc3RhcnQnKTtcXG4gICAgICB0aGlzLmZhaWwocnVubmFibGUsIGVycik7XFxuICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICBydW5uYWJsZS5jbGVhclRpbWVvdXQoKTtcXG5cXG4gIC8vIElnbm9yZSBlcnJvcnMgaWYgYWxyZWFkeSBmYWlsZWQgb3IgcGVuZGluZ1xcbiAgLy8gU2VlICMzMjI2XFxuICBpZiAocnVubmFibGUuaXNGYWlsZWQoKSB8fCBydW5uYWJsZS5pc1BlbmRpbmcoKSkge1xcbiAgICByZXR1cm47XFxuICB9XFxuICAvLyB3ZSBjYW5ub3QgcmVjb3ZlciBncmFjZWZ1bGx5IGlmIGEgUnVubmFibGUgaGFzIGFscmVhZHkgcGFzc2VkXFxuICAvLyB0aGVuIGZhaWxzIGFzeW5jaHJvbm91c2x5XFxuICB2YXIgYWxyZWFkeVBhc3NlZCA9IHJ1bm5hYmxlLmlzUGFzc2VkKCk7XFxuICAvLyB0aGlzIHdpbGwgY2hhbmdlIHRoZSBzdGF0ZSB0byBcXFwiZmFpbGVkXFxcIiByZWdhcmRsZXNzIG9mIHRoZSBjdXJyZW50IHZhbHVlXFxuICB0aGlzLmZhaWwocnVubmFibGUsIGVycik7XFxuICBpZiAoIWFscmVhZHlQYXNzZWQpIHtcXG4gICAgLy8gcmVjb3ZlciBmcm9tIHRlc3RcXG4gICAgaWYgKHJ1bm5hYmxlLnR5cGUgPT09ICd0ZXN0Jykge1xcbiAgICAgIHRoaXMuZW1pdCgndGVzdCBlbmQnLCBydW5uYWJsZSk7XFxuICAgICAgdGhpcy5ob29rVXAoJ2FmdGVyRWFjaCcsIHRoaXMubmV4dCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIC8vIHJlY292ZXIgZnJvbSBob29rc1xcbiAgICB2YXIgZXJyU3VpdGUgPSB0aGlzLnN1aXRlO1xcbiAgICAvLyBpZiBob29rIGZhaWx1cmUgaXMgaW4gYWZ0ZXJFYWNoIGJsb2NrXFxuICAgIGlmIChydW5uYWJsZS5mdWxsVGl0bGUoKS5pbmRleE9mKCdhZnRlciBlYWNoJykgPiAtMSkge1xcbiAgICAgIHJldHVybiB0aGlzLmhvb2tFcnIoZXJyLCBlcnJTdWl0ZSwgdHJ1ZSk7XFxuICAgIH1cXG4gICAgLy8gaWYgaG9vayBmYWlsdXJlIGlzIGluIGJlZm9yZUVhY2ggYmxvY2tcXG4gICAgaWYgKHJ1bm5hYmxlLmZ1bGxUaXRsZSgpLmluZGV4T2YoJ2JlZm9yZSBlYWNoJykgPiAtMSkge1xcbiAgICAgIHJldHVybiB0aGlzLmhvb2tFcnIoZXJyLCBlcnJTdWl0ZSwgZmFsc2UpO1xcbiAgICB9XFxuICAgIC8vIGlmIGhvb2sgZmFpbHVyZSBpcyBpbiBhZnRlciBvciBiZWZvcmUgYmxvY2tzXFxuICAgIHJldHVybiB0aGlzLm5leHRTdWl0ZShlcnJTdWl0ZSk7XFxuICB9XFxuXFxuICAvLyBiYWlsXFxuICB0aGlzLmVtaXQoJ2VuZCcpO1xcbn07XFxuXFxuLyoqXFxuICogQ2xlYW5zIHVwIHRoZSByZWZlcmVuY2VzIHRvIGFsbCB0aGUgZGVmZXJyZWQgZnVuY3Rpb25zXFxuICogKGJlZm9yZS9hZnRlci9iZWZvcmVFYWNoL2FmdGVyRWFjaCkgYW5kIHRlc3RzIG9mIGEgU3VpdGUuXFxuICogVGhlc2UgbXVzdCBiZSBkZWxldGVkIG90aGVyd2lzZSBhIG1lbW9yeSBsZWFrIGNhbiBoYXBwZW4sXFxuICogYXMgdGhvc2UgZnVuY3Rpb25zIG1heSByZWZlcmVuY2UgdmFyaWFibGVzIGZyb20gY2xvc3VyZXMsXFxuICogdGh1cyB0aG9zZSB2YXJpYWJsZXMgY2FuIG5ldmVyIGJlIGdhcmJhZ2UgY29sbGVjdGVkIGFzIGxvbmdcXG4gKiBhcyB0aGUgZGVmZXJyZWQgZnVuY3Rpb25zIGV4aXN0LlxcbiAqXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcXG4gKi9cXG5mdW5jdGlvbiBjbGVhblN1aXRlUmVmZXJlbmNlcyAoc3VpdGUpIHtcXG4gIGZ1bmN0aW9uIGNsZWFuQXJyUmVmZXJlbmNlcyAoYXJyKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgZGVsZXRlIGFycltpXS5mbjtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3VpdGUuX2JlZm9yZUFsbCkpIHtcXG4gICAgY2xlYW5BcnJSZWZlcmVuY2VzKHN1aXRlLl9iZWZvcmVBbGwpO1xcbiAgfVxcblxcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3VpdGUuX2JlZm9yZUVhY2gpKSB7XFxuICAgIGNsZWFuQXJyUmVmZXJlbmNlcyhzdWl0ZS5fYmVmb3JlRWFjaCk7XFxuICB9XFxuXFxuICBpZiAoQXJyYXkuaXNBcnJheShzdWl0ZS5fYWZ0ZXJBbGwpKSB7XFxuICAgIGNsZWFuQXJyUmVmZXJlbmNlcyhzdWl0ZS5fYWZ0ZXJBbGwpO1xcbiAgfVxcblxcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3VpdGUuX2FmdGVyRWFjaCkpIHtcXG4gICAgY2xlYW5BcnJSZWZlcmVuY2VzKHN1aXRlLl9hZnRlckVhY2gpO1xcbiAgfVxcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWl0ZS50ZXN0cy5sZW5ndGg7IGkrKykge1xcbiAgICBkZWxldGUgc3VpdGUudGVzdHNbaV0uZm47XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIFJ1biB0aGUgcm9vdCBzdWl0ZSBhbmQgaW52b2tlIGBmbihmYWlsdXJlcylgXFxuICogb24gY29tcGxldGlvbi5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqIEBtZW1iZXJvZiBNb2NoYS5SdW5uZXJcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge1J1bm5lcn0gUnVubmVyIGluc3RhbmNlLlxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKGZuKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgcm9vdFN1aXRlID0gdGhpcy5zdWl0ZTtcXG5cXG4gIGZuID0gZm4gfHwgZnVuY3Rpb24gKCkge307XFxuXFxuICBmdW5jdGlvbiB1bmNhdWdodCAoZXJyKSB7XFxuICAgIHNlbGYudW5jYXVnaHQoZXJyKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHN0YXJ0ICgpIHtcXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gYG9ubHlgIGZpbHRlclxcbiAgICBpZiAoaGFzT25seShyb290U3VpdGUpKSB7XFxuICAgICAgZmlsdGVyT25seShyb290U3VpdGUpO1xcbiAgICB9XFxuICAgIHNlbGYuc3RhcnRlZCA9IHRydWU7XFxuICAgIHNlbGYuZW1pdCgnc3RhcnQnKTtcXG4gICAgc2VsZi5ydW5TdWl0ZShyb290U3VpdGUsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBkZWJ1ZygnZmluaXNoZWQgcnVubmluZycpO1xcbiAgICAgIHNlbGYuZW1pdCgnZW5kJyk7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgZGVidWcoJ3N0YXJ0Jyk7XFxuXFxuICAvLyByZWZlcmVuY2VzIGNsZWFudXAgdG8gYXZvaWQgbWVtb3J5IGxlYWtzXFxuICB0aGlzLm9uKCdzdWl0ZSBlbmQnLCBjbGVhblN1aXRlUmVmZXJlbmNlcyk7XFxuXFxuICAvLyBjYWxsYmFja1xcbiAgdGhpcy5vbignZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBkZWJ1ZygnZW5kJyk7XFxuICAgIHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoJ3VuY2F1Z2h0RXhjZXB0aW9uJywgdW5jYXVnaHQpO1xcbiAgICBmbihzZWxmLmZhaWx1cmVzKTtcXG4gIH0pO1xcblxcbiAgLy8gdW5jYXVnaHQgZXhjZXB0aW9uXFxuICBwcm9jZXNzLm9uKCd1bmNhdWdodEV4Y2VwdGlvbicsIHVuY2F1Z2h0KTtcXG5cXG4gIGlmICh0aGlzLl9kZWxheSkge1xcbiAgICAvLyBmb3IgcmVwb3J0ZXJzLCBJIGd1ZXNzLlxcbiAgICAvLyBtaWdodCBiZSBuaWNlIHRvIGRlYm91bmNlIHNvbWUgZG90cyB3aGlsZSB3ZSB3YWl0LlxcbiAgICB0aGlzLmVtaXQoJ3dhaXRpbmcnLCByb290U3VpdGUpO1xcbiAgICByb290U3VpdGUub25jZSgncnVuJywgc3RhcnQpO1xcbiAgfSBlbHNlIHtcXG4gICAgc3RhcnQoKTtcXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogQ2xlYW5seSBhYm9ydCBleGVjdXRpb24uXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGEuUnVubmVyXFxuICogQHB1YmxpY1xcbiAqIEBhcGkgcHVibGljXFxuICogQHJldHVybiB7UnVubmVyfSBSdW5uZXIgaW5zdGFuY2UuXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcXG4gIGRlYnVnKCdhYm9ydGluZycpO1xcbiAgdGhpcy5fYWJvcnQgPSB0cnVlO1xcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBGaWx0ZXIgc3VpdGVzIGJhc2VkIG9uIGBpc09ubHlgIGxvZ2ljLlxcbiAqXFxuICogQHBhcmFtIHtBcnJheX0gc3VpdGVcXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5mdW5jdGlvbiBmaWx0ZXJPbmx5IChzdWl0ZSkge1xcbiAgaWYgKHN1aXRlLl9vbmx5VGVzdHMubGVuZ3RoKSB7XFxuICAgIC8vIElmIHRoZSBzdWl0ZSBjb250YWlucyBgb25seWAgdGVzdHMsIHJ1biB0aG9zZSBhbmQgaWdub3JlIGFueSBuZXN0ZWQgc3VpdGVzLlxcbiAgICBzdWl0ZS50ZXN0cyA9IHN1aXRlLl9vbmx5VGVzdHM7XFxuICAgIHN1aXRlLnN1aXRlcyA9IFtdO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gT3RoZXJ3aXNlLCBkbyBub3QgcnVuIGFueSBvZiB0aGUgdGVzdHMgaW4gdGhpcyBzdWl0ZS5cXG4gICAgc3VpdGUudGVzdHMgPSBbXTtcXG4gICAgc3VpdGUuX29ubHlTdWl0ZXMuZm9yRWFjaChmdW5jdGlvbiAob25seVN1aXRlKSB7XFxuICAgICAgLy8gSWYgdGhlcmUgYXJlIG90aGVyIGBvbmx5YCB0ZXN0cy9zdWl0ZXMgbmVzdGVkIGluIHRoZSBjdXJyZW50IGBvbmx5YCBzdWl0ZSwgdGhlbiBmaWx0ZXIgdGhhdCBgb25seWAgc3VpdGUuXFxuICAgICAgLy8gT3RoZXJ3aXNlLCBhbGwgb2YgdGhlIHRlc3RzIG9uIHRoaXMgYG9ubHlgIHN1aXRlIHNob3VsZCBiZSBydW4sIHNvIGRvbid0IGZpbHRlciBpdC5cXG4gICAgICBpZiAoaGFzT25seShvbmx5U3VpdGUpKSB7XFxuICAgICAgICBmaWx0ZXJPbmx5KG9ubHlTdWl0ZSk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gICAgLy8gUnVuIHRoZSBgb25seWAgc3VpdGVzLCBhcyB3ZWxsIGFzIGFueSBvdGhlciBzdWl0ZXMgdGhhdCBoYXZlIGBvbmx5YCB0ZXN0cy9zdWl0ZXMgYXMgZGVzY2VuZGFudHMuXFxuICAgIHN1aXRlLnN1aXRlcyA9IHN1aXRlLnN1aXRlcy5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkU3VpdGUpIHtcXG4gICAgICByZXR1cm4gc3VpdGUuX29ubHlTdWl0ZXMuaW5kZXhPZihjaGlsZFN1aXRlKSAhPT0gLTEgfHwgZmlsdGVyT25seShjaGlsZFN1aXRlKTtcXG4gICAgfSk7XFxuICB9XFxuICAvLyBLZWVwIHRoZSBzdWl0ZSBvbmx5IGlmIHRoZXJlIGlzIHNvbWV0aGluZyB0byBydW5cXG4gIHJldHVybiBzdWl0ZS50ZXN0cy5sZW5ndGggfHwgc3VpdGUuc3VpdGVzLmxlbmd0aDtcXG59XFxuXFxuLyoqXFxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgc3VpdGUgaGFzIGFuIGBvbmx5YCB0ZXN0IG9yIHN1aXRlIGFzIGEgZGVzY2VuZGFudC5cXG4gKlxcbiAqIEBwYXJhbSB7QXJyYXl9IHN1aXRlXFxuICogQHJldHVybnMge0Jvb2xlYW59XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuZnVuY3Rpb24gaGFzT25seSAoc3VpdGUpIHtcXG4gIHJldHVybiBzdWl0ZS5fb25seVRlc3RzLmxlbmd0aCB8fCBzdWl0ZS5fb25seVN1aXRlcy5sZW5ndGggfHwgc3VpdGUuc3VpdGVzLnNvbWUoaGFzT25seSk7XFxufVxcblxcbi8qKlxcbiAqIEZpbHRlciBsZWFrcyB3aXRoIHRoZSBnaXZlbiBnbG9iYWxzIGZsYWdnZWQgYXMgYG9rYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7QXJyYXl9IG9rXFxuICogQHBhcmFtIHtBcnJheX0gZ2xvYmFsc1xcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqL1xcbmZ1bmN0aW9uIGZpbHRlckxlYWtzIChvaywgZ2xvYmFscykge1xcbiAgcmV0dXJuIGdsb2JhbHMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgLy8gRmlyZWZveCBhbmQgQ2hyb21lIGV4cG9zZXMgaWZyYW1lcyBhcyBpbmRleCBpbnNpZGUgdGhlIHdpbmRvdyBvYmplY3RcXG4gICAgaWYgKC9eXFxcXGQrLy50ZXN0KGtleSkpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgLy8gaW4gZmlyZWZveFxcbiAgICAvLyBpZiBydW5uZXIgcnVucyBpbiBhbiBpZnJhbWUsIHRoaXMgaWZyYW1lJ3Mgd2luZG93LmdldEludGVyZmFjZSBtZXRob2RcXG4gICAgLy8gbm90IGluaXQgYXQgZmlyc3QgaXQgaXMgYXNzaWduZWQgaW4gc29tZSBzZWNvbmRzXFxuICAgIGlmIChnbG9iYWwubmF2aWdhdG9yICYmICgvXmdldEludGVyZmFjZS8pLnRlc3Qoa2V5KSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICAvLyBhbiBpZnJhbWUgY291bGQgYmUgYXBwcm9hY2hlZCBieSB3aW5kb3dbaWZyYW1lSW5kZXhdXFxuICAgIC8vIGluIGllNiw3LDggYW5kIG9wZXJhLCBpZnJhbWVJbmRleCBpcyBlbnVtZXJhYmxlLCB0aGlzIGNvdWxkIGNhdXNlIGxlYWtcXG4gICAgaWYgKGdsb2JhbC5uYXZpZ2F0b3IgJiYgKC9eXFxcXGQrLykudGVzdChrZXkpKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIC8vIE9wZXJhIGFuZCBJRSBleHBvc2UgZ2xvYmFsIHZhcmlhYmxlcyBmb3IgSFRNTCBlbGVtZW50IElEcyAoaXNzdWUgIzI0MylcXG4gICAgaWYgKC9ebW9jaGEtLy50ZXN0KGtleSkpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgdmFyIG1hdGNoZWQgPSBvay5maWx0ZXIoZnVuY3Rpb24gKG9rKSB7XFxuICAgICAgaWYgKH5vay5pbmRleE9mKCcqJykpIHtcXG4gICAgICAgIHJldHVybiBrZXkuaW5kZXhPZihvay5zcGxpdCgnKicpWzBdKSA9PT0gMDtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGtleSA9PT0gb2s7XFxuICAgIH0pO1xcbiAgICByZXR1cm4gIW1hdGNoZWQubGVuZ3RoICYmICghZ2xvYmFsLm5hdmlnYXRvciB8fCBrZXkgIT09ICdvbmVycm9yJyk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogQXJyYXkgb2YgZ2xvYmFscyBkZXBlbmRlbnQgb24gdGhlIGVudmlyb25tZW50LlxcbiAqXFxuICogQHJldHVybiB7QXJyYXl9XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuZnVuY3Rpb24gZXh0cmFHbG9iYWxzICgpIHtcXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcXG4gICAgdmFyIHBhcnRzID0gcHJvY2Vzcy52ZXJzaW9uLnNwbGl0KCcuJyk7XFxuICAgIHZhciBub2RlVmVyc2lvbiA9IHBhcnRzLnJlZHVjZShmdW5jdGlvbiAoYSwgdikge1xcbiAgICAgIHJldHVybiBhIDw8IDggfCB2O1xcbiAgICB9KTtcXG5cXG4gICAgLy8gJ2Vycm5vJyB3YXMgcmVuYW1lZCB0byBwcm9jZXNzLl9lcnJubyBpbiB2MC45LjExLlxcblxcbiAgICBpZiAobm9kZVZlcnNpb24gPCAweDAwMDkwQikge1xcbiAgICAgIHJldHVybiBbJ2Vycm5vJ107XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBbXTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi9wZW5kaW5nXFxcIjoxNSxcXFwiLi9ydW5uYWJsZVxcXCI6MzIsXFxcIi4vdXRpbHNcXFwiOjM2LFxcXCJfcHJvY2Vzc1xcXCI6NTYsXFxcImRlYnVnXFxcIjo0MyxcXFwiZXZlbnRzXFxcIjo0N31dLDM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBTdWl0ZVxcbiAqL1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcXG52YXIgSG9vayA9IHJlcXVpcmUoJy4vaG9vaycpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcXG52YXIgaW5oZXJpdHMgPSB1dGlscy5pbmhlcml0cztcXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb2NoYTpzdWl0ZScpO1xcbnZhciBtaWxsaXNlY29uZHMgPSByZXF1aXJlKCcuL21zJyk7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBTdWl0ZWAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gU3VpdGU7XFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IGBTdWl0ZWAgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgcGFyZW50IGBTdWl0ZWAuIFdoZW4gYSBzdWl0ZVxcbiAqIHdpdGggdGhlIHNhbWUgdGl0bGUgaXMgYWxyZWFkeSBwcmVzZW50LCB0aGF0IHN1aXRlIGlzIHJldHVybmVkIHRvIHByb3ZpZGVcXG4gKiBuaWNlciByZXBvcnRlciBhbmQgbW9yZSBmbGV4aWJsZSBtZXRhLXRlc3RpbmcuXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGFcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1N1aXRlfSBwYXJlbnRcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gKiBAcmV0dXJuIHtTdWl0ZX1cXG4gKi9cXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIChwYXJlbnQsIHRpdGxlKSB7XFxuICB2YXIgc3VpdGUgPSBuZXcgU3VpdGUodGl0bGUsIHBhcmVudC5jdHgpO1xcbiAgc3VpdGUucGFyZW50ID0gcGFyZW50O1xcbiAgdGl0bGUgPSBzdWl0ZS5mdWxsVGl0bGUoKTtcXG4gIHBhcmVudC5hZGRTdWl0ZShzdWl0ZSk7XFxuICByZXR1cm4gc3VpdGU7XFxufTtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBTdWl0ZWAgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgYGN0eGAuIERlcml2ZWQgZnJvbSBbRXZlbnRFbWl0dGVyXShodHRwczovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2V2ZW50c19jbGFzc19ldmVudGVtaXR0ZXIpXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGFcXG4gKiBAcHVibGljXFxuICogQGNsYXNzXFxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXFxuICogQHBhcmFtIHtDb250ZXh0fSBwYXJlbnRDb250ZXh0XFxuICovXFxuZnVuY3Rpb24gU3VpdGUgKHRpdGxlLCBwYXJlbnRDb250ZXh0KSB7XFxuICBpZiAoIXV0aWxzLmlzU3RyaW5nKHRpdGxlKSkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1aXRlIGB0aXRsZWAgc2hvdWxkIGJlIGEgXFxcInN0cmluZ1xcXCIgYnV0IFxcXCInICsgdHlwZW9mIHRpdGxlICsgJ1xcXCIgd2FzIGdpdmVuIGluc3RlYWQuJyk7XFxuICB9XFxuICB0aGlzLnRpdGxlID0gdGl0bGU7XFxuICBmdW5jdGlvbiBDb250ZXh0ICgpIHt9XFxuICBDb250ZXh0LnByb3RvdHlwZSA9IHBhcmVudENvbnRleHQ7XFxuICB0aGlzLmN0eCA9IG5ldyBDb250ZXh0KCk7XFxuICB0aGlzLnN1aXRlcyA9IFtdO1xcbiAgdGhpcy50ZXN0cyA9IFtdO1xcbiAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XFxuICB0aGlzLl9iZWZvcmVFYWNoID0gW107XFxuICB0aGlzLl9iZWZvcmVBbGwgPSBbXTtcXG4gIHRoaXMuX2FmdGVyRWFjaCA9IFtdO1xcbiAgdGhpcy5fYWZ0ZXJBbGwgPSBbXTtcXG4gIHRoaXMucm9vdCA9ICF0aXRsZTtcXG4gIHRoaXMuX3RpbWVvdXQgPSAyMDAwO1xcbiAgdGhpcy5fZW5hYmxlVGltZW91dHMgPSB0cnVlO1xcbiAgdGhpcy5fc2xvdyA9IDc1O1xcbiAgdGhpcy5fYmFpbCA9IGZhbHNlO1xcbiAgdGhpcy5fcmV0cmllcyA9IC0xO1xcbiAgdGhpcy5fb25seVRlc3RzID0gW107XFxuICB0aGlzLl9vbmx5U3VpdGVzID0gW107XFxuICB0aGlzLmRlbGF5ZWQgPSBmYWxzZTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBFdmVudEVtaXR0ZXIucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhTdWl0ZSwgRXZlbnRFbWl0dGVyKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBjbG9uZSBvZiB0aGlzIGBTdWl0ZWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcmV0dXJuIHtTdWl0ZX1cXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc3VpdGUgPSBuZXcgU3VpdGUodGhpcy50aXRsZSk7XFxuICBkZWJ1ZygnY2xvbmUnKTtcXG4gIHN1aXRlLmN0eCA9IHRoaXMuY3R4O1xcbiAgc3VpdGUudGltZW91dCh0aGlzLnRpbWVvdXQoKSk7XFxuICBzdWl0ZS5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcXG4gIHN1aXRlLmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICBzdWl0ZS5zbG93KHRoaXMuc2xvdygpKTtcXG4gIHN1aXRlLmJhaWwodGhpcy5iYWlsKCkpO1xcbiAgcmV0dXJuIHN1aXRlO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IG9yIGdldCB0aW1lb3V0IGBtc2Agb3Igc2hvcnQtaGFuZCBzdWNoIGFzIFxcXCIyc1xcXCIuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG1zXFxuICogQHJldHVybiB7U3VpdGV8bnVtYmVyfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIChtcykge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl90aW1lb3V0O1xcbiAgfVxcbiAgaWYgKG1zLnRvU3RyaW5nKCkgPT09ICcwJykge1xcbiAgICB0aGlzLl9lbmFibGVUaW1lb3V0cyA9IGZhbHNlO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBtcyA9PT0gJ3N0cmluZycpIHtcXG4gICAgbXMgPSBtaWxsaXNlY29uZHMobXMpO1xcbiAgfVxcbiAgZGVidWcoJ3RpbWVvdXQgJWQnLCBtcyk7XFxuICB0aGlzLl90aW1lb3V0ID0gcGFyc2VJbnQobXMsIDEwKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IG9yIGdldCBudW1iZXIgb2YgdGltZXMgdG8gcmV0cnkgYSBmYWlsZWQgdGVzdC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gblxcbiAqIEByZXR1cm4ge1N1aXRlfG51bWJlcn0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLnJldHJpZXMgPSBmdW5jdGlvbiAobikge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9yZXRyaWVzO1xcbiAgfVxcbiAgZGVidWcoJ3JldHJpZXMgJWQnLCBuKTtcXG4gIHRoaXMuX3JldHJpZXMgPSBwYXJzZUludChuLCAxMCkgfHwgMDtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICAqIFNldCBvciBnZXQgdGltZW91dCB0byBgZW5hYmxlZGAuXFxuICAqXFxuICAqIEBhcGkgcHJpdmF0ZVxcbiAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcXG4gICogQHJldHVybiB7U3VpdGV8Ym9vbGVhbn0gc2VsZiBvciBlbmFibGVkXFxuICAqL1xcblN1aXRlLnByb3RvdHlwZS5lbmFibGVUaW1lb3V0cyA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2VuYWJsZVRpbWVvdXRzO1xcbiAgfVxcbiAgZGVidWcoJ2VuYWJsZVRpbWVvdXRzICVzJywgZW5hYmxlZCk7XFxuICB0aGlzLl9lbmFibGVUaW1lb3V0cyA9IGVuYWJsZWQ7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBvciBnZXQgc2xvdyBgbXNgIG9yIHNob3J0LWhhbmQgc3VjaCBhcyBcXFwiMnNcXFwiLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBtc1xcbiAqIEByZXR1cm4ge1N1aXRlfG51bWJlcn0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLnNsb3cgPSBmdW5jdGlvbiAobXMpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fc2xvdztcXG4gIH1cXG4gIGlmICh0eXBlb2YgbXMgPT09ICdzdHJpbmcnKSB7XFxuICAgIG1zID0gbWlsbGlzZWNvbmRzKG1zKTtcXG4gIH1cXG4gIGRlYnVnKCdzbG93ICVkJywgbXMpO1xcbiAgdGhpcy5fc2xvdyA9IG1zO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgb3IgZ2V0IHdoZXRoZXIgdG8gYmFpbCBhZnRlciBmaXJzdCBlcnJvci5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYmFpbFxcbiAqIEByZXR1cm4ge1N1aXRlfG51bWJlcn0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmJhaWwgPSBmdW5jdGlvbiAoYmFpbCkge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9iYWlsO1xcbiAgfVxcbiAgZGVidWcoJ2JhaWwgJXMnLCBiYWlsKTtcXG4gIHRoaXMuX2JhaWwgPSBiYWlsO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0aGlzIHN1aXRlIG9yIGl0cyBwYXJlbnQgc3VpdGUgaXMgbWFya2VkIGFzIHBlbmRpbmcuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIHRoaXMucGVuZGluZyB8fCAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaXNQZW5kaW5nKCkpO1xcbn07XFxuXFxuLyoqXFxuICogR2VuZXJpYyBob29rLWNyZWF0b3IuXFxuICogQHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGUgLSBUaXRsZSBvZiBob29rXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBIb29rIGNhbGxiYWNrXFxuICogQHJldHVybnMge0hvb2t9IEEgbmV3IGhvb2tcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuX2NyZWF0ZUhvb2sgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICB2YXIgaG9vayA9IG5ldyBIb29rKHRpdGxlLCBmbik7XFxuICBob29rLnBhcmVudCA9IHRoaXM7XFxuICBob29rLnRpbWVvdXQodGhpcy50aW1lb3V0KCkpO1xcbiAgaG9vay5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcXG4gIGhvb2suZW5hYmxlVGltZW91dHModGhpcy5lbmFibGVUaW1lb3V0cygpKTtcXG4gIGhvb2suc2xvdyh0aGlzLnNsb3coKSk7XFxuICBob29rLmN0eCA9IHRoaXMuY3R4O1xcbiAgaG9vay5maWxlID0gdGhpcy5maWxlO1xcbiAgcmV0dXJuIGhvb2s7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gYGZuKHRlc3RbLCBkb25lXSlgIGJlZm9yZSBydW5uaW5nIHRlc3RzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcmV0dXJuIHtTdWl0ZX0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmJlZm9yZUFsbCA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gIGlmICh0aGlzLmlzUGVuZGluZygpKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiB0aXRsZSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBmbiA9IHRpdGxlO1xcbiAgICB0aXRsZSA9IGZuLm5hbWU7XFxuICB9XFxuICB0aXRsZSA9ICdcXFwiYmVmb3JlIGFsbFxcXCIgaG9vaycgKyAodGl0bGUgPyAnOiAnICsgdGl0bGUgOiAnJyk7XFxuXFxuICB2YXIgaG9vayA9IHRoaXMuX2NyZWF0ZUhvb2sodGl0bGUsIGZuKTtcXG4gIHRoaXMuX2JlZm9yZUFsbC5wdXNoKGhvb2spO1xcbiAgdGhpcy5lbWl0KCdiZWZvcmVBbGwnLCBob29rKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIGBmbih0ZXN0WywgZG9uZV0pYCBhZnRlciBydW5uaW5nIHRlc3RzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcmV0dXJuIHtTdWl0ZX0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmFmdGVyQWxsID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgaWYgKHRoaXMuaXNQZW5kaW5nKCkpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICBpZiAodHlwZW9mIHRpdGxlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGZuID0gdGl0bGU7XFxuICAgIHRpdGxlID0gZm4ubmFtZTtcXG4gIH1cXG4gIHRpdGxlID0gJ1xcXCJhZnRlciBhbGxcXFwiIGhvb2snICsgKHRpdGxlID8gJzogJyArIHRpdGxlIDogJycpO1xcblxcbiAgdmFyIGhvb2sgPSB0aGlzLl9jcmVhdGVIb29rKHRpdGxlLCBmbik7XFxuICB0aGlzLl9hZnRlckFsbC5wdXNoKGhvb2spO1xcbiAgdGhpcy5lbWl0KCdhZnRlckFsbCcsIGhvb2spO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gYGZuKHRlc3RbLCBkb25lXSlgIGJlZm9yZSBlYWNoIHRlc3QgY2FzZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5iZWZvcmVFYWNoID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgaWYgKHRoaXMuaXNQZW5kaW5nKCkpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICBpZiAodHlwZW9mIHRpdGxlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGZuID0gdGl0bGU7XFxuICAgIHRpdGxlID0gZm4ubmFtZTtcXG4gIH1cXG4gIHRpdGxlID0gJ1xcXCJiZWZvcmUgZWFjaFxcXCIgaG9vaycgKyAodGl0bGUgPyAnOiAnICsgdGl0bGUgOiAnJyk7XFxuXFxuICB2YXIgaG9vayA9IHRoaXMuX2NyZWF0ZUhvb2sodGl0bGUsIGZuKTtcXG4gIHRoaXMuX2JlZm9yZUVhY2gucHVzaChob29rKTtcXG4gIHRoaXMuZW1pdCgnYmVmb3JlRWFjaCcsIGhvb2spO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gYGZuKHRlc3RbLCBkb25lXSlgIGFmdGVyIGVhY2ggdGVzdCBjYXNlLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcmV0dXJuIHtTdWl0ZX0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmFmdGVyRWFjaCA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gIGlmICh0aGlzLmlzUGVuZGluZygpKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiB0aXRsZSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBmbiA9IHRpdGxlO1xcbiAgICB0aXRsZSA9IGZuLm5hbWU7XFxuICB9XFxuICB0aXRsZSA9ICdcXFwiYWZ0ZXIgZWFjaFxcXCIgaG9vaycgKyAodGl0bGUgPyAnOiAnICsgdGl0bGUgOiAnJyk7XFxuXFxuICB2YXIgaG9vayA9IHRoaXMuX2NyZWF0ZUhvb2sodGl0bGUsIGZuKTtcXG4gIHRoaXMuX2FmdGVyRWFjaC5wdXNoKGhvb2spO1xcbiAgdGhpcy5lbWl0KCdhZnRlckVhY2gnLCBob29rKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogQWRkIGEgdGVzdCBgc3VpdGVgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcXG4gKiBAcmV0dXJuIHtTdWl0ZX0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmFkZFN1aXRlID0gZnVuY3Rpb24gKHN1aXRlKSB7XFxuICBzdWl0ZS5wYXJlbnQgPSB0aGlzO1xcbiAgc3VpdGUudGltZW91dCh0aGlzLnRpbWVvdXQoKSk7XFxuICBzdWl0ZS5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcXG4gIHN1aXRlLmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICBzdWl0ZS5zbG93KHRoaXMuc2xvdygpKTtcXG4gIHN1aXRlLmJhaWwodGhpcy5iYWlsKCkpO1xcbiAgdGhpcy5zdWl0ZXMucHVzaChzdWl0ZSk7XFxuICB0aGlzLmVtaXQoJ3N1aXRlJywgc3VpdGUpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBBZGQgYSBgdGVzdGAgdG8gdGhpcyBzdWl0ZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7VGVzdH0gdGVzdFxcbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuYWRkVGVzdCA9IGZ1bmN0aW9uICh0ZXN0KSB7XFxuICB0ZXN0LnBhcmVudCA9IHRoaXM7XFxuICB0ZXN0LnRpbWVvdXQodGhpcy50aW1lb3V0KCkpO1xcbiAgdGVzdC5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcXG4gIHRlc3QuZW5hYmxlVGltZW91dHModGhpcy5lbmFibGVUaW1lb3V0cygpKTtcXG4gIHRlc3Quc2xvdyh0aGlzLnNsb3coKSk7XFxuICB0ZXN0LmN0eCA9IHRoaXMuY3R4O1xcbiAgdGhpcy50ZXN0cy5wdXNoKHRlc3QpO1xcbiAgdGhpcy5lbWl0KCd0ZXN0JywgdGVzdCk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybiB0aGUgZnVsbCB0aXRsZSBnZW5lcmF0ZWQgYnkgcmVjdXJzaXZlbHkgY29uY2F0ZW5hdGluZyB0aGUgcGFyZW50J3NcXG4gKiBmdWxsIHRpdGxlLlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhLlN1aXRlXFxuICogQHB1YmxpY1xcbiAqIEBhcGkgcHVibGljXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5mdWxsVGl0bGUgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gdGhpcy50aXRsZVBhdGgoKS5qb2luKCcgJyk7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gdGhlIHRpdGxlIHBhdGggZ2VuZXJhdGVkIGJ5IHJlY3Vyc2l2ZWx5IGNvbmNhdGVuYXRpbmcgdGhlIHBhcmVudCdzXFxuICogdGl0bGUgcGF0aC5cXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYS5TdWl0ZVxcbiAqIEBwdWJsaWNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUudGl0bGVQYXRoID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHJlc3VsdCA9IFtdO1xcbiAgaWYgKHRoaXMucGFyZW50KSB7XFxuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5wYXJlbnQudGl0bGVQYXRoKCkpO1xcbiAgfVxcbiAgaWYgKCF0aGlzLnJvb3QpIHtcXG4gICAgcmVzdWx0LnB1c2godGhpcy50aXRsZSk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIHRoZSB0b3RhbCBudW1iZXIgb2YgdGVzdHMuXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGEuU3VpdGVcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9XFxuICovXFxuU3VpdGUucHJvdG90eXBlLnRvdGFsID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIHRoaXMuc3VpdGVzLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBzdWl0ZSkge1xcbiAgICByZXR1cm4gc3VtICsgc3VpdGUudG90YWwoKTtcXG4gIH0sIDApICsgdGhpcy50ZXN0cy5sZW5ndGg7XFxufTtcXG5cXG4vKipcXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGVhY2ggc3VpdGUgcmVjdXJzaXZlbHkgdG8gZmluZCBhbGwgdGVzdHMuIEFwcGxpZXMgYVxcbiAqIGZ1bmN0aW9uIGluIHRoZSBmb3JtYXQgYGZuKHRlc3QpYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7U3VpdGV9XFxuICovXFxuU3VpdGUucHJvdG90eXBlLmVhY2hUZXN0ID0gZnVuY3Rpb24gKGZuKSB7XFxuICB0aGlzLnRlc3RzLmZvckVhY2goZm4pO1xcbiAgdGhpcy5zdWl0ZXMuZm9yRWFjaChmdW5jdGlvbiAoc3VpdGUpIHtcXG4gICAgc3VpdGUuZWFjaFRlc3QoZm4pO1xcbiAgfSk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFRoaXMgd2lsbCBydW4gdGhlIHJvb3Qgc3VpdGUgaWYgd2UgaGFwcGVuIHRvIGJlIHJ1bm5pbmcgaW4gZGVsYXllZCBtb2RlLlxcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xcbiAgaWYgKHRoaXMucm9vdCkge1xcbiAgICB0aGlzLmVtaXQoJ3J1bicpO1xcbiAgfVxcbn07XFxuXFxufSx7XFxcIi4vaG9va1xcXCI6NixcXFwiLi9tc1xcXCI6MTQsXFxcIi4vdXRpbHNcXFwiOjM2LFxcXCJkZWJ1Z1xcXCI6NDMsXFxcImV2ZW50c1xcXCI6NDd9XSwzNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIFJ1bm5hYmxlID0gcmVxdWlyZSgnLi9ydW5uYWJsZScpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcXG52YXIgaXNTdHJpbmcgPSB1dGlscy5pc1N0cmluZztcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFRlc3RgLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gVGVzdDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBUZXN0YCB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKi9cXG5mdW5jdGlvbiBUZXN0ICh0aXRsZSwgZm4pIHtcXG4gIGlmICghaXNTdHJpbmcodGl0bGUpKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcignVGVzdCBgdGl0bGVgIHNob3VsZCBiZSBhIFxcXCJzdHJpbmdcXFwiIGJ1dCBcXFwiJyArIHR5cGVvZiB0aXRsZSArICdcXFwiIHdhcyBnaXZlbiBpbnN0ZWFkLicpO1xcbiAgfVxcbiAgUnVubmFibGUuY2FsbCh0aGlzLCB0aXRsZSwgZm4pO1xcbiAgdGhpcy5wZW5kaW5nID0gIWZuO1xcbiAgdGhpcy50eXBlID0gJ3Rlc3QnO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYFJ1bm5hYmxlLnByb3RvdHlwZWAuXFxuICovXFxudXRpbHMuaW5oZXJpdHMoVGVzdCwgUnVubmFibGUpO1xcblxcblRlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHRlc3QgPSBuZXcgVGVzdCh0aGlzLnRpdGxlLCB0aGlzLmZuKTtcXG4gIHRlc3QudGltZW91dCh0aGlzLnRpbWVvdXQoKSk7XFxuICB0ZXN0LnNsb3codGhpcy5zbG93KCkpO1xcbiAgdGVzdC5lbmFibGVUaW1lb3V0cyh0aGlzLmVuYWJsZVRpbWVvdXRzKCkpO1xcbiAgdGVzdC5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcXG4gIHRlc3QuY3VycmVudFJldHJ5KHRoaXMuY3VycmVudFJldHJ5KCkpO1xcbiAgdGVzdC5nbG9iYWxzKHRoaXMuZ2xvYmFscygpKTtcXG4gIHRlc3QucGFyZW50ID0gdGhpcy5wYXJlbnQ7XFxuICB0ZXN0LmZpbGUgPSB0aGlzLmZpbGU7XFxuICB0ZXN0LmN0eCA9IHRoaXMuY3R4O1xcbiAgcmV0dXJuIHRlc3Q7XFxufTtcXG5cXG59LHtcXFwiLi9ydW5uYWJsZVxcXCI6MzIsXFxcIi4vdXRpbHNcXFwiOjM2fV0sMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxCdWZmZXIpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBAbW9kdWxlXFxuICovXFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb2NoYTp3YXRjaCcpO1xcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XFxudmFyIGdsb2IgPSByZXF1aXJlKCdnbG9iJyk7XFxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XFxudmFyIGpvaW4gPSBwYXRoLmpvaW47XFxudmFyIGhlID0gcmVxdWlyZSgnaGUnKTtcXG5cXG4vKipcXG4gKiBJZ25vcmVkIGRpcmVjdG9yaWVzLlxcbiAqL1xcblxcbnZhciBpZ25vcmUgPSBbJ25vZGVfbW9kdWxlcycsICcuZ2l0J107XFxuXFxuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcXG5cXG4vKipcXG4gKiBFc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIHRoZSBnaXZlbiBzdHJpbmcgb2YgaHRtbC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSAge3N0cmluZ30gaHRtbFxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5leHBvcnRzLmVzY2FwZSA9IGZ1bmN0aW9uIChodG1sKSB7XFxuICByZXR1cm4gaGUuZW5jb2RlKFN0cmluZyhodG1sKSwgeyB1c2VOYW1lZFJlZmVyZW5jZXM6IGZhbHNlIH0pO1xcbn07XFxuXFxuLyoqXFxuICogVGVzdCBpZiB0aGUgZ2l2ZW4gb2JqIGlzIHR5cGUgb2Ygc3RyaW5nLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XFxuICovXFxuZXhwb3J0cy5pc1N0cmluZyA9IGZ1bmN0aW9uIChvYmopIHtcXG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJztcXG59O1xcblxcbi8qKlxcbiAqIFdhdGNoIHRoZSBnaXZlbiBgZmlsZXNgIGZvciBjaGFuZ2VzXFxuICogYW5kIGludm9rZSBgZm4oZmlsZSlgIG9uIG1vZGlmaWNhdGlvbi5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7QXJyYXl9IGZpbGVzXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKi9cXG5leHBvcnRzLndhdGNoID0gZnVuY3Rpb24gKGZpbGVzLCBmbikge1xcbiAgdmFyIG9wdGlvbnMgPSB7IGludGVydmFsOiAxMDAgfTtcXG4gIGZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcXG4gICAgZGVidWcoJ2ZpbGUgJXMnLCBmaWxlKTtcXG4gICAgZnMud2F0Y2hGaWxlKGZpbGUsIG9wdGlvbnMsIGZ1bmN0aW9uIChjdXJyLCBwcmV2KSB7XFxuICAgICAgaWYgKHByZXYubXRpbWUgPCBjdXJyLm10aW1lKSB7XFxuICAgICAgICBmbihmaWxlKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBJZ25vcmVkIGZpbGVzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcXG4gKiBAcmV0dXJuIHtib29sZWFufVxcbiAqL1xcbmZ1bmN0aW9uIGlnbm9yZWQgKHBhdGgpIHtcXG4gIHJldHVybiAhfmlnbm9yZS5pbmRleE9mKHBhdGgpO1xcbn1cXG5cXG4vKipcXG4gKiBMb29rdXAgZmlsZXMgaW4gdGhlIGdpdmVuIGBkaXJgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IGRpclxcbiAqIEBwYXJhbSB7c3RyaW5nW119IFtleHQ9WycuanMnXV1cXG4gKiBAcGFyYW0ge0FycmF5fSBbcmV0PVtdXVxcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqL1xcbmV4cG9ydHMuZmlsZXMgPSBmdW5jdGlvbiAoZGlyLCBleHQsIHJldCkge1xcbiAgcmV0ID0gcmV0IHx8IFtdO1xcbiAgZXh0ID0gZXh0IHx8IFsnanMnXTtcXG5cXG4gIHZhciByZSA9IG5ldyBSZWdFeHAoJ1xcXFxcXFxcLignICsgZXh0LmpvaW4oJ3wnKSArICcpJCcpO1xcblxcbiAgZnMucmVhZGRpclN5bmMoZGlyKVxcbiAgICAuZmlsdGVyKGlnbm9yZWQpXFxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoKSB7XFxuICAgICAgcGF0aCA9IGpvaW4oZGlyLCBwYXRoKTtcXG4gICAgICBpZiAoZnMubHN0YXRTeW5jKHBhdGgpLmlzRGlyZWN0b3J5KCkpIHtcXG4gICAgICAgIGV4cG9ydHMuZmlsZXMocGF0aCwgZXh0LCByZXQpO1xcbiAgICAgIH0gZWxzZSBpZiAocGF0aC5tYXRjaChyZSkpIHtcXG4gICAgICAgIHJldC5wdXNoKHBhdGgpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuXFxuICByZXR1cm4gcmV0O1xcbn07XFxuXFxuLyoqXFxuICogQ29tcHV0ZSBhIHNsdWcgZnJvbSB0aGUgZ2l2ZW4gYHN0cmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmV4cG9ydHMuc2x1ZyA9IGZ1bmN0aW9uIChzdHIpIHtcXG4gIHJldHVybiBzdHJcXG4gICAgLnRvTG93ZXJDYXNlKClcXG4gICAgLnJlcGxhY2UoLyArL2csICctJylcXG4gICAgLnJlcGxhY2UoL1teLVxcXFx3XS9nLCAnJyk7XFxufTtcXG5cXG4vKipcXG4gKiBTdHJpcCB0aGUgZnVuY3Rpb24gZGVmaW5pdGlvbiBmcm9tIGBzdHJgLCBhbmQgcmUtaW5kZW50IGZvciBwcmUgd2hpdGVzcGFjZS5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZXhwb3J0cy5jbGVhbiA9IGZ1bmN0aW9uIChzdHIpIHtcXG4gIHN0ciA9IHN0clxcbiAgICAucmVwbGFjZSgvXFxcXHJcXFxcbj98W1xcXFxuXFxcXHUyMDI4XFxcXHUyMDI5XS9nLCAnXFxcXG4nKS5yZXBsYWNlKC9eXFxcXHVGRUZGLywgJycpXFxuICAgIC8vICh0cmFkaXRpb25hbCktPiAgc3BhY2UvbmFtZSAgICAgcGFyYW1ldGVycyAgICBib2R5ICAgICAobGFtYmRhKS0+IHBhcmFtZXRlcnMgICAgICAgYm9keSAgIG11bHRpLXN0YXRlbWVudC9zaW5nbGUgICAgICAgICAga2VlcCBib2R5IGNvbnRlbnRcXG4gICAgLnJlcGxhY2UoL15mdW5jdGlvbig/OlxcXFxzKnxcXFxccytbXihdKilcXFxcKFteKV0qXFxcXClcXFxccypcXFxceygoPzoufFxcXFxuKSo/KVxcXFxzKlxcXFx9JHxeXFxcXChbXildKlxcXFwpXFxcXHMqPT5cXFxccyooPzpcXFxceygoPzoufFxcXFxuKSo/KVxcXFxzKlxcXFx9fCgoPzoufFxcXFxuKSopKSQvLCAnJDEkMiQzJyk7XFxuXFxuICB2YXIgc3BhY2VzID0gc3RyLm1hdGNoKC9eXFxcXG4/KCAqKS8pWzFdLmxlbmd0aDtcXG4gIHZhciB0YWJzID0gc3RyLm1hdGNoKC9eXFxcXG4/KFxcXFx0KikvKVsxXS5sZW5ndGg7XFxuICB2YXIgcmUgPSBuZXcgUmVnRXhwKCdeXFxcXG4/JyArICh0YWJzID8gJ1xcXFx0JyA6ICcgJykgKyAneycgKyAodGFicyB8fCBzcGFjZXMpICsgJ30nLCAnZ20nKTtcXG5cXG4gIHN0ciA9IHN0ci5yZXBsYWNlKHJlLCAnJyk7XFxuXFxuICByZXR1cm4gc3RyLnRyaW0oKTtcXG59O1xcblxcbi8qKlxcbiAqIFBhcnNlIHRoZSBnaXZlbiBgcXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHFzXFxuICogQHJldHVybiB7T2JqZWN0fVxcbiAqL1xcbmV4cG9ydHMucGFyc2VRdWVyeSA9IGZ1bmN0aW9uIChxcykge1xcbiAgcmV0dXJuIHFzLnJlcGxhY2UoJz8nLCAnJykuc3BsaXQoJyYnKS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgcGFpcikge1xcbiAgICB2YXIgaSA9IHBhaXIuaW5kZXhPZignPScpO1xcbiAgICB2YXIga2V5ID0gcGFpci5zbGljZSgwLCBpKTtcXG4gICAgdmFyIHZhbCA9IHBhaXIuc2xpY2UoKytpKTtcXG5cXG4gICAgLy8gRHVlIHRvIGhvdyB0aGUgVVJMU2VhcmNoUGFyYW1zIEFQSSB0cmVhdHMgc3BhY2VzXFxuICAgIG9ialtrZXldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbC5yZXBsYWNlKC9cXFxcKy9nLCAnJTIwJykpO1xcblxcbiAgICByZXR1cm4gb2JqO1xcbiAgfSwge30pO1xcbn07XFxuXFxuLyoqXFxuICogSGlnaGxpZ2h0IHRoZSBnaXZlbiBzdHJpbmcgb2YgYGpzYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBqc1xcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiBoaWdobGlnaHQgKGpzKSB7XFxuICByZXR1cm4ganNcXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXFxuICAgIC5yZXBsYWNlKC9cXFxcL1xcXFwvKC4qKS9nbSwgJzxzcGFuIGNsYXNzPVxcXCJjb21tZW50XFxcIj4vLyQxPC9zcGFuPicpXFxuICAgIC5yZXBsYWNlKC8oJy4qPycpL2dtLCAnPHNwYW4gY2xhc3M9XFxcInN0cmluZ1xcXCI+JDE8L3NwYW4+JylcXG4gICAgLnJlcGxhY2UoLyhcXFxcZCtcXFxcLlxcXFxkKykvZ20sICc8c3BhbiBjbGFzcz1cXFwibnVtYmVyXFxcIj4kMTwvc3Bhbj4nKVxcbiAgICAucmVwbGFjZSgvKFxcXFxkKykvZ20sICc8c3BhbiBjbGFzcz1cXFwibnVtYmVyXFxcIj4kMTwvc3Bhbj4nKVxcbiAgICAucmVwbGFjZSgvXFxcXGJuZXdbIFxcXFx0XSsoXFxcXHcrKS9nbSwgJzxzcGFuIGNsYXNzPVxcXCJrZXl3b3JkXFxcIj5uZXc8L3NwYW4+IDxzcGFuIGNsYXNzPVxcXCJpbml0XFxcIj4kMTwvc3Bhbj4nKVxcbiAgICAucmVwbGFjZSgvXFxcXGIoZnVuY3Rpb258bmV3fHRocm93fHJldHVybnx2YXJ8aWZ8ZWxzZSlcXFxcYi9nbSwgJzxzcGFuIGNsYXNzPVxcXCJrZXl3b3JkXFxcIj4kMTwvc3Bhbj4nKTtcXG59XFxuXFxuLyoqXFxuICogSGlnaGxpZ2h0IHRoZSBjb250ZW50cyBvZiB0YWcgYG5hbWVgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gKi9cXG5leHBvcnRzLmhpZ2hsaWdodFRhZ3MgPSBmdW5jdGlvbiAobmFtZSkge1xcbiAgdmFyIGNvZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9jaGEnKS5nZXRFbGVtZW50c0J5VGFnTmFtZShuYW1lKTtcXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XFxuICAgIGNvZGVbaV0uaW5uZXJIVE1MID0gaGlnaGxpZ2h0KGNvZGVbaV0uaW5uZXJIVE1MKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIElmIGEgdmFsdWUgY291bGQgaGF2ZSBwcm9wZXJ0aWVzLCBhbmQgaGFzIG5vbmUsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLFxcbiAqIHdoaWNoIHJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVtcHR5IHZhbHVlLlxcbiAqXFxuICogRnVuY3Rpb25zIHcvIG5vIHByb3BlcnRpZXMgcmV0dXJuIGAnW0Z1bmN0aW9uXSdgXFxuICogQXJyYXlzIHcvIGxlbmd0aCA9PT0gMCByZXR1cm4gYCdbXSdgXFxuICogT2JqZWN0cyB3LyBubyBwcm9wZXJ0aWVzIHJldHVybiBgJ3t9J2BcXG4gKiBBbGwgZWxzZTogcmV0dXJuIHJlc3VsdCBvZiBgdmFsdWUudG9TdHJpbmcoKWBcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVIaW50IFRoZSB0eXBlIG9mIHRoZSB2YWx1ZVxcbiAqIEByZXR1cm5zIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gZW1wdHlSZXByZXNlbnRhdGlvbiAodmFsdWUsIHR5cGVIaW50KSB7XFxuICBzd2l0Y2ggKHR5cGVIaW50KSB7XFxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcXG4gICAgICByZXR1cm4gJ1tGdW5jdGlvbl0nO1xcbiAgICBjYXNlICdvYmplY3QnOlxcbiAgICAgIHJldHVybiAne30nO1xcbiAgICBjYXNlICdhcnJheSc6XFxuICAgICAgcmV0dXJuICdbXSc7XFxuICAgIGRlZmF1bHQ6XFxuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIFRha2VzIHNvbWUgdmFyaWFibGUgYW5kIGFza3MgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKWAgd2hhdCBpdCB0aGlua3MgaXRcXG4gKiBpcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L3RvU3RyaW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdC5cXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb21wdXRlZCB0eXBlXFxuICogQGV4YW1wbGVcXG4gKiB0eXBlKHt9KSAvLyAnb2JqZWN0J1xcbiAqIHR5cGUoW10pIC8vICdhcnJheSdcXG4gKiB0eXBlKDEpIC8vICdudW1iZXInXFxuICogdHlwZShmYWxzZSkgLy8gJ2Jvb2xlYW4nXFxuICogdHlwZShJbmZpbml0eSkgLy8gJ251bWJlcidcXG4gKiB0eXBlKG51bGwpIC8vICdudWxsJ1xcbiAqIHR5cGUobmV3IERhdGUoKSkgLy8gJ2RhdGUnXFxuICogdHlwZSgvZm9vLykgLy8gJ3JlZ2V4cCdcXG4gKiB0eXBlKCd0eXBlJykgLy8gJ3N0cmluZydcXG4gKiB0eXBlKGdsb2JhbCkgLy8gJ2dsb2JhbCdcXG4gKiB0eXBlKG5ldyBTdHJpbmcoJ2ZvbycpIC8vICdvYmplY3QnXFxuICovXFxudmFyIHR5cGUgPSBleHBvcnRzLnR5cGUgPSBmdW5jdGlvbiB0eXBlICh2YWx1ZSkge1xcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcXG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xcbiAgICByZXR1cm4gJ251bGwnO1xcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XFxuICAgIHJldHVybiAnYnVmZmVyJztcXG4gIH1cXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpXFxuICAgIC5yZXBsYWNlKC9eXFxcXFsuK1xcXFxzKC4rPyldJC8sICckMScpXFxuICAgIC50b0xvd2VyQ2FzZSgpO1xcbn07XFxuXFxuLyoqXFxuICogU3RyaW5naWZ5IGB2YWx1ZWAuIERpZmZlcmVudCBiZWhhdmlvciBkZXBlbmRpbmcgb24gdHlwZSBvZiB2YWx1ZTpcXG4gKlxcbiAqIC0gSWYgYHZhbHVlYCBpcyB1bmRlZmluZWQgb3IgbnVsbCwgcmV0dXJuIGAnW3VuZGVmaW5lZF0nYCBvciBgJ1tudWxsXSdgLCByZXNwZWN0aXZlbHkuXFxuICogLSBJZiBgdmFsdWVgIGlzIG5vdCBhbiBvYmplY3QsIGZ1bmN0aW9uIG9yIGFycmF5LCByZXR1cm4gcmVzdWx0IG9mIGB2YWx1ZS50b1N0cmluZygpYCB3cmFwcGVkIGluIGRvdWJsZS1xdW90ZXMuXFxuICogLSBJZiBgdmFsdWVgIGlzIGFuICplbXB0eSogb2JqZWN0LCBmdW5jdGlvbiwgb3IgYXJyYXksIHJldHVybiByZXN1bHQgb2YgZnVuY3Rpb25cXG4gKiAgIHtAbGluayBlbXB0eVJlcHJlc2VudGF0aW9ufS5cXG4gKiAtIElmIGB2YWx1ZWAgaGFzIHByb3BlcnRpZXMsIGNhbGwge0BsaW5rIGV4cG9ydHMuY2Fub25pY2FsaXplfSBvbiBpdCwgdGhlbiByZXR1cm4gcmVzdWx0IG9mXFxuICogICBKU09OLnN0cmluZ2lmeSgpLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHNlZSBleHBvcnRzLnR5cGVcXG4gKiBAcGFyYW0geyp9IHZhbHVlXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICB2YXIgdHlwZUhpbnQgPSB0eXBlKHZhbHVlKTtcXG5cXG4gIGlmICghflsnb2JqZWN0JywgJ2FycmF5JywgJ2Z1bmN0aW9uJ10uaW5kZXhPZih0eXBlSGludCkpIHtcXG4gICAgaWYgKHR5cGVIaW50ID09PSAnYnVmZmVyJykge1xcbiAgICAgIHZhciBqc29uID0gQnVmZmVyLnByb3RvdHlwZS50b0pTT04uY2FsbCh2YWx1ZSk7XFxuICAgICAgLy8gQmFzZWQgb24gdGhlIHRvSlNPTiByZXN1bHRcXG4gICAgICByZXR1cm4ganNvblN0cmluZ2lmeShqc29uLmRhdGEgJiYganNvbi50eXBlID8ganNvbi5kYXRhIDoganNvbiwgMilcXG4gICAgICAgIC5yZXBsYWNlKC8sKFxcXFxufCQpL2csICckMScpO1xcbiAgICB9XFxuXFxuICAgIC8vIElFNy9JRTggaGFzIGEgYml6YXJyZSBTdHJpbmcgY29uc3RydWN0b3I7IG5lZWRzIHRvIGJlIGNvZXJjZWRcXG4gICAgLy8gaW50byBhbiBhcnJheSBhbmQgYmFjayB0byBvYmouXFxuICAgIGlmICh0eXBlSGludCA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xcbiAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJycpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjaGFyLCBpZHgpIHtcXG4gICAgICAgIGFjY1tpZHhdID0gY2hhcjtcXG4gICAgICAgIHJldHVybiBhY2M7XFxuICAgICAgfSwge30pO1xcbiAgICAgIHR5cGVIaW50ID0gJ29iamVjdCc7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIGpzb25TdHJpbmdpZnkodmFsdWUpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmb3IgKHZhciBwcm9wIGluIHZhbHVlKSB7XFxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHByb3ApKSB7XFxuICAgICAgcmV0dXJuIGpzb25TdHJpbmdpZnkoZXhwb3J0cy5jYW5vbmljYWxpemUodmFsdWUsIG51bGwsIHR5cGVIaW50KSwgMikucmVwbGFjZSgvLChcXFxcbnwkKS9nLCAnJDEnKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIGVtcHR5UmVwcmVzZW50YXRpb24odmFsdWUsIHR5cGVIaW50KTtcXG59O1xcblxcbi8qKlxcbiAqIGxpa2UgSlNPTi5zdHJpbmdpZnkgYnV0IG1vcmUgc2Vuc2UuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gIG9iamVjdFxcbiAqIEBwYXJhbSB7bnVtYmVyPX0gc3BhY2VzXFxuICogQHBhcmFtIHtudW1iZXI9fSBkZXB0aFxcbiAqIEByZXR1cm5zIHsqfVxcbiAqL1xcbmZ1bmN0aW9uIGpzb25TdHJpbmdpZnkgKG9iamVjdCwgc3BhY2VzLCBkZXB0aCkge1xcbiAgaWYgKHR5cGVvZiBzcGFjZXMgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgIC8vIHByaW1pdGl2ZSB0eXBlc1xcbiAgICByZXR1cm4gX3N0cmluZ2lmeShvYmplY3QpO1xcbiAgfVxcblxcbiAgZGVwdGggPSBkZXB0aCB8fCAxO1xcbiAgdmFyIHNwYWNlID0gc3BhY2VzICogZGVwdGg7XFxuICB2YXIgc3RyID0gQXJyYXkuaXNBcnJheShvYmplY3QpID8gJ1snIDogJ3snO1xcbiAgdmFyIGVuZCA9IEFycmF5LmlzQXJyYXkob2JqZWN0KSA/ICddJyA6ICd9JztcXG4gIHZhciBsZW5ndGggPSB0eXBlb2Ygb2JqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcicgPyBvYmplY3QubGVuZ3RoIDogT2JqZWN0LmtleXMob2JqZWN0KS5sZW5ndGg7XFxuICAvLyBgLnJlcGVhdCgpYCBwb2x5ZmlsbFxcbiAgZnVuY3Rpb24gcmVwZWF0IChzLCBuKSB7XFxuICAgIHJldHVybiBuZXcgQXJyYXkobikuam9pbihzKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIF9zdHJpbmdpZnkgKHZhbCkge1xcbiAgICBzd2l0Y2ggKHR5cGUodmFsKSkge1xcbiAgICAgIGNhc2UgJ251bGwnOlxcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XFxuICAgICAgICB2YWwgPSAnWycgKyB2YWwgKyAnXSc7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICdhcnJheSc6XFxuICAgICAgY2FzZSAnb2JqZWN0JzpcXG4gICAgICAgIHZhbCA9IGpzb25TdHJpbmdpZnkodmFsLCBzcGFjZXMsIGRlcHRoICsgMSk7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICdib29sZWFuJzpcXG4gICAgICBjYXNlICdyZWdleHAnOlxcbiAgICAgIGNhc2UgJ3N5bWJvbCc6XFxuICAgICAgY2FzZSAnbnVtYmVyJzpcXG4gICAgICAgIHZhbCA9IHZhbCA9PT0gMCAmJiAoMSAvIHZhbCkgPT09IC1JbmZpbml0eSAvLyBgLTBgXFxuICAgICAgICAgID8gJy0wJ1xcbiAgICAgICAgICA6IHZhbC50b1N0cmluZygpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAnZGF0ZSc6XFxuICAgICAgICB2YXIgc0RhdGUgPSBpc05hTih2YWwuZ2V0VGltZSgpKSA/IHZhbC50b1N0cmluZygpIDogdmFsLnRvSVNPU3RyaW5nKCk7XFxuICAgICAgICB2YWwgPSAnW0RhdGU6ICcgKyBzRGF0ZSArICddJztcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgJ2J1ZmZlcic6XFxuICAgICAgICB2YXIganNvbiA9IHZhbC50b0pTT04oKTtcXG4gICAgICAgIC8vIEJhc2VkIG9uIHRoZSB0b0pTT04gcmVzdWx0XFxuICAgICAgICBqc29uID0ganNvbi5kYXRhICYmIGpzb24udHlwZSA/IGpzb24uZGF0YSA6IGpzb247XFxuICAgICAgICB2YWwgPSAnW0J1ZmZlcjogJyArIGpzb25TdHJpbmdpZnkoanNvbiwgMiwgZGVwdGggKyAxKSArICddJztcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICB2YWwgPSAodmFsID09PSAnW0Z1bmN0aW9uXScgfHwgdmFsID09PSAnW0NpcmN1bGFyXScpXFxuICAgICAgICAgID8gdmFsXFxuICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkodmFsKTsgLy8gc3RyaW5nXFxuICAgIH1cXG4gICAgcmV0dXJuIHZhbDtcXG4gIH1cXG5cXG4gIGZvciAodmFyIGkgaW4gb2JqZWN0KSB7XFxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaSkpIHtcXG4gICAgICBjb250aW51ZTsgLy8gbm90IG15IGJ1c2luZXNzXFxuICAgIH1cXG4gICAgLS1sZW5ndGg7XFxuICAgIHN0ciArPSAnXFxcXG4gJyArIHJlcGVhdCgnICcsIHNwYWNlKSArXFxuICAgICAgKEFycmF5LmlzQXJyYXkob2JqZWN0KSA/ICcnIDogJ1xcXCInICsgaSArICdcXFwiOiAnKSArIC8vIGtleVxcbiAgICAgIF9zdHJpbmdpZnkob2JqZWN0W2ldKSArIC8vIHZhbHVlXFxuICAgICAgKGxlbmd0aCA/ICcsJyA6ICcnKTsgLy8gY29tbWFcXG4gIH1cXG5cXG4gIHJldHVybiBzdHIgK1xcbiAgICAvLyBbXSwge31cXG4gICAgKHN0ci5sZW5ndGggIT09IDEgPyAnXFxcXG4nICsgcmVwZWF0KCcgJywgLS1zcGFjZSkgKyBlbmQgOiBlbmQpO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBuZXcgVGhpbmcgdGhhdCBoYXMgdGhlIGtleXMgaW4gc29ydGVkIG9yZGVyLiBSZWN1cnNpdmUuXFxuICpcXG4gKiBJZiB0aGUgVGhpbmcuLi5cXG4gKiAtIGhhcyBhbHJlYWR5IGJlZW4gc2VlbiwgcmV0dXJuIHN0cmluZyBgJ1tDaXJjdWxhcl0nYFxcbiAqIC0gaXMgYHVuZGVmaW5lZGAsIHJldHVybiBzdHJpbmcgYCdbdW5kZWZpbmVkXSdgXFxuICogLSBpcyBgbnVsbGAsIHJldHVybiB2YWx1ZSBgbnVsbGBcXG4gKiAtIGlzIHNvbWUgb3RoZXIgcHJpbWl0aXZlLCByZXR1cm4gdGhlIHZhbHVlXFxuICogLSBpcyBub3QgYSBwcmltaXRpdmUgb3IgYW4gYEFycmF5YCwgYE9iamVjdGAsIG9yIGBGdW5jdGlvbmAsIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIFRoaW5nJ3MgYHRvU3RyaW5nKClgIG1ldGhvZFxcbiAqIC0gaXMgYSBub24tZW1wdHkgYEFycmF5YCwgYE9iamVjdGAsIG9yIGBGdW5jdGlvbmAsIHJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBhZ2Fpbi5cXG4gKiAtIGlzIGFuIGVtcHR5IGBBcnJheWAsIGBPYmplY3RgLCBvciBgRnVuY3Rpb25gLCByZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBlbXB0eVJlcHJlc2VudGF0aW9uKClgXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAc2VlIHtAbGluayBleHBvcnRzLnN0cmluZ2lmeX1cXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoaW5nIHRvIGluc3BlY3QuICBNYXkgb3IgbWF5IG5vdCBoYXZlIHByb3BlcnRpZXMuXFxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrPVtdXSBTdGFjayBvZiBzZWVuIHZhbHVlc1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZUhpbnRdIFR5cGUgaGludFxcbiAqIEByZXR1cm4geyhPYmplY3R8QXJyYXl8RnVuY3Rpb258c3RyaW5nfHVuZGVmaW5lZCl9XFxuICovXFxuZXhwb3J0cy5jYW5vbmljYWxpemUgPSBmdW5jdGlvbiBjYW5vbmljYWxpemUgKHZhbHVlLCBzdGFjaywgdHlwZUhpbnQpIHtcXG4gIHZhciBjYW5vbmljYWxpemVkT2JqO1xcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cXG4gIHZhciBwcm9wO1xcbiAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xcbiAgdHlwZUhpbnQgPSB0eXBlSGludCB8fCB0eXBlKHZhbHVlKTtcXG4gIGZ1bmN0aW9uIHdpdGhTdGFjayAodmFsdWUsIGZuKSB7XFxuICAgIHN0YWNrLnB1c2godmFsdWUpO1xcbiAgICBmbigpO1xcbiAgICBzdGFjay5wb3AoKTtcXG4gIH1cXG5cXG4gIHN0YWNrID0gc3RhY2sgfHwgW107XFxuXFxuICBpZiAoc3RhY2suaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XFxuICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XFxuICB9XFxuXFxuICBzd2l0Y2ggKHR5cGVIaW50KSB7XFxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XFxuICAgIGNhc2UgJ2J1ZmZlcic6XFxuICAgIGNhc2UgJ251bGwnOlxcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB2YWx1ZTtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAnYXJyYXknOlxcbiAgICAgIHdpdGhTdGFjayh2YWx1ZSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgY2Fub25pY2FsaXplZE9iaiA9IHZhbHVlLm1hcChmdW5jdGlvbiAoaXRlbSkge1xcbiAgICAgICAgICByZXR1cm4gZXhwb3J0cy5jYW5vbmljYWxpemUoaXRlbSwgc3RhY2spO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cXG4gICAgICBmb3IgKHByb3AgaW4gdmFsdWUpIHtcXG4gICAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB7fTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIGd1YXJkLWZvci1pbiAqL1xcbiAgICAgIGlmICghY2Fub25pY2FsaXplZE9iaikge1xcbiAgICAgICAgY2Fub25pY2FsaXplZE9iaiA9IGVtcHR5UmVwcmVzZW50YXRpb24odmFsdWUsIHR5cGVIaW50KTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG4gICAgLyogZmFsbHMgdGhyb3VnaCAqL1xcbiAgICBjYXNlICdvYmplY3QnOlxcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBjYW5vbmljYWxpemVkT2JqIHx8IHt9O1xcbiAgICAgIHdpdGhTdGFjayh2YWx1ZSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLnNvcnQoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgICAgICAgY2Fub25pY2FsaXplZE9ialtrZXldID0gZXhwb3J0cy5jYW5vbmljYWxpemUodmFsdWVba2V5XSwgc3RhY2spO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ2RhdGUnOlxcbiAgICBjYXNlICdudW1iZXInOlxcbiAgICBjYXNlICdyZWdleHAnOlxcbiAgICBjYXNlICdib29sZWFuJzpcXG4gICAgY2FzZSAnc3ltYm9sJzpcXG4gICAgICBjYW5vbmljYWxpemVkT2JqID0gdmFsdWU7XFxuICAgICAgYnJlYWs7XFxuICAgIGRlZmF1bHQ6XFxuICAgICAgY2Fub25pY2FsaXplZE9iaiA9IHZhbHVlICsgJyc7XFxuICB9XFxuXFxuICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcXG59O1xcblxcbi8qKlxcbiAqIExvb2t1cCBmaWxlIG5hbWVzIGF0IHRoZSBnaXZlbiBgcGF0aGAuXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGEudXRpbHNcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZXBhdGggQmFzZSBwYXRoIHRvIHN0YXJ0IHNlYXJjaGluZyBmcm9tLlxcbiAqIEBwYXJhbSB7c3RyaW5nW119IGV4dGVuc2lvbnMgRmlsZSBleHRlbnNpb25zIHRvIGxvb2sgZm9yLlxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVjdXJzaXZlIFdoZXRoZXIgb3Igbm90IHRvIHJlY3Vyc2UgaW50byBzdWJkaXJlY3Rvcmllcy5cXG4gKiBAcmV0dXJuIHtzdHJpbmdbXX0gQW4gYXJyYXkgb2YgcGF0aHMuXFxuICovXFxuZXhwb3J0cy5sb29rdXBGaWxlcyA9IGZ1bmN0aW9uIGxvb2t1cEZpbGVzIChmaWxlcGF0aCwgZXh0ZW5zaW9ucywgcmVjdXJzaXZlKSB7XFxuICB2YXIgZmlsZXMgPSBbXTtcXG5cXG4gIGlmICghZnMuZXhpc3RzU3luYyhmaWxlcGF0aCkpIHtcXG4gICAgaWYgKGZzLmV4aXN0c1N5bmMoZmlsZXBhdGggKyAnLmpzJykpIHtcXG4gICAgICBmaWxlcGF0aCArPSAnLmpzJztcXG4gICAgfSBlbHNlIHtcXG4gICAgICBmaWxlcyA9IGdsb2Iuc3luYyhmaWxlcGF0aCk7XFxuICAgICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiY2Fubm90IHJlc29sdmUgcGF0aCAob3IgcGF0dGVybikgJ1xcXCIgKyBmaWxlcGF0aCArIFxcXCInXFxcIik7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBmaWxlcztcXG4gICAgfVxcbiAgfVxcblxcbiAgdHJ5IHtcXG4gICAgdmFyIHN0YXQgPSBmcy5zdGF0U3luYyhmaWxlcGF0aCk7XFxuICAgIGlmIChzdGF0LmlzRmlsZSgpKSB7XFxuICAgICAgcmV0dXJuIGZpbGVwYXRoO1xcbiAgICB9XFxuICB9IGNhdGNoIChlcnIpIHtcXG4gICAgLy8gaWdub3JlIGVycm9yXFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGZzLnJlYWRkaXJTeW5jKGZpbGVwYXRoKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XFxuICAgIGZpbGUgPSBwYXRoLmpvaW4oZmlsZXBhdGgsIGZpbGUpO1xcbiAgICB0cnkge1xcbiAgICAgIHZhciBzdGF0ID0gZnMuc3RhdFN5bmMoZmlsZSk7XFxuICAgICAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xcbiAgICAgICAgaWYgKHJlY3Vyc2l2ZSkge1xcbiAgICAgICAgICBmaWxlcyA9IGZpbGVzLmNvbmNhdChsb29rdXBGaWxlcyhmaWxlLCBleHRlbnNpb25zLCByZWN1cnNpdmUpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIC8vIGlnbm9yZSBlcnJvclxcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKCdcXFxcXFxcXC4oPzonICsgZXh0ZW5zaW9ucy5qb2luKCd8JykgKyAnKSQnKTtcXG4gICAgaWYgKCFzdGF0LmlzRmlsZSgpIHx8ICFyZS50ZXN0KGZpbGUpIHx8IHBhdGguYmFzZW5hbWUoZmlsZSlbMF0gPT09ICcuJykge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBmaWxlcy5wdXNoKGZpbGUpO1xcbiAgfSk7XFxuXFxuICByZXR1cm4gZmlsZXM7XFxufTtcXG5cXG4vKipcXG4gKiBHZW5lcmF0ZSBhbiB1bmRlZmluZWQgZXJyb3Igd2l0aCBhIG1lc3NhZ2Ugd2FybmluZyB0aGUgdXNlci5cXG4gKlxcbiAqIEByZXR1cm4ge0Vycm9yfVxcbiAqL1xcblxcbmV4cG9ydHMudW5kZWZpbmVkRXJyb3IgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gbmV3IEVycm9yKCdDYXVnaHQgdW5kZWZpbmVkIGVycm9yLCBkaWQgeW91IHRocm93IHdpdGhvdXQgc3BlY2lmeWluZyB3aGF0PycpO1xcbn07XFxuXFxuLyoqXFxuICogR2VuZXJhdGUgYW4gdW5kZWZpbmVkIGVycm9yIGlmIGBlcnJgIGlzIG5vdCBkZWZpbmVkLlxcbiAqXFxuICogQHBhcmFtIHtFcnJvcn0gZXJyXFxuICogQHJldHVybiB7RXJyb3J9XFxuICovXFxuXFxuZXhwb3J0cy5nZXRFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcXG4gIHJldHVybiBlcnIgfHwgZXhwb3J0cy51bmRlZmluZWRFcnJvcigpO1xcbn07XFxuXFxuLyoqXFxuICogQHN1bW1hcnlcXG4gKiBUaGlzIEZpbHRlciBiYXNlZCBvbiBgbW9jaGEtY2xlYW5gIG1vZHVsZS4oc2VlOiBgZ2l0aHViLmNvbS9yc3RhY3J1ei9tb2NoYS1jbGVhbmApXFxuICogQGRlc2NyaXB0aW9uXFxuICogV2hlbiBpbnZva2luZyB0aGlzIGZ1bmN0aW9uIHlvdSBnZXQgYSBmaWx0ZXIgZnVuY3Rpb24gdGhhdCBnZXQgdGhlIEVycm9yLnN0YWNrIGFzIGFuIGlucHV0LFxcbiAqIGFuZCByZXR1cm4gYSBwcmV0dGlmeSBvdXRwdXQuXFxuICogKGkuZTogc3RyaXAgTW9jaGEgYW5kIGludGVybmFsIG5vZGUgZnVuY3Rpb25zIGZyb20gc3RhY2sgdHJhY2UpLlxcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cXG4gKi9cXG5leHBvcnRzLnN0YWNrVHJhY2VGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAvLyBUT0RPOiBSZXBsYWNlIHdpdGggYHByb2Nlc3MuYnJvd3NlcmBcXG4gIHZhciBpcyA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyB7IG5vZGU6IHRydWUgfSA6IHsgYnJvd3NlcjogdHJ1ZSB9O1xcbiAgdmFyIHNsYXNoID0gcGF0aC5zZXA7XFxuICB2YXIgY3dkO1xcbiAgaWYgKGlzLm5vZGUpIHtcXG4gICAgY3dkID0gcHJvY2Vzcy5jd2QoKSArIHNsYXNoO1xcbiAgfSBlbHNlIHtcXG4gICAgY3dkID0gKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCdcXG4gICAgICA/IHdpbmRvdy5sb2NhdGlvblxcbiAgICAgIDogbG9jYXRpb24pLmhyZWYucmVwbGFjZSgvXFxcXC9bXi9dKiQvLCAnLycpO1xcbiAgICBzbGFzaCA9ICcvJztcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGlzTW9jaGFJbnRlcm5hbCAobGluZSkge1xcbiAgICByZXR1cm4gKH5saW5lLmluZGV4T2YoJ25vZGVfbW9kdWxlcycgKyBzbGFzaCArICdtb2NoYScgKyBzbGFzaCkpIHx8XFxuICAgICAgKH5saW5lLmluZGV4T2YoJ25vZGVfbW9kdWxlcycgKyBzbGFzaCArICdtb2NoYS5qcycpKSB8fFxcbiAgICAgICh+bGluZS5pbmRleE9mKCdib3dlcl9jb21wb25lbnRzJyArIHNsYXNoICsgJ21vY2hhLmpzJykpIHx8XFxuICAgICAgKH5saW5lLmluZGV4T2Yoc2xhc2ggKyAnbW9jaGEuanMnKSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpc05vZGVJbnRlcm5hbCAobGluZSkge1xcbiAgICByZXR1cm4gKH5saW5lLmluZGV4T2YoJyh0aW1lcnMuanM6JykpIHx8XFxuICAgICAgKH5saW5lLmluZGV4T2YoJyhldmVudHMuanM6JykpIHx8XFxuICAgICAgKH5saW5lLmluZGV4T2YoJyhub2RlLmpzOicpKSB8fFxcbiAgICAgICh+bGluZS5pbmRleE9mKCcobW9kdWxlLmpzOicpKSB8fFxcbiAgICAgICh+bGluZS5pbmRleE9mKCdHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5uZXh0IChuYXRpdmUpJykpIHx8XFxuICAgICAgZmFsc2U7XFxuICB9XFxuXFxuICByZXR1cm4gZnVuY3Rpb24gKHN0YWNrKSB7XFxuICAgIHN0YWNrID0gc3RhY2suc3BsaXQoJ1xcXFxuJyk7XFxuXFxuICAgIHN0YWNrID0gc3RhY2sucmVkdWNlKGZ1bmN0aW9uIChsaXN0LCBsaW5lKSB7XFxuICAgICAgaWYgKGlzTW9jaGFJbnRlcm5hbChsaW5lKSkge1xcbiAgICAgICAgcmV0dXJuIGxpc3Q7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpcy5ub2RlICYmIGlzTm9kZUludGVybmFsKGxpbmUpKSB7XFxuICAgICAgICByZXR1cm4gbGlzdDtcXG4gICAgICB9XFxuXFxuICAgICAgLy8gQ2xlYW4gdXAgY3dkKGFic29sdXRlKVxcbiAgICAgIGlmICgvXFxcXCg/Lis6XFxcXGQrOlxcXFxkK1xcXFwpPyQvLnRlc3QobGluZSkpIHtcXG4gICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoJygnICsgY3dkLCAnKCcpO1xcbiAgICAgIH1cXG5cXG4gICAgICBsaXN0LnB1c2gobGluZSk7XFxuICAgICAgcmV0dXJuIGxpc3Q7XFxuICAgIH0sIFtdKTtcXG5cXG4gICAgcmV0dXJuIHN0YWNrLmpvaW4oJ1xcXFxuJyk7XFxuICB9O1xcbn07XFxuXFxuLyoqXFxuICogQ3J1ZGUsIGJ1dCBlZmZlY3RpdmUuXFxuICogQGFwaVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgYHZhbHVlYCBpcyBhIFByb21pc2VcXG4gKi9cXG5leHBvcnRzLmlzUHJvbWlzZSA9IGZ1bmN0aW9uIGlzUHJvbWlzZSAodmFsdWUpIHtcXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xcbn07XFxuXFxuLyoqXFxuICogSXQncyBhIG5vb3AuXFxuICogQGFwaVxcbiAqL1xcbmV4cG9ydHMubm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHJlcXVpcmUoXFxcImJ1ZmZlclxcXCIpLkJ1ZmZlcilcXG59LHtcXFwiX3Byb2Nlc3NcXFwiOjU2LFxcXCJidWZmZXJcXFwiOjQxLFxcXCJkZWJ1Z1xcXCI6NDMsXFxcImZzXFxcIjo0MCxcXFwiZ2xvYlxcXCI6NDAsXFxcImhlXFxcIjo0OCxcXFwicGF0aFxcXCI6NDAsXFxcInV0aWxcXFwiOjc2fV0sMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0J1xcblxcbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcXG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XFxuXFxudmFyIGxvb2t1cCA9IFtdXFxudmFyIHJldkxvb2t1cCA9IFtdXFxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxcblxcbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXFxuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcXG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxcbn1cXG5cXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcXG5cXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XFxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxcbiAgaWYgKGxlbiAlIDQgPiAwKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXFxuICB9XFxuXFxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXFxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcXG4gIHJldHVybiBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXFxufVxcblxcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXFxuICByZXR1cm4gKGI2NC5sZW5ndGggKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXFxufVxcblxcbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcXG4gIHZhciBpLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXFxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxcblxcbiAgYXJyID0gbmV3IEFycigobGVuICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzKVxcblxcbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXFxuXFxuICB2YXIgTCA9IDBcXG5cXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpICs9IDQpIHtcXG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXFxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXFxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXFxuICB9XFxuXFxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XFxuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXFxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcXG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXFxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXFxuICB9XFxuXFxuICByZXR1cm4gYXJyXFxufVxcblxcbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XFxuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cXG59XFxuXFxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XFxuICB2YXIgdG1wXFxuICB2YXIgb3V0cHV0ID0gW11cXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XFxuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXFxuICB9XFxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXFxufVxcblxcbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XFxuICB2YXIgdG1wXFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcXG4gIHZhciBvdXRwdXQgPSAnJ1xcbiAgdmFyIHBhcnRzID0gW11cXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xcblxcbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxcbiAgfVxcblxcbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcXG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cXG4gICAgb3V0cHV0ICs9ICc9PSdcXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXFxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXVxcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxcbiAgICBvdXRwdXQgKz0gJz0nXFxuICB9XFxuXFxuICBwYXJ0cy5wdXNoKG91dHB1dClcXG5cXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxcbn1cXG5cXG59LHt9XSwzODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuXFxufSx7fV0sMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxudmFyIFdyaXRhYmxlU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuV3JpdGFibGVcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IEJyb3dzZXJTdGRvdXRcXG5cXG5cXG5pbmhlcml0cyhCcm93c2VyU3Rkb3V0LCBXcml0YWJsZVN0cmVhbSlcXG5cXG5mdW5jdGlvbiBCcm93c2VyU3Rkb3V0KG9wdHMpIHtcXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCcm93c2VyU3Rkb3V0KSkgcmV0dXJuIG5ldyBCcm93c2VyU3Rkb3V0KG9wdHMpXFxuXFxuICBvcHRzID0gb3B0cyB8fCB7fVxcbiAgV3JpdGFibGVTdHJlYW0uY2FsbCh0aGlzLCBvcHRzKVxcbiAgdGhpcy5sYWJlbCA9IChvcHRzLmxhYmVsICE9PSB1bmRlZmluZWQpID8gb3B0cy5sYWJlbCA6ICdzdGRvdXQnXFxufVxcblxcbkJyb3dzZXJTdGRvdXQucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rcywgZW5jb2RpbmcsIGNiKSB7XFxuICB2YXIgb3V0cHV0ID0gY2h1bmtzLnRvU3RyaW5nID8gY2h1bmtzLnRvU3RyaW5nKCkgOiBjaHVua3NcXG4gIGlmICh0aGlzLmxhYmVsID09PSBmYWxzZSkge1xcbiAgICBjb25zb2xlLmxvZyhvdXRwdXQpXFxuICB9IGVsc2Uge1xcbiAgICBjb25zb2xlLmxvZyh0aGlzLmxhYmVsKyc6Jywgb3V0cHV0KVxcbiAgfVxcbiAgcHJvY2Vzcy5uZXh0VGljayhjYilcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIl9wcm9jZXNzXFxcIjo1NixcXFwic3RyZWFtXFxcIjo3MSxcXFwidXRpbFxcXCI6NzZ9XSw0MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuYXJndW1lbnRzWzRdWzM4XVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cylcXG59LHtcXFwiZHVwXFxcIjozOH1dLDQxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKiFcXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cXG4gKlxcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxcbiAqIEBsaWNlbnNlICBNSVRcXG4gKi9cXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xcblxcbid1c2Ugc3RyaWN0J1xcblxcbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXFxuXFxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXFxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXFxuXFxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcXG5cXG4vKipcXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXFxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcXG4gKlxcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXFxuICpcXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxcbiAqL1xcbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxcblxcbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXFxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XFxuICBjb25zb2xlLmVycm9yKFxcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXFxuICApXFxufVxcblxcbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcXG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cXG4gIHRyeSB7XFxuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcXG4gIH0gY2F0Y2ggKGUpIHtcXG4gICAgcmV0dXJuIGZhbHNlXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XFxuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXFxuICB9XFxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXFxuICByZXR1cm4gYnVmXFxufVxcblxcbi8qKlxcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXFxuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcXG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxcbiAqXFxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxcbiAqL1xcblxcbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcXG4gIC8vIENvbW1vbiBjYXNlLlxcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XFxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXFxuICAgICAgKVxcbiAgICB9XFxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXFxuICB9XFxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcXG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcXG4gICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xcbiAgICB2YWx1ZTogbnVsbCxcXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcXG4gICAgd3JpdGFibGU6IGZhbHNlXFxuICB9KVxcbn1cXG5cXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cXG5cXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XFxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwidmFsdWVcXFwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcXG4gIH1cXG5cXG4gIGlmIChpc0FycmF5QnVmZmVyKHZhbHVlKSkge1xcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXFxuICB9XFxuXFxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcXG4gIH1cXG5cXG4gIHJldHVybiBmcm9tT2JqZWN0KHZhbHVlKVxcbn1cXG5cXG4vKipcXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxcbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXFxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXFxuICoqL1xcbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcXG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1ZzpcXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcXG5CdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxcblxcbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcXG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFxcInNpemVcXFwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFxcInNpemVcXFwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XFxuICBhc3NlcnRTaXplKHNpemUpXFxuICBpZiAoc2l6ZSA8PSAwKSB7XFxuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcXG4gIH1cXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcXG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXFxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXFxuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXFxuICB9XFxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXFxufVxcblxcbi8qKlxcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXFxuICoqL1xcbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxcbn1cXG5cXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xcbiAgYXNzZXJ0U2l6ZShzaXplKVxcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcXG59XFxuXFxuLyoqXFxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cXG4gKiAqL1xcbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XFxuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcXG59XFxuLyoqXFxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXFxuICovXFxuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XFxuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcXG59XFxuXFxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XFxuICAgIGVuY29kaW5nID0gJ3V0ZjgnXFxuICB9XFxuXFxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwiZW5jb2RpbmdcXFwiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxcbiAgfVxcblxcbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcXG5cXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcXG5cXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXFxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXFxuICB9XFxuXFxuICByZXR1cm4gYnVmXFxufVxcblxcbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XFxuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcXG4gIH1cXG4gIHJldHVybiBidWZcXG59XFxuXFxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XFxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcXFwnb2Zmc2V0XFxcXCcgaXMgb3V0IG9mIGJvdW5kcycpXFxuICB9XFxuXFxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXFxcJ2xlbmd0aFxcXFwnIGlzIG91dCBvZiBib3VuZHMnKVxcbiAgfVxcblxcbiAgdmFyIGJ1ZlxcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcXG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXFxuICB9IGVsc2Uge1xcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxcbiAgfVxcblxcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXFxuICByZXR1cm4gYnVmXFxufVxcblxcbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XFxuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcXG5cXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcXG4gICAgICByZXR1cm4gYnVmXFxuICAgIH1cXG5cXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXFxuICAgIHJldHVybiBidWZcXG4gIH1cXG5cXG4gIGlmIChvYmopIHtcXG4gICAgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KG9iaikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XFxuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXFxuICAgIH1cXG5cXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxcbiAgICB9XFxuICB9XFxuXFxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcXG59XFxuXFxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XFxuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXFxuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXFxuICB9XFxuICByZXR1cm4gbGVuZ3RoIHwgMFxcbn1cXG5cXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcXG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxcbiAgICBsZW5ndGggPSAwXFxuICB9XFxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXFxufVxcblxcbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XFxuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlXFxufVxcblxcbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcXG4gIH1cXG5cXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxcblxcbiAgdmFyIHggPSBhLmxlbmd0aFxcbiAgdmFyIHkgPSBiLmxlbmd0aFxcblxcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcXG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcXG4gICAgICB4ID0gYVtpXVxcbiAgICAgIHkgPSBiW2ldXFxuICAgICAgYnJlYWtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcXG4gIHJldHVybiAwXFxufVxcblxcbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcXG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XFxuICAgIGNhc2UgJ2hleCc6XFxuICAgIGNhc2UgJ3V0ZjgnOlxcbiAgICBjYXNlICd1dGYtOCc6XFxuICAgIGNhc2UgJ2FzY2lpJzpcXG4gICAgY2FzZSAnbGF0aW4xJzpcXG4gICAgY2FzZSAnYmluYXJ5JzpcXG4gICAgY2FzZSAnYmFzZTY0JzpcXG4gICAgY2FzZSAndWNzMic6XFxuICAgIGNhc2UgJ3Vjcy0yJzpcXG4gICAgY2FzZSAndXRmMTZsZSc6XFxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcXG4gICAgICByZXR1cm4gdHJ1ZVxcbiAgICBkZWZhdWx0OlxcbiAgICAgIHJldHVybiBmYWxzZVxcbiAgfVxcbn1cXG5cXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcXG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwibGlzdFxcXCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcXG4gIH1cXG5cXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXFxuICB9XFxuXFxuICB2YXIgaVxcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIGxlbmd0aCA9IDBcXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcXG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXFxuICB2YXIgcG9zID0gMFxcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJsaXN0XFxcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxcbiAgICB9XFxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxcbiAgfVxcbiAgcmV0dXJuIGJ1ZmZlclxcbn1cXG5cXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcXG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcXG4gIH1cXG4gIGlmIChpc0FycmF5QnVmZmVyVmlldyhzdHJpbmcpIHx8IGlzQXJyYXlCdWZmZXIoc3RyaW5nKSkge1xcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcXG4gIH1cXG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xcbiAgfVxcblxcbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXFxuXFxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXFxuICBmb3IgKDs7KSB7XFxuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcXG4gICAgICBjYXNlICdhc2NpaSc6XFxuICAgICAgY2FzZSAnbGF0aW4xJzpcXG4gICAgICBjYXNlICdiaW5hcnknOlxcbiAgICAgICAgcmV0dXJuIGxlblxcbiAgICAgIGNhc2UgJ3V0ZjgnOlxcbiAgICAgIGNhc2UgJ3V0Zi04JzpcXG4gICAgICBjYXNlIHVuZGVmaW5lZDpcXG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxcbiAgICAgIGNhc2UgJ3VjczInOlxcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcXG4gICAgICBjYXNlICd1dGYxNmxlJzpcXG4gICAgICBjYXNlICd1dGYtMTZsZSc6XFxuICAgICAgICByZXR1cm4gbGVuICogMlxcbiAgICAgIGNhc2UgJ2hleCc6XFxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXFxuICAgICAgY2FzZSAnYmFzZTY0JzpcXG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXFxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcXG4gICAgfVxcbiAgfVxcbn1cXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcXG5cXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XFxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxcblxcbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcXFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlxcXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cXG5cXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxcbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxcbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XFxuICAgIHN0YXJ0ID0gMFxcbiAgfVxcbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXFxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gJydcXG4gIH1cXG5cXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxcbiAgfVxcblxcbiAgaWYgKGVuZCA8PSAwKSB7XFxuICAgIHJldHVybiAnJ1xcbiAgfVxcblxcbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cXG4gIGVuZCA+Pj49IDBcXG4gIHN0YXJ0ID4+Pj0gMFxcblxcbiAgaWYgKGVuZCA8PSBzdGFydCkge1xcbiAgICByZXR1cm4gJydcXG4gIH1cXG5cXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXFxuXFxuICB3aGlsZSAodHJ1ZSkge1xcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XFxuICAgICAgY2FzZSAnaGV4JzpcXG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxcblxcbiAgICAgIGNhc2UgJ3V0ZjgnOlxcbiAgICAgIGNhc2UgJ3V0Zi04JzpcXG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcXG5cXG4gICAgICBjYXNlICdhc2NpaSc6XFxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxcblxcbiAgICAgIGNhc2UgJ2xhdGluMSc6XFxuICAgICAgY2FzZSAnYmluYXJ5JzpcXG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxcblxcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XFxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcXG5cXG4gICAgICBjYXNlICd1Y3MyJzpcXG4gICAgICBjYXNlICd1Y3MtMic6XFxuICAgICAgY2FzZSAndXRmMTZsZSc6XFxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxcblxcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxcbiAgICB9XFxuICB9XFxufVxcblxcbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcXG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXFxuXFxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xcbiAgdmFyIGkgPSBiW25dXFxuICBiW25dID0gYlttXVxcbiAgYlttXSA9IGlcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxcbiAgfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxcbiAgfVxcbiAgcmV0dXJuIHRoaXNcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxcbiAgfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcXG4gIH1cXG4gIHJldHVybiB0aGlzXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcXG4gIH1cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcXG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXFxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcXG4gIH1cXG4gIHJldHVybiB0aGlzXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XFxuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XFxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXFxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcXG4gIHZhciBzdHIgPSAnJ1xcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcXG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xcbiAgfVxcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXFxuICB9XFxuXFxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xcbiAgICBzdGFydCA9IDBcXG4gIH1cXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxcbiAgfVxcbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIHRoaXNTdGFydCA9IDBcXG4gIH1cXG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcXG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXFxuICB9XFxuXFxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXFxuICB9XFxuXFxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XFxuICAgIHJldHVybiAwXFxuICB9XFxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcXG4gICAgcmV0dXJuIC0xXFxuICB9XFxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XFxuICAgIHJldHVybiAxXFxuICB9XFxuXFxuICBzdGFydCA+Pj49IDBcXG4gIGVuZCA+Pj49IDBcXG4gIHRoaXNTdGFydCA+Pj49IDBcXG4gIHRoaXNFbmQgPj4+PSAwXFxuXFxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxcblxcbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcXG5cXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcXG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XFxuICAgICAgeCA9IHRoaXNDb3B5W2ldXFxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cXG4gICAgICBicmVha1xcbiAgICB9XFxuICB9XFxuXFxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxcbiAgcmV0dXJuIDBcXG59XFxuXFxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXFxuLy9cXG4vLyBBcmd1bWVudHM6XFxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXFxuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcXG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxcblxcbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcXG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcXG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XFxuICAgIGJ5dGVPZmZzZXQgPSAwXFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XFxuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcXG4gIH1cXG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcXFwiZm9vXFxcIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXFxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxcbiAgfVxcblxcbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XFxuICAgIGlmIChkaXIpIHJldHVybiAtMVxcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxcbiAgICBlbHNlIHJldHVybiAtMVxcbiAgfVxcblxcbiAgLy8gTm9ybWFsaXplIHZhbFxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XFxuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXFxuICB9XFxuXFxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XFxuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcXG4gICAgICByZXR1cm4gLTFcXG4gICAgfVxcbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgaWYgKGRpcikge1xcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxcbiAgfVxcblxcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcXG59XFxuXFxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xcbiAgdmFyIGluZGV4U2l6ZSA9IDFcXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxcblxcbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcXG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcXG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcXG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcXG4gICAgICAgIHJldHVybiAtMVxcbiAgICAgIH1cXG4gICAgICBpbmRleFNpemUgPSAyXFxuICAgICAgYXJyTGVuZ3RoIC89IDJcXG4gICAgICB2YWxMZW5ndGggLz0gMlxcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcXG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xcbiAgICAgIHJldHVybiBidWZbaV1cXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgaVxcbiAgaWYgKGRpcikge1xcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcXG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcXG4gICAgICB9XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XFxuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcXG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcXG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxcbiAgICAgICAgICBicmVha1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiAtMVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcXG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcXG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcXG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcXG59XFxuXFxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcXG4gIGlmICghbGVuZ3RoKSB7XFxuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xcbiAgfSBlbHNlIHtcXG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxcblxcbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcXG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxcbiAgfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXFxuICB9XFxuICByZXR1cm4gaVxcbn1cXG5cXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIGVuY29kaW5nID0gJ3V0ZjgnXFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXFxuICAgIG9mZnNldCA9IDBcXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xcbiAgICBlbmNvZGluZyA9IG9mZnNldFxcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxcbiAgICBvZmZzZXQgPSAwXFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XFxuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIHRocm93IG5ldyBFcnJvcihcXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXFxuICAgIClcXG4gIH1cXG5cXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXFxuXFxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxcbiAgfVxcblxcbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcXG5cXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXFxuICBmb3IgKDs7KSB7XFxuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcXG4gICAgICBjYXNlICdoZXgnOlxcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxuXFxuICAgICAgY2FzZSAndXRmOCc6XFxuICAgICAgY2FzZSAndXRmLTgnOlxcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcblxcbiAgICAgIGNhc2UgJ2FzY2lpJzpcXG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxuXFxuICAgICAgY2FzZSAnbGF0aW4xJzpcXG4gICAgICBjYXNlICdiaW5hcnknOlxcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxuXFxuICAgICAgY2FzZSAnYmFzZTY0JzpcXG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXFxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcXG5cXG4gICAgICBjYXNlICd1Y3MyJzpcXG4gICAgICBjYXNlICd1Y3MtMic6XFxuICAgICAgY2FzZSAndXRmMTZsZSc6XFxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcblxcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxcbiAgICB9XFxuICB9XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcXG4gIHJldHVybiB7XFxuICAgIHR5cGU6ICdCdWZmZXInLFxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcXG4gIHZhciByZXMgPSBbXVxcblxcbiAgdmFyIGkgPSBzdGFydFxcbiAgd2hpbGUgKGkgPCBlbmQpIHtcXG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxcbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcXG4gICAgICA6IDFcXG5cXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcXG5cXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcXG4gICAgICAgIGNhc2UgMTpcXG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcXG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBicmVha1xcbiAgICAgICAgY2FzZSAyOlxcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBicmVha1xcbiAgICAgICAgY2FzZSAzOlxcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxcbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXFxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcXG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYnJlYWtcXG4gICAgICAgIGNhc2UgNDpcXG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxcbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XFxuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXFxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXFxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcXG4gICAgfVxcblxcbiAgICByZXMucHVzaChjb2RlUG9pbnQpXFxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxcbiAgfVxcblxcbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXFxufVxcblxcbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XFxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXFxuXFxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XFxuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXFxuICB9XFxuXFxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFxcXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcXFwiLlxcbiAgdmFyIHJlcyA9ICcnXFxuICB2YXIgaSA9IDBcXG4gIHdoaWxlIChpIDwgbGVuKSB7XFxuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxcbiAgICAgIFN0cmluZyxcXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXFxuICAgIClcXG4gIH1cXG4gIHJldHVybiByZXNcXG59XFxuXFxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XFxuICB2YXIgcmV0ID0gJydcXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcXG5cXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XFxuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXFxuICB9XFxuICByZXR1cm4gcmV0XFxufVxcblxcbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciByZXQgPSAnJ1xcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxcblxcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcXG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxcbiAgfVxcbiAgcmV0dXJuIHJldFxcbn1cXG5cXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XFxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxcblxcbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxcblxcbiAgdmFyIG91dCA9ICcnXFxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxcbiAgfVxcbiAgcmV0dXJuIG91dFxcbn1cXG5cXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXFxuICB2YXIgcmVzID0gJydcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcXG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcXG4gIH1cXG4gIHJldHVybiByZXNcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XFxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcXG4gIHN0YXJ0ID0gfn5zdGFydFxcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxcblxcbiAgaWYgKHN0YXJ0IDwgMCkge1xcbiAgICBzdGFydCArPSBsZW5cXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XFxuICAgIHN0YXJ0ID0gbGVuXFxuICB9XFxuXFxuICBpZiAoZW5kIDwgMCkge1xcbiAgICBlbmQgKz0gbGVuXFxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xcbiAgICBlbmQgPSBsZW5cXG4gIH1cXG5cXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcXG5cXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXFxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcXG4gIHJldHVybiBuZXdCdWZcXG59XFxuXFxuLypcXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cXG4gKi9cXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcXG5cXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cXG4gIHZhciBtdWwgPSAxXFxuICB2YXIgaSA9IDBcXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXFxuICB9XFxuXFxuICByZXR1cm4gdmFsXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcXG4gIH1cXG5cXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cXG4gIHZhciBtdWwgPSAxXFxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxcbiAgfVxcblxcbiAgcmV0dXJuIHZhbFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXFxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcXG5cXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcXG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcXG5cXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXFxuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxcblxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciBpID0gMFxcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcXG4gIH1cXG4gIG11bCAqPSAweDgwXFxuXFxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxcblxcbiAgcmV0dXJuIHZhbFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcXG5cXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXFxuICB9XFxuICBtdWwgKj0gMHg4MFxcblxcbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcXG5cXG4gIHJldHVybiB2YWxcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXFxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXFxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXFxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXFxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuXFxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcXG5cXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcXG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXFxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXFxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxcbn1cXG5cXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XFxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwiYnVmZmVyXFxcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcXCJ2YWx1ZVxcXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXFxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSB7XFxuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXFxuICB9XFxuXFxuICB2YXIgbXVsID0gMVxcbiAgdmFyIGkgPSAwXFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxcbiAgfVxcblxcbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcXG4gIH1cXG5cXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcXG4gIHZhciBtdWwgPSAxXFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXFxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXFxuICB9XFxuXFxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICByZXR1cm4gb2Zmc2V0ICsgMVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXFxuICByZXR1cm4gb2Zmc2V0ICsgMlxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICByZXR1cm4gb2Zmc2V0ICsgMlxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXFxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcXG4gIHJldHVybiBvZmZzZXQgKyA0XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxcbiAgcmV0dXJuIG9mZnNldCArIDRcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXFxuXFxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxcbiAgfVxcblxcbiAgdmFyIGkgPSAwXFxuICB2YXIgbXVsID0gMVxcbiAgdmFyIHN1YiA9IDBcXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcXG4gICAgICBzdWIgPSAxXFxuICAgIH1cXG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxcbiAgfVxcblxcbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXFxuXFxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxcbiAgfVxcblxcbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciBzdWIgPSAwXFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXFxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcXG4gICAgICBzdWIgPSAxXFxuICAgIH1cXG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxcbiAgfVxcblxcbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcXG4gIHJldHVybiBvZmZzZXQgKyAxXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXFxuICByZXR1cm4gb2Zmc2V0ICsgMlxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxcbiAgcmV0dXJuIG9mZnNldCArIDJcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXFxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcXG4gIHJldHVybiBvZmZzZXQgKyA0XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXFxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXFxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXFxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcXG4gIHJldHVybiBvZmZzZXQgKyA0XFxufVxcblxcbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XFxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXFxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXFxufVxcblxcbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcXG4gIH1cXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxcbiAgcmV0dXJuIG9mZnNldCArIDRcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXFxufVxcblxcbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcXG4gIH1cXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxcbiAgcmV0dXJuIG9mZnNldCArIDhcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXFxufVxcblxcbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XFxuXFxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXFxuXFxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXFxuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcXG4gIH1cXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxcblxcbiAgLy8gQXJlIHdlIG9vYj9cXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxcbiAgfVxcblxcbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XFxuICB2YXIgaVxcblxcbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XFxuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXFxuICAgIH1cXG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCkge1xcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxcbiAgICAgIHRhcmdldCxcXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXFxuICAgICAgdGFyZ2V0U3RhcnRcXG4gICAgKVxcbiAgfVxcblxcbiAgcmV0dXJuIGxlblxcbn1cXG5cXG4vLyBVc2FnZTpcXG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XFxuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XFxuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgZW5jb2RpbmcgPSBzdGFydFxcbiAgICAgIHN0YXJ0ID0gMFxcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcXG4gICAgICBlbmNvZGluZyA9IGVuZFxcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXFxuICAgIH1cXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcXG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXFxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcXG4gICAgICAgIHZhbCA9IGNvZGVcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxcbiAgICB9XFxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXFxuICAgIH1cXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcXG4gICAgdmFsID0gdmFsICYgMjU1XFxuICB9XFxuXFxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcXG4gIH1cXG5cXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcXG4gICAgcmV0dXJuIHRoaXNcXG4gIH1cXG5cXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcXG5cXG4gIGlmICghdmFsKSB2YWwgPSAwXFxuXFxuICB2YXIgaVxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcXG4gICAgICB0aGlzW2ldID0gdmFsXFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXFxuICAgICAgPyB2YWxcXG4gICAgICA6IG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZylcXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzXFxufVxcblxcbi8vIEhFTFBFUiBGVU5DVElPTlNcXG4vLyA9PT09PT09PT09PT09PT09XFxuXFxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xcblxcbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXFxcbiBhbmQgXFxcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcXG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXFxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXFxuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcXG4gICAgc3RyID0gc3RyICsgJz0nXFxuICB9XFxuICByZXR1cm4gc3RyXFxufVxcblxcbmZ1bmN0aW9uIHRvSGV4IChuKSB7XFxuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxcbn1cXG5cXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxcbiAgdmFyIGNvZGVQb2ludFxcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxcbiAgdmFyIGJ5dGVzID0gW11cXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcXG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcXG5cXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XFxuICAgICAgICAvLyBubyBsZWFkIHlldFxcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxcbiAgICAgICAgICBjb250aW51ZVxcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XFxuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXFxuICAgICAgICAgIGNvbnRpbnVlXFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyB2YWxpZCBsZWFkXFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XFxuXFxuICAgICAgICBjb250aW51ZVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XFxuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XFxuICAgICAgICBjb250aW51ZVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XFxuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxcbiAgICB9XFxuXFxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXFxuXFxuICAgIC8vIGVuY29kZSB1dGY4XFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XFxuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXFxuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXFxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcXG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcXG4gICAgICBieXRlcy5wdXNoKFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxcbiAgICAgIClcXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXFxuICAgICAgYnl0ZXMucHVzaChcXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcXG4gICAgICApXFxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcXG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcXG4gICAgICBieXRlcy5wdXNoKFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcXG4gICAgICApXFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gYnl0ZXNcXG59XFxuXFxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcXG4gIHZhciBieXRlQXJyYXkgPSBbXVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcXG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXFxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcXG4gIH1cXG4gIHJldHVybiBieXRlQXJyYXlcXG59XFxuXFxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcXG4gIHZhciBjLCBoaSwgbG9cXG4gIHZhciBieXRlQXJyYXkgPSBbXVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcXG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXFxuXFxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxcbiAgICBoaSA9IGMgPj4gOFxcbiAgICBsbyA9IGMgJSAyNTZcXG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXFxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxcbiAgfVxcblxcbiAgcmV0dXJuIGJ5dGVBcnJheVxcbn1cXG5cXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcXG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcXG59XFxuXFxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XFxuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXFxuICB9XFxuICByZXR1cm4gaVxcbn1cXG5cXG4vLyBBcnJheUJ1ZmZlcnMgZnJvbSBhbm90aGVyIGNvbnRleHQgKGkuZS4gYW4gaWZyYW1lKSBkbyBub3QgcGFzcyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrXFxuLy8gYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgdmFsaWQuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIgKG9iaikge1xcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5QnVmZmVyJyAmJlxcbiAgICAgIHR5cGVvZiBvYmouYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpXFxufVxcblxcbi8vIE5vZGUgMC4xMCBzdXBwb3J0cyBgQXJyYXlCdWZmZXJgIGJ1dCBsYWNrcyBgQXJyYXlCdWZmZXIuaXNWaWV3YFxcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3IChvYmopIHtcXG4gIHJldHVybiAodHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KG9iailcXG59XFxuXFxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXFxufVxcblxcbn0se1xcXCJiYXNlNjQtanNcXFwiOjM3LFxcXCJpZWVlNzU0XFxcIjo0OX1dLDQyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKEJ1ZmZlcil7XFxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXFxuXFxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcXG4gIGlmIChBcnJheS5pc0FycmF5KSB7XFxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XFxuICB9XFxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcXG59XFxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcXG5cXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xcbn1cXG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcXG5cXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XFxuICByZXR1cm4gYXJnID09PSBudWxsO1xcbn1cXG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcXG5cXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcXG4gIHJldHVybiBhcmcgPT0gbnVsbDtcXG59XFxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xcblxcbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xcbn1cXG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XFxuXFxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XFxufVxcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcXG5cXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcXG59XFxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xcblxcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xcbn1cXG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XFxuXFxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcXG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xcbn1cXG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XFxuXFxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xcbn1cXG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XFxuXFxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcXG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xcbn1cXG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcXG5cXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcXG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcXG59XFxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcXG5cXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XFxufVxcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XFxuXFxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XFxuICByZXR1cm4gYXJnID09PSBudWxsIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XFxufVxcbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcXG5cXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xcblxcbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XFxufVxcblxcbn0pLmNhbGwodGhpcyx7XFxcImlzQnVmZmVyXFxcIjpyZXF1aXJlKFxcXCIuLi8uLi9pcy1idWZmZXIvaW5kZXguanNcXFwiKX0pXFxufSx7XFxcIi4uLy4uL2lzLWJ1ZmZlci9pbmRleC5qc1xcXCI6NTF9XSw0MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4vKipcXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXFxuICpcXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xcbmV4cG9ydHMubG9nID0gbG9nO1xcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XFxuZXhwb3J0cy5zYXZlID0gc2F2ZTtcXG5leHBvcnRzLmxvYWQgPSBsb2FkO1xcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcXG5cXG4vKipcXG4gKiBDb2xvcnMuXFxuICovXFxuXFxuZXhwb3J0cy5jb2xvcnMgPSBbXFxuICAnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsXFxuICAnIzAwOTlGRicsICcjMDBDQzAwJywgJyMwMENDMzMnLCAnIzAwQ0M2NicsICcjMDBDQzk5JywgJyMwMENDQ0MnLCAnIzAwQ0NGRicsXFxuICAnIzMzMDBDQycsICcjMzMwMEZGJywgJyMzMzMzQ0MnLCAnIzMzMzNGRicsICcjMzM2NkNDJywgJyMzMzY2RkYnLCAnIzMzOTlDQycsXFxuICAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsXFxuICAnIzY2MDBDQycsICcjNjYwMEZGJywgJyM2NjMzQ0MnLCAnIzY2MzNGRicsICcjNjZDQzAwJywgJyM2NkNDMzMnLCAnIzk5MDBDQycsXFxuICAnIzk5MDBGRicsICcjOTkzM0NDJywgJyM5OTMzRkYnLCAnIzk5Q0MwMCcsICcjOTlDQzMzJywgJyNDQzAwMDAnLCAnI0NDMDAzMycsXFxuICAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsXFxuICAnI0NDMzM5OScsICcjQ0MzM0NDJywgJyNDQzMzRkYnLCAnI0NDNjYwMCcsICcjQ0M2NjMzJywgJyNDQzk5MDAnLCAnI0NDOTkzMycsXFxuICAnI0NDQ0MwMCcsICcjQ0NDQzMzJywgJyNGRjAwMDAnLCAnI0ZGMDAzMycsICcjRkYwMDY2JywgJyNGRjAwOTknLCAnI0ZGMDBDQycsXFxuICAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsXFxuICAnI0ZGNjYwMCcsICcjRkY2NjMzJywgJyNGRjk5MDAnLCAnI0ZGOTkzMycsICcjRkZDQzAwJywgJyNGRkNDMzMnXFxuXTtcXG5cXG4vKipcXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxcbiAqIHRvIHN1cHBvcnQgXFxcIiVjXFxcIiBDU1MgY3VzdG9taXphdGlvbnMuXFxuICpcXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xcbiAqL1xcblxcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcXG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcXG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXFxuICAvLyBleHBsaWNpdGx5XFxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH1cXG5cXG4gIC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cXG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXFxcLyhcXFxcZCspLykpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXFxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcXG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXFxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcXFwvKFxcXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcXG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFxcXC8oXFxcXGQrKS8pKTtcXG59XFxuXFxuLyoqXFxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxcbiAqL1xcblxcbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xcbiAgdHJ5IHtcXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xcbiAgfSBjYXRjaCAoZXJyKSB7XFxuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcXG4gIH1cXG59O1xcblxcblxcbi8qKlxcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuXFxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XFxuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XFxuXFxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcXG4gICAgKyBhcmdzWzBdXFxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcXG5cXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XFxuXFxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XFxuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKVxcblxcbiAgLy8gdGhlIGZpbmFsIFxcXCIlY1xcXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXFxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXFxuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cXG4gIHZhciBpbmRleCA9IDA7XFxuICB2YXIgbGFzdEMgPSAwO1xcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XFxuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xcbiAgICBpbmRleCsrO1xcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcXG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxcbiAgICAgIGxhc3RDID0gaW5kZXg7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xcbn1cXG5cXG4vKipcXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXFxcImZ1bmN0aW9uXFxcIi5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuXFxuZnVuY3Rpb24gbG9nKCkge1xcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXFxuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXFxuICAgICYmIGNvbnNvbGUubG9nXFxuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xcbn1cXG5cXG4vKipcXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cXG4gKlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XFxuICB0cnkge1xcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XFxuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcXG4gICAgfVxcbiAgfSBjYXRjaChlKSB7fVxcbn1cXG5cXG4vKipcXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cXG4gKlxcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5mdW5jdGlvbiBsb2FkKCkge1xcbiAgdmFyIHI7XFxuICB0cnkge1xcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xcbiAgfSBjYXRjaChlKSB7fVxcblxcbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XFxuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcXG4gIH1cXG5cXG4gIHJldHVybiByO1xcbn1cXG5cXG4vKipcXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxcbiAqL1xcblxcbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XFxuXFxuLyoqXFxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxcbiAqXFxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXFxuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxcbiAqXFxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcXG4gIHRyeSB7XFxuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xcbiAgfSBjYXRjaCAoZSkge31cXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4vZGVidWdcXFwiOjQ0LFxcXCJfcHJvY2Vzc1xcXCI6NTZ9XSw0NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuXFxuLyoqXFxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXFxuICpcXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XFxuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XFxuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcXG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcXG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xcblxcbi8qKlxcbiAqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cXG4gKi9cXG5leHBvcnRzLmluc3RhbmNlcyA9IFtdO1xcblxcbi8qKlxcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxcbiAqL1xcblxcbmV4cG9ydHMubmFtZXMgPSBbXTtcXG5leHBvcnRzLnNraXBzID0gW107XFxuXFxuLyoqXFxuICogTWFwIG9mIHNwZWNpYWwgXFxcIiVuXFxcIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXFxcImZvcm1hdFxcXCIgYXJndW1lbnQuXFxuICpcXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcXFwiblxcXCIgYW5kIFxcXCJOXFxcIi5cXG4gKi9cXG5cXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcXG5cXG4vKipcXG4gKiBTZWxlY3QgYSBjb2xvci5cXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXFxuICogQHJldHVybiB7TnVtYmVyfVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xcbiAgdmFyIGhhc2ggPSAwLCBpO1xcblxcbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XFxuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXFxuICB9XFxuXFxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xcbn1cXG5cXG4vKipcXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cXG4gKlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xcblxcbiAgdmFyIHByZXZUaW1lO1xcblxcbiAgZnVuY3Rpb24gZGVidWcoKSB7XFxuICAgIC8vIGRpc2FibGVkP1xcbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcXG5cXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcXG5cXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcXG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcXG4gICAgc2VsZi5kaWZmID0gbXM7XFxuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xcbiAgICBwcmV2VGltZSA9IGN1cnI7XFxuXFxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcXG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XFxuICAgIH1cXG5cXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xcblxcbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XFxuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XFxuICAgIH1cXG5cXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcXG4gICAgdmFyIGluZGV4ID0gMDtcXG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcXG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XFxuICAgICAgaW5kZXgrKztcXG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XFxuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcXG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcXG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcXG5cXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcXG4gICAgICAgIGluZGV4LS07XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBtYXRjaDtcXG4gICAgfSk7XFxuXFxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXFxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xcblxcbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcXG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XFxuICB9XFxuXFxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XFxuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XFxuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xcbiAgZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XFxuXFxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcXG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcXG4gIH1cXG5cXG4gIGV4cG9ydHMuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xcblxcbiAgcmV0dXJuIGRlYnVnO1xcbn1cXG5cXG5mdW5jdGlvbiBkZXN0cm95ICgpIHtcXG4gIHZhciBpbmRleCA9IGV4cG9ydHMuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XFxuICBpZiAoaW5kZXggIT09IC0xKSB7XFxuICAgIGV4cG9ydHMuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXFxuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cXG4gKlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5cXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xcblxcbiAgZXhwb3J0cy5uYW1lcyA9IFtdO1xcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xcblxcbiAgdmFyIGk7XFxuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xcXFxzLF0rLyk7XFxuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xcblxcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFxcXCovZywgJy4qPycpO1xcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XFxuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZvciAoaSA9IDA7IGkgPCBleHBvcnRzLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgaW5zdGFuY2UgPSBleHBvcnRzLmluc3RhbmNlc1tpXTtcXG4gICAgaW5zdGFuY2UuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuXFxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcXG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxcbiAqXFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcXG4gKiBAcmV0dXJuIHtCb29sZWFufVxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuXFxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XFxuICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuICB2YXIgaSwgbGVuO1xcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICB9XFxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGZhbHNlO1xcbn1cXG5cXG4vKipcXG4gKiBDb2VyY2UgYHZhbGAuXFxuICpcXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcXG4gKiBAcmV0dXJuIHtNaXhlZH1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XFxuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XFxuICByZXR1cm4gdmFsO1xcbn1cXG5cXG59LHtcXFwibXNcXFwiOjU0fV0sNDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qIVxcblxcbiBkaWZmIHYzLjUuMFxcblxcblNvZnR3YXJlIExpY2Vuc2UgQWdyZWVtZW50IChCU0QgTGljZW5zZSlcXG5cXG5Db3B5cmlnaHQgKGMpIDIwMDktMjAxNSwgS2V2aW4gRGVja2VyIDxrcGRlY2tlckBnbWFpbC5jb20+XFxuXFxuQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG5cXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIG9mIHRoaXMgc29mdHdhcmUgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxcblxcbiogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxcbiAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZVxcbiAgZm9sbG93aW5nIGRpc2NsYWltZXIuXFxuXFxuKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXFxuICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlXFxuICBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXJcXG4gIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXFxuXFxuKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEtldmluIERlY2tlciBub3IgdGhlIG5hbWVzIG9mIGl0c1xcbiAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xcbiAgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvclxcbiAgd3JpdHRlbiBwZXJtaXNzaW9uLlxcblxcblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXFxcIkFTIElTXFxcIiBBTkQgQU5ZIEVYUFJFU1MgT1JcXG5JTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkRcXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxcbkNPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcXG5EQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXFxuREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVJcXG5JTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUXFxuT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxcbkBsaWNlbnNlXFxuKi9cXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xcblxcdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JylcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcXG5cXHRlbHNlIGlmKGZhbHNlKVxcblxcdFxcdGRlZmluZShbXSwgZmFjdG9yeSk7XFxuXFx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXFxuXFx0XFx0ZXhwb3J0c1tcXFwiSnNEaWZmXFxcIl0gPSBmYWN0b3J5KCk7XFxuXFx0ZWxzZVxcblxcdFxcdHJvb3RbXFxcIkpzRGlmZlxcXCJdID0gZmFjdG9yeSgpO1xcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXFxuLyoqKioqKi8gXFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxcbi8qKioqKiovIFxcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XFxuXFxuLyoqKioqKi8gXFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cXG4vKioqKioqLyBcXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XFxuXFxuLyoqKioqKi8gXFx0XFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXFxuLyoqKioqKi8gXFx0XFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXFxuLyoqKioqKi8gXFx0XFx0XFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XFxuXFxuLyoqKioqKi8gXFx0XFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcXG4vKioqKioqLyBcXHRcXHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XFxuLyoqKioqKi8gXFx0XFx0XFx0ZXhwb3J0czoge30sXFxuLyoqKioqKi8gXFx0XFx0XFx0aWQ6IG1vZHVsZUlkLFxcbi8qKioqKiovIFxcdFxcdFxcdGxvYWRlZDogZmFsc2VcXG4vKioqKioqLyBcXHRcXHR9O1xcblxcbi8qKioqKiovIFxcdFxcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxcbi8qKioqKiovIFxcdFxcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xcblxcbi8qKioqKiovIFxcdFxcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcXG4vKioqKioqLyBcXHRcXHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcXG5cXG4vKioqKioqLyBcXHRcXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxcbi8qKioqKiovIFxcdFxcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcXG4vKioqKioqLyBcXHR9XFxuXFxuXFxuLyoqKioqKi8gXFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xcblxcbi8qKioqKiovIFxcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcXG5cXG4vKioqKioqLyBcXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFxcXCJcXFwiO1xcblxcbi8qKioqKiovIFxcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xcbi8qKioqKiovIFxcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xcbi8qKioqKiovIH0pXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKioqKioqLyAoW1xcbi8qIDAgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcdGV4cG9ydHMuY2Fub25pY2FsaXplID0gZXhwb3J0cy5jb252ZXJ0Q2hhbmdlc1RvWE1MID0gZXhwb3J0cy5jb252ZXJ0Q2hhbmdlc1RvRE1QID0gZXhwb3J0cy5tZXJnZSA9IGV4cG9ydHMucGFyc2VQYXRjaCA9IGV4cG9ydHMuYXBwbHlQYXRjaGVzID0gZXhwb3J0cy5hcHBseVBhdGNoID0gZXhwb3J0cy5jcmVhdGVQYXRjaCA9IGV4cG9ydHMuY3JlYXRlVHdvRmlsZXNQYXRjaCA9IGV4cG9ydHMuc3RydWN0dXJlZFBhdGNoID0gZXhwb3J0cy5kaWZmQXJyYXlzID0gZXhwb3J0cy5kaWZmSnNvbiA9IGV4cG9ydHMuZGlmZkNzcyA9IGV4cG9ydHMuZGlmZlNlbnRlbmNlcyA9IGV4cG9ydHMuZGlmZlRyaW1tZWRMaW5lcyA9IGV4cG9ydHMuZGlmZkxpbmVzID0gZXhwb3J0cy5kaWZmV29yZHNXaXRoU3BhY2UgPSBleHBvcnRzLmRpZmZXb3JkcyA9IGV4cG9ydHMuZGlmZkNoYXJzID0gZXhwb3J0cy5EaWZmID0gdW5kZWZpbmVkO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIGVuZCovdmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3ZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2NoYXJhY3RlciA9IF9fd2VicGFja19yZXF1aXJlX18oMikgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fd29yZCA9IF9fd2VicGFja19yZXF1aXJlX18oMykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fbGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fc2VudGVuY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2NzcyA9IF9fd2VicGFja19yZXF1aXJlX18oNykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fanNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oOCkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2FwcGx5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fcGFyc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19tZXJnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2NyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2RtcCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3htbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XFxuXFxuXFx0LyogU2VlIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMgb2YgdXNlICovXFxuXFxuXFx0LypcXG5cXHQgKiBUZXh0IGRpZmYgaW1wbGVtZW50YXRpb24uXFxuXFx0ICpcXG5cXHQgKiBUaGlzIGxpYnJhcnkgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBBUElTOlxcblxcdCAqIEpzRGlmZi5kaWZmQ2hhcnM6IENoYXJhY3RlciBieSBjaGFyYWN0ZXIgZGlmZlxcblxcdCAqIEpzRGlmZi5kaWZmV29yZHM6IFdvcmQgKGFzIGRlZmluZWQgYnkgXFxcXGIgcmVnZXgpIGRpZmYgd2hpY2ggaWdub3JlcyB3aGl0ZXNwYWNlXFxuXFx0ICogSnNEaWZmLmRpZmZMaW5lczogTGluZSBiYXNlZCBkaWZmXFxuXFx0ICpcXG5cXHQgKiBKc0RpZmYuZGlmZkNzczogRGlmZiB0YXJnZXRlZCBhdCBDU1MgY29udGVudFxcblxcdCAqXFxuXFx0ICogVGhlc2UgbWV0aG9kcyBhcmUgYmFzZWQgb24gdGhlIGltcGxlbWVudGF0aW9uIHByb3Bvc2VkIGluXFxuXFx0ICogXFxcIkFuIE8oTkQpIERpZmZlcmVuY2UgQWxnb3JpdGhtIGFuZCBpdHMgVmFyaWF0aW9uc1xcXCIgKE15ZXJzLCAxOTg2KS5cXG5cXHQgKiBodHRwOi8vY2l0ZXNlZXJ4LmlzdC5wc3UuZWR1L3ZpZXdkb2Mvc3VtbWFyeT9kb2k9MTAuMS4xLjQuNjkyN1xcblxcdCAqL1xcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovRGlmZiA9IF9iYXNlMlsnZGVmYXVsdCddO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZDaGFycyA9IF9jaGFyYWN0ZXIuZGlmZkNoYXJzO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZXb3JkcyA9IF93b3JkLmRpZmZXb3JkcztcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmV29yZHNXaXRoU3BhY2UgPSBfd29yZC5kaWZmV29yZHNXaXRoU3BhY2U7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZkxpbmVzID0gX2xpbmUuZGlmZkxpbmVzO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZUcmltbWVkTGluZXMgPSBfbGluZS5kaWZmVHJpbW1lZExpbmVzO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZTZW50ZW5jZXMgPSBfc2VudGVuY2UuZGlmZlNlbnRlbmNlcztcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmQ3NzID0gX2Nzcy5kaWZmQ3NzO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZKc29uID0gX2pzb24uZGlmZkpzb247XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZkFycmF5cyA9IF9hcnJheS5kaWZmQXJyYXlzO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3N0cnVjdHVyZWRQYXRjaCA9IF9jcmVhdGUuc3RydWN0dXJlZFBhdGNoO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NyZWF0ZVR3b0ZpbGVzUGF0Y2ggPSBfY3JlYXRlLmNyZWF0ZVR3b0ZpbGVzUGF0Y2g7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY3JlYXRlUGF0Y2ggPSBfY3JlYXRlLmNyZWF0ZVBhdGNoO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2FwcGx5UGF0Y2ggPSBfYXBwbHkuYXBwbHlQYXRjaDtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9hcHBseVBhdGNoZXMgPSBfYXBwbHkuYXBwbHlQYXRjaGVzO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3BhcnNlUGF0Y2ggPSBfcGFyc2UucGFyc2VQYXRjaDtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9tZXJnZSA9IF9tZXJnZS5tZXJnZTtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jb252ZXJ0Q2hhbmdlc1RvRE1QID0gX2RtcC5jb252ZXJ0Q2hhbmdlc1RvRE1QO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NvbnZlcnRDaGFuZ2VzVG9YTUwgPSBfeG1sLmNvbnZlcnRDaGFuZ2VzVG9YTUw7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY2Fub25pY2FsaXplID0gX2pzb24uY2Fub25pY2FsaXplO1xcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDEgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovRGlmZjtcXG5cXHRmdW5jdGlvbiBEaWZmKCkge31cXG5cXG5cXHREaWZmLnByb3RvdHlwZSA9IHtcXG5cXHQgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmOiBmdW5jdGlvbiBkaWZmKG9sZFN0cmluZywgbmV3U3RyaW5nKSB7XFxuXFx0ICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9vcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcXG5cXG5cXHQgICAgdmFyIGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcXG5cXHQgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XFxuXFx0ICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xcblxcdCAgICAgIG9wdGlvbnMgPSB7fTtcXG5cXHQgICAgfVxcblxcdCAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xcblxcblxcdCAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuXFx0ICAgIGZ1bmN0aW9uIGRvbmUodmFsdWUpIHtcXG5cXHQgICAgICBpZiAoY2FsbGJhY2spIHtcXG5cXHQgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcblxcdCAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIHZhbHVlKTtcXG5cXHQgICAgICAgIH0sIDApO1xcblxcdCAgICAgICAgcmV0dXJuIHRydWU7XFxuXFx0ICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgIHJldHVybiB2YWx1ZTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgLy8gQWxsb3cgc3ViY2xhc3NlcyB0byBtYXNzYWdlIHRoZSBpbnB1dCBwcmlvciB0byBydW5uaW5nXFxuXFx0ICAgIG9sZFN0cmluZyA9IHRoaXMuY2FzdElucHV0KG9sZFN0cmluZyk7XFxuXFx0ICAgIG5ld1N0cmluZyA9IHRoaXMuY2FzdElucHV0KG5ld1N0cmluZyk7XFxuXFxuXFx0ICAgIG9sZFN0cmluZyA9IHRoaXMucmVtb3ZlRW1wdHkodGhpcy50b2tlbml6ZShvbGRTdHJpbmcpKTtcXG5cXHQgICAgbmV3U3RyaW5nID0gdGhpcy5yZW1vdmVFbXB0eSh0aGlzLnRva2VuaXplKG5ld1N0cmluZykpO1xcblxcblxcdCAgICB2YXIgbmV3TGVuID0gbmV3U3RyaW5nLmxlbmd0aCxcXG5cXHQgICAgICAgIG9sZExlbiA9IG9sZFN0cmluZy5sZW5ndGg7XFxuXFx0ICAgIHZhciBlZGl0TGVuZ3RoID0gMTtcXG5cXHQgICAgdmFyIG1heEVkaXRMZW5ndGggPSBuZXdMZW4gKyBvbGRMZW47XFxuXFx0ICAgIHZhciBiZXN0UGF0aCA9IFt7IG5ld1BvczogLTEsIGNvbXBvbmVudHM6IFtdIH1dO1xcblxcblxcdCAgICAvLyBTZWVkIGVkaXRMZW5ndGggPSAwLCBpLmUuIHRoZSBjb250ZW50IHN0YXJ0cyB3aXRoIHRoZSBzYW1lIHZhbHVlc1xcblxcdCAgICB2YXIgb2xkUG9zID0gdGhpcy5leHRyYWN0Q29tbW9uKGJlc3RQYXRoWzBdLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgMCk7XFxuXFx0ICAgIGlmIChiZXN0UGF0aFswXS5uZXdQb3MgKyAxID49IG5ld0xlbiAmJiBvbGRQb3MgKyAxID49IG9sZExlbikge1xcblxcdCAgICAgIC8vIElkZW50aXR5IHBlciB0aGUgZXF1YWxpdHkgYW5kIHRva2VuaXplclxcblxcdCAgICAgIHJldHVybiBkb25lKFt7IHZhbHVlOiB0aGlzLmpvaW4obmV3U3RyaW5nKSwgY291bnQ6IG5ld1N0cmluZy5sZW5ndGggfV0pO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIE1haW4gd29ya2VyIG1ldGhvZC4gY2hlY2tzIGFsbCBwZXJtdXRhdGlvbnMgb2YgYSBnaXZlbiBlZGl0IGxlbmd0aCBmb3IgYWNjZXB0YW5jZS5cXG5cXHQgICAgZnVuY3Rpb24gZXhlY0VkaXRMZW5ndGgoKSB7XFxuXFx0ICAgICAgZm9yICh2YXIgZGlhZ29uYWxQYXRoID0gLTEgKiBlZGl0TGVuZ3RoOyBkaWFnb25hbFBhdGggPD0gZWRpdExlbmd0aDsgZGlhZ29uYWxQYXRoICs9IDIpIHtcXG5cXHQgICAgICAgIHZhciBiYXNlUGF0aCA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92b2lkIDAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFx0ICAgICAgICB2YXIgYWRkUGF0aCA9IGJlc3RQYXRoW2RpYWdvbmFsUGF0aCAtIDFdLFxcblxcdCAgICAgICAgICAgIHJlbW92ZVBhdGggPSBiZXN0UGF0aFtkaWFnb25hbFBhdGggKyAxXSxcXG5cXHQgICAgICAgICAgICBfb2xkUG9zID0gKHJlbW92ZVBhdGggPyByZW1vdmVQYXRoLm5ld1BvcyA6IDApIC0gZGlhZ29uYWxQYXRoO1xcblxcdCAgICAgICAgaWYgKGFkZFBhdGgpIHtcXG5cXHQgICAgICAgICAgLy8gTm8gb25lIGVsc2UgaXMgZ29pbmcgdG8gYXR0ZW1wdCB0byB1c2UgdGhpcyB2YWx1ZSwgY2xlYXIgaXRcXG5cXHQgICAgICAgICAgYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0gPSB1bmRlZmluZWQ7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB2YXIgY2FuQWRkID0gYWRkUGF0aCAmJiBhZGRQYXRoLm5ld1BvcyArIDEgPCBuZXdMZW4sXFxuXFx0ICAgICAgICAgICAgY2FuUmVtb3ZlID0gcmVtb3ZlUGF0aCAmJiAwIDw9IF9vbGRQb3MgJiYgX29sZFBvcyA8IG9sZExlbjtcXG5cXHQgICAgICAgIGlmICghY2FuQWRkICYmICFjYW5SZW1vdmUpIHtcXG5cXHQgICAgICAgICAgLy8gSWYgdGhpcyBwYXRoIGlzIGEgdGVybWluYWwgdGhlbiBwcnVuZVxcblxcdCAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gdW5kZWZpbmVkO1xcblxcdCAgICAgICAgICBjb250aW51ZTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIC8vIFNlbGVjdCB0aGUgZGlhZ29uYWwgdGhhdCB3ZSB3YW50IHRvIGJyYW5jaCBmcm9tLiBXZSBzZWxlY3QgdGhlIHByaW9yXFxuXFx0ICAgICAgICAvLyBwYXRoIHdob3NlIHBvc2l0aW9uIGluIHRoZSBuZXcgc3RyaW5nIGlzIHRoZSBmYXJ0aGVzdCBmcm9tIHRoZSBvcmlnaW5cXG5cXHQgICAgICAgIC8vIGFuZCBkb2VzIG5vdCBwYXNzIHRoZSBib3VuZHMgb2YgdGhlIGRpZmYgZ3JhcGhcXG5cXHQgICAgICAgIGlmICghY2FuQWRkIHx8IGNhblJlbW92ZSAmJiBhZGRQYXRoLm5ld1BvcyA8IHJlbW92ZVBhdGgubmV3UG9zKSB7XFxuXFx0ICAgICAgICAgIGJhc2VQYXRoID0gY2xvbmVQYXRoKHJlbW92ZVBhdGgpO1xcblxcdCAgICAgICAgICBzZWxmLnB1c2hDb21wb25lbnQoYmFzZVBhdGguY29tcG9uZW50cywgdW5kZWZpbmVkLCB0cnVlKTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgIGJhc2VQYXRoID0gYWRkUGF0aDsgLy8gTm8gbmVlZCB0byBjbG9uZSwgd2UndmUgcHVsbGVkIGl0IGZyb20gdGhlIGxpc3RcXG5cXHQgICAgICAgICAgYmFzZVBhdGgubmV3UG9zKys7XFxuXFx0ICAgICAgICAgIHNlbGYucHVzaENvbXBvbmVudChiYXNlUGF0aC5jb21wb25lbnRzLCB0cnVlLCB1bmRlZmluZWQpO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgX29sZFBvcyA9IHNlbGYuZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCk7XFxuXFxuXFx0ICAgICAgICAvLyBJZiB3ZSBoYXZlIGhpdCB0aGUgZW5kIG9mIGJvdGggc3RyaW5ncywgdGhlbiB3ZSBhcmUgZG9uZVxcblxcdCAgICAgICAgaWYgKGJhc2VQYXRoLm5ld1BvcyArIDEgPj0gbmV3TGVuICYmIF9vbGRQb3MgKyAxID49IG9sZExlbikge1xcblxcdCAgICAgICAgICByZXR1cm4gZG9uZShidWlsZFZhbHVlcyhzZWxmLCBiYXNlUGF0aC5jb21wb25lbnRzLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgc2VsZi51c2VMb25nZXN0VG9rZW4pKTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgIC8vIE90aGVyd2lzZSB0cmFjayB0aGlzIHBhdGggYXMgYSBwb3RlbnRpYWwgY2FuZGlkYXRlIGFuZCBjb250aW51ZS5cXG5cXHQgICAgICAgICAgYmVzdFBhdGhbZGlhZ29uYWxQYXRoXSA9IGJhc2VQYXRoO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgIH1cXG5cXG5cXHQgICAgICBlZGl0TGVuZ3RoKys7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgLy8gUGVyZm9ybXMgdGhlIGxlbmd0aCBvZiBlZGl0IGl0ZXJhdGlvbi4gSXMgYSBiaXQgZnVnbHkgYXMgdGhpcyBoYXMgdG8gc3VwcG9ydCB0aGVcXG5cXHQgICAgLy8gc3luYyBhbmQgYXN5bmMgbW9kZSB3aGljaCBpcyBuZXZlciBmdW4uIExvb3BzIG92ZXIgZXhlY0VkaXRMZW5ndGggdW50aWwgYSB2YWx1ZVxcblxcdCAgICAvLyBpcyBwcm9kdWNlZC5cXG5cXHQgICAgaWYgKGNhbGxiYWNrKSB7XFxuXFx0ICAgICAgKGZ1bmN0aW9uIGV4ZWMoKSB7XFxuXFx0ICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbiwgYnV0IHdlIHdhbnQgdG8gYmUgc2FmZS5cXG5cXHQgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cXG5cXHQgICAgICAgICAgaWYgKGVkaXRMZW5ndGggPiBtYXhFZGl0TGVuZ3RoKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XFxuXFx0ICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgaWYgKCFleGVjRWRpdExlbmd0aCgpKSB7XFxuXFx0ICAgICAgICAgICAgZXhlYygpO1xcblxcdCAgICAgICAgICB9XFxuXFx0ICAgICAgICB9LCAwKTtcXG5cXHQgICAgICB9KSgpO1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIHdoaWxlIChlZGl0TGVuZ3RoIDw9IG1heEVkaXRMZW5ndGgpIHtcXG5cXHQgICAgICAgIHZhciByZXQgPSBleGVjRWRpdExlbmd0aCgpO1xcblxcdCAgICAgICAgaWYgKHJldCkge1xcblxcdCAgICAgICAgICByZXR1cm4gcmV0O1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgfSxcXG5cXHQgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9wdXNoQ29tcG9uZW50OiBmdW5jdGlvbiBwdXNoQ29tcG9uZW50KGNvbXBvbmVudHMsIGFkZGVkLCByZW1vdmVkKSB7XFxuXFx0ICAgIHZhciBsYXN0ID0gY29tcG9uZW50c1tjb21wb25lbnRzLmxlbmd0aCAtIDFdO1xcblxcdCAgICBpZiAobGFzdCAmJiBsYXN0LmFkZGVkID09PSBhZGRlZCAmJiBsYXN0LnJlbW92ZWQgPT09IHJlbW92ZWQpIHtcXG5cXHQgICAgICAvLyBXZSBuZWVkIHRvIGNsb25lIGhlcmUgYXMgdGhlIGNvbXBvbmVudCBjbG9uZSBvcGVyYXRpb24gaXMganVzdFxcblxcdCAgICAgIC8vIGFzIHNoYWxsb3cgYXJyYXkgY2xvbmVcXG5cXHQgICAgICBjb21wb25lbnRzW2NvbXBvbmVudHMubGVuZ3RoIC0gMV0gPSB7IGNvdW50OiBsYXN0LmNvdW50ICsgMSwgYWRkZWQ6IGFkZGVkLCByZW1vdmVkOiByZW1vdmVkIH07XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgY29tcG9uZW50cy5wdXNoKHsgY291bnQ6IDEsIGFkZGVkOiBhZGRlZCwgcmVtb3ZlZDogcmVtb3ZlZCB9KTtcXG5cXHQgICAgfVxcblxcdCAgfSxcXG5cXHQgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9leHRyYWN0Q29tbW9uOiBmdW5jdGlvbiBleHRyYWN0Q29tbW9uKGJhc2VQYXRoLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgZGlhZ29uYWxQYXRoKSB7XFxuXFx0ICAgIHZhciBuZXdMZW4gPSBuZXdTdHJpbmcubGVuZ3RoLFxcblxcdCAgICAgICAgb2xkTGVuID0gb2xkU3RyaW5nLmxlbmd0aCxcXG5cXHQgICAgICAgIG5ld1BvcyA9IGJhc2VQYXRoLm5ld1BvcyxcXG5cXHQgICAgICAgIG9sZFBvcyA9IG5ld1BvcyAtIGRpYWdvbmFsUGF0aCxcXG5cXHQgICAgICAgIGNvbW1vbkNvdW50ID0gMDtcXG5cXHQgICAgd2hpbGUgKG5ld1BvcyArIDEgPCBuZXdMZW4gJiYgb2xkUG9zICsgMSA8IG9sZExlbiAmJiB0aGlzLmVxdWFscyhuZXdTdHJpbmdbbmV3UG9zICsgMV0sIG9sZFN0cmluZ1tvbGRQb3MgKyAxXSkpIHtcXG5cXHQgICAgICBuZXdQb3MrKztcXG5cXHQgICAgICBvbGRQb3MrKztcXG5cXHQgICAgICBjb21tb25Db3VudCsrO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGlmIChjb21tb25Db3VudCkge1xcblxcdCAgICAgIGJhc2VQYXRoLmNvbXBvbmVudHMucHVzaCh7IGNvdW50OiBjb21tb25Db3VudCB9KTtcXG5cXHQgICAgfVxcblxcblxcdCAgICBiYXNlUGF0aC5uZXdQb3MgPSBuZXdQb3M7XFxuXFx0ICAgIHJldHVybiBvbGRQb3M7XFxuXFx0ICB9LFxcblxcdCAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2VxdWFsczogZnVuY3Rpb24gZXF1YWxzKGxlZnQsIHJpZ2h0KSB7XFxuXFx0ICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGFyYXRvcikge1xcblxcdCAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY29tcGFyYXRvcihsZWZ0LCByaWdodCk7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8IHRoaXMub3B0aW9ucy5pZ25vcmVDYXNlICYmIGxlZnQudG9Mb3dlckNhc2UoKSA9PT0gcmlnaHQudG9Mb3dlckNhc2UoKTtcXG5cXHQgICAgfVxcblxcdCAgfSxcXG5cXHQgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9yZW1vdmVFbXB0eTogZnVuY3Rpb24gcmVtb3ZlRW1wdHkoYXJyYXkpIHtcXG5cXHQgICAgdmFyIHJldCA9IFtdO1xcblxcdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgICAgaWYgKGFycmF5W2ldKSB7XFxuXFx0ICAgICAgICByZXQucHVzaChhcnJheVtpXSk7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICAgIHJldHVybiByZXQ7XFxuXFx0ICB9LFxcblxcdCAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2Nhc3RJbnB1dDogZnVuY3Rpb24gY2FzdElucHV0KHZhbHVlKSB7XFxuXFx0ICAgIHJldHVybiB2YWx1ZTtcXG5cXHQgIH0sXFxuXFx0ICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIC8qaXN0YW5idWwgaWdub3JlIGVuZCovdG9rZW5pemU6IGZ1bmN0aW9uIHRva2VuaXplKHZhbHVlKSB7XFxuXFx0ICAgIHJldHVybiB2YWx1ZS5zcGxpdCgnJyk7XFxuXFx0ICB9LFxcblxcdCAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2pvaW46IGZ1bmN0aW9uIGpvaW4oY2hhcnMpIHtcXG5cXHQgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0ZnVuY3Rpb24gYnVpbGRWYWx1ZXMoZGlmZiwgY29tcG9uZW50cywgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIHVzZUxvbmdlc3RUb2tlbikge1xcblxcdCAgdmFyIGNvbXBvbmVudFBvcyA9IDAsXFxuXFx0ICAgICAgY29tcG9uZW50TGVuID0gY29tcG9uZW50cy5sZW5ndGgsXFxuXFx0ICAgICAgbmV3UG9zID0gMCxcXG5cXHQgICAgICBvbGRQb3MgPSAwO1xcblxcblxcdCAgZm9yICg7IGNvbXBvbmVudFBvcyA8IGNvbXBvbmVudExlbjsgY29tcG9uZW50UG9zKyspIHtcXG5cXHQgICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zXTtcXG5cXHQgICAgaWYgKCFjb21wb25lbnQucmVtb3ZlZCkge1xcblxcdCAgICAgIGlmICghY29tcG9uZW50LmFkZGVkICYmIHVzZUxvbmdlc3RUb2tlbikge1xcblxcdCAgICAgICAgdmFyIHZhbHVlID0gbmV3U3RyaW5nLnNsaWNlKG5ld1BvcywgbmV3UG9zICsgY29tcG9uZW50LmNvdW50KTtcXG5cXHQgICAgICAgIHZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xcblxcdCAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBvbGRTdHJpbmdbb2xkUG9zICsgaV07XFxuXFx0ICAgICAgICAgIHJldHVybiBvbGRWYWx1ZS5sZW5ndGggPiB2YWx1ZS5sZW5ndGggPyBvbGRWYWx1ZSA6IHZhbHVlO1xcblxcdCAgICAgICAgfSk7XFxuXFxuXFx0ICAgICAgICBjb21wb25lbnQudmFsdWUgPSBkaWZmLmpvaW4odmFsdWUpO1xcblxcdCAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICBjb21wb25lbnQudmFsdWUgPSBkaWZmLmpvaW4obmV3U3RyaW5nLnNsaWNlKG5ld1BvcywgbmV3UG9zICsgY29tcG9uZW50LmNvdW50KSk7XFxuXFx0ICAgICAgfVxcblxcdCAgICAgIG5ld1BvcyArPSBjb21wb25lbnQuY291bnQ7XFxuXFxuXFx0ICAgICAgLy8gQ29tbW9uIGNhc2VcXG5cXHQgICAgICBpZiAoIWNvbXBvbmVudC5hZGRlZCkge1xcblxcdCAgICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKG9sZFN0cmluZy5zbGljZShvbGRQb3MsIG9sZFBvcyArIGNvbXBvbmVudC5jb3VudCkpO1xcblxcdCAgICAgIG9sZFBvcyArPSBjb21wb25lbnQuY291bnQ7XFxuXFxuXFx0ICAgICAgLy8gUmV2ZXJzZSBhZGQgYW5kIHJlbW92ZSBzbyByZW1vdmVzIGFyZSBvdXRwdXQgZmlyc3QgdG8gbWF0Y2ggY29tbW9uIGNvbnZlbnRpb25cXG5cXHQgICAgICAvLyBUaGUgZGlmZmluZyBhbGdvcml0aG0gaXMgdGllZCB0byBhZGQgdGhlbiByZW1vdmUgb3V0cHV0IGFuZCB0aGlzIGlzIHRoZSBzaW1wbGVzdFxcblxcdCAgICAgIC8vIHJvdXRlIHRvIGdldCB0aGUgZGVzaXJlZCBvdXRwdXQgd2l0aCBtaW5pbWFsIG92ZXJoZWFkLlxcblxcdCAgICAgIGlmIChjb21wb25lbnRQb3MgJiYgY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXS5hZGRlZCkge1xcblxcdCAgICAgICAgdmFyIHRtcCA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV07XFxuXFx0ICAgICAgICBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdID0gY29tcG9uZW50c1tjb21wb25lbnRQb3NdO1xcblxcdCAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRQb3NdID0gdG1wO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgLy8gU3BlY2lhbCBjYXNlIGhhbmRsZSBmb3Igd2hlbiBvbmUgdGVybWluYWwgaXMgaWdub3JlZCAoaS5lLiB3aGl0ZXNwYWNlKS5cXG5cXHQgIC8vIEZvciB0aGlzIGNhc2Ugd2UgbWVyZ2UgdGhlIHRlcm1pbmFsIGludG8gdGhlIHByaW9yIHN0cmluZyBhbmQgZHJvcCB0aGUgY2hhbmdlLlxcblxcdCAgLy8gVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBmb3Igc3RyaW5nIG1vZGUuXFxuXFx0ICB2YXIgbGFzdENvbXBvbmVudCA9IGNvbXBvbmVudHNbY29tcG9uZW50TGVuIC0gMV07XFxuXFx0ICBpZiAoY29tcG9uZW50TGVuID4gMSAmJiB0eXBlb2YgbGFzdENvbXBvbmVudC52YWx1ZSA9PT0gJ3N0cmluZycgJiYgKGxhc3RDb21wb25lbnQuYWRkZWQgfHwgbGFzdENvbXBvbmVudC5yZW1vdmVkKSAmJiBkaWZmLmVxdWFscygnJywgbGFzdENvbXBvbmVudC52YWx1ZSkpIHtcXG5cXHQgICAgY29tcG9uZW50c1tjb21wb25lbnRMZW4gLSAyXS52YWx1ZSArPSBsYXN0Q29tcG9uZW50LnZhbHVlO1xcblxcdCAgICBjb21wb25lbnRzLnBvcCgpO1xcblxcdCAgfVxcblxcblxcdCAgcmV0dXJuIGNvbXBvbmVudHM7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGNsb25lUGF0aChwYXRoKSB7XFxuXFx0ICByZXR1cm4geyBuZXdQb3M6IHBhdGgubmV3UG9zLCBjb21wb25lbnRzOiBwYXRoLmNvbXBvbmVudHMuc2xpY2UoMCkgfTtcXG5cXHR9XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMiAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0cy5jaGFyYWN0ZXJEaWZmID0gdW5kZWZpbmVkO1xcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZkNoYXJzID0gZGlmZkNoYXJzO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XFxuXFxuXFx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIGVuZCovdmFyIGNoYXJhY3RlckRpZmYgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jaGFyYWN0ZXJEaWZmID0gbmV3IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZTJbJ2RlZmF1bHQnXSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLygpO1xcblxcdGZ1bmN0aW9uIGRpZmZDaGFycyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xcblxcdCAgcmV0dXJuIGNoYXJhY3RlckRpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDMgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcdGV4cG9ydHMud29yZERpZmYgPSB1bmRlZmluZWQ7XFxuXFx0ZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmV29yZHMgPSBkaWZmV29yZHM7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZldvcmRzV2l0aFNwYWNlID0gZGlmZldvcmRzV2l0aFNwYWNlO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi92YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19wYXJhbXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8gLy8gQmFzZWQgb24gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fc2NyaXB0X2luX1VuaWNvZGVcXG5cXHQvL1xcblxcdC8vIFJhbmdlcyBhbmQgZXhjZXB0aW9uczpcXG5cXHQvLyBMYXRpbi0xIFN1cHBsZW1lbnQsIDAwODDigJMwMEZGXFxuXFx0Ly8gIC0gVSswMEQ3ICDDlyBNdWx0aXBsaWNhdGlvbiBzaWduXFxuXFx0Ly8gIC0gVSswMEY3ICDDtyBEaXZpc2lvbiBzaWduXFxuXFx0Ly8gTGF0aW4gRXh0ZW5kZWQtQSwgMDEwMOKAkzAxN0ZcXG5cXHQvLyBMYXRpbiBFeHRlbmRlZC1CLCAwMTgw4oCTMDI0RlxcblxcdC8vIElQQSBFeHRlbnNpb25zLCAwMjUw4oCTMDJBRlxcblxcdC8vIFNwYWNpbmcgTW9kaWZpZXIgTGV0dGVycywgMDJCMOKAkzAyRkZcXG5cXHQvLyAgLSBVKzAyQzcgIMuHICYjNzExOyAgQ2Fyb25cXG5cXHQvLyAgLSBVKzAyRDggIMuYICYjNzI4OyAgQnJldmVcXG5cXHQvLyAgLSBVKzAyRDkgIMuZICYjNzI5OyAgRG90IEFib3ZlXFxuXFx0Ly8gIC0gVSswMkRBICDLmiAmIzczMDsgIFJpbmcgQWJvdmVcXG5cXHQvLyAgLSBVKzAyREIgIMubICYjNzMxOyAgT2dvbmVrXFxuXFx0Ly8gIC0gVSswMkRDICDLnCAmIzczMjsgIFNtYWxsIFRpbGRlXFxuXFx0Ly8gIC0gVSswMkREICDLnSAmIzczMzsgIERvdWJsZSBBY3V0ZSBBY2NlbnRcXG5cXHQvLyBMYXRpbiBFeHRlbmRlZCBBZGRpdGlvbmFsLCAxRTAw4oCTMUVGRlxcblxcdHZhciBleHRlbmRlZFdvcmRDaGFycyA9IC9eW0EtWmEtelxcXFx4QzAtXFxcXHUwMkM2XFxcXHUwMkM4LVxcXFx1MDJEN1xcXFx1MDJERS1cXFxcdTAyRkZcXFxcdTFFMDAtXFxcXHUxRUZGXSskLztcXG5cXG5cXHR2YXIgcmVXaGl0ZXNwYWNlID0gL1xcXFxTLztcXG5cXG5cXHR2YXIgd29yZERpZmYgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi93b3JkRGlmZiA9IG5ldyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UyWydkZWZhdWx0J10gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oKTtcXG5cXHR3b3JkRGlmZi5lcXVhbHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcXG5cXHQgIGlmICh0aGlzLm9wdGlvbnMuaWdub3JlQ2FzZSkge1xcblxcdCAgICBsZWZ0ID0gbGVmdC50b0xvd2VyQ2FzZSgpO1xcblxcdCAgICByaWdodCA9IHJpZ2h0LnRvTG93ZXJDYXNlKCk7XFxuXFx0ICB9XFxuXFx0ICByZXR1cm4gbGVmdCA9PT0gcmlnaHQgfHwgdGhpcy5vcHRpb25zLmlnbm9yZVdoaXRlc3BhY2UgJiYgIXJlV2hpdGVzcGFjZS50ZXN0KGxlZnQpICYmICFyZVdoaXRlc3BhY2UudGVzdChyaWdodCk7XFxuXFx0fTtcXG5cXHR3b3JkRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcblxcdCAgdmFyIHRva2VucyA9IHZhbHVlLnNwbGl0KC8oXFxcXHMrfFxcXFxiKS8pO1xcblxcblxcdCAgLy8gSm9pbiB0aGUgYm91bmRhcnkgc3BsaXRzIHRoYXQgd2UgZG8gbm90IGNvbnNpZGVyIHRvIGJlIGJvdW5kYXJpZXMuIFRoaXMgaXMgcHJpbWFyaWx5IHRoZSBleHRlbmRlZCBMYXRpbiBjaGFyYWN0ZXIgc2V0LlxcblxcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoIC0gMTsgaSsrKSB7XFxuXFx0ICAgIC8vIElmIHdlIGhhdmUgYW4gZW1wdHkgc3RyaW5nIGluIHRoZSBuZXh0IGZpZWxkIGFuZCB3ZSBoYXZlIG9ubHkgd29yZCBjaGFycyBiZWZvcmUgYW5kIGFmdGVyLCBtZXJnZVxcblxcdCAgICBpZiAoIXRva2Vuc1tpICsgMV0gJiYgdG9rZW5zW2kgKyAyXSAmJiBleHRlbmRlZFdvcmRDaGFycy50ZXN0KHRva2Vuc1tpXSkgJiYgZXh0ZW5kZWRXb3JkQ2hhcnMudGVzdCh0b2tlbnNbaSArIDJdKSkge1xcblxcdCAgICAgIHRva2Vuc1tpXSArPSB0b2tlbnNbaSArIDJdO1xcblxcdCAgICAgIHRva2Vucy5zcGxpY2UoaSArIDEsIDIpO1xcblxcdCAgICAgIGktLTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgcmV0dXJuIHRva2VucztcXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIGRpZmZXb3JkcyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xcblxcdCAgb3B0aW9ucyA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX3BhcmFtcy5nZW5lcmF0ZU9wdGlvbnMpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKG9wdGlvbnMsIHsgaWdub3JlV2hpdGVzcGFjZTogdHJ1ZSB9KTtcXG5cXHQgIHJldHVybiB3b3JkRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gZGlmZldvcmRzV2l0aFNwYWNlKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKSB7XFxuXFx0ICByZXR1cm4gd29yZERpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZ2VuZXJhdGVPcHRpb25zID0gZ2VuZXJhdGVPcHRpb25zO1xcblxcdGZ1bmN0aW9uIGdlbmVyYXRlT3B0aW9ucyhvcHRpb25zLCBkZWZhdWx0cykge1xcblxcdCAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XFxuXFx0ICAgIGRlZmF1bHRzLmNhbGxiYWNrID0gb3B0aW9ucztcXG5cXHQgIH0gZWxzZSBpZiAob3B0aW9ucykge1xcblxcdCAgICBmb3IgKHZhciBuYW1lIGluIG9wdGlvbnMpIHtcXG5cXHQgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xcblxcdCAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XFxuXFx0ICAgICAgICBkZWZhdWx0c1tuYW1lXSA9IG9wdGlvbnNbbmFtZV07XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0ICByZXR1cm4gZGVmYXVsdHM7XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDUgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcdGV4cG9ydHMubGluZURpZmYgPSB1bmRlZmluZWQ7XFxuXFx0ZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmTGluZXMgPSBkaWZmTGluZXM7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZlRyaW1tZWRMaW5lcyA9IGRpZmZUcmltbWVkTGluZXM7XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3ZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3BhcmFtcyA9IF9fd2VicGFja19yZXF1aXJlX18oNCkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3ZhciBsaW5lRGlmZiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2xpbmVEaWZmID0gbmV3IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZTJbJ2RlZmF1bHQnXSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLygpO1xcblxcdGxpbmVEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuXFx0ICB2YXIgcmV0TGluZXMgPSBbXSxcXG5cXHQgICAgICBsaW5lc0FuZE5ld2xpbmVzID0gdmFsdWUuc3BsaXQoLyhcXFxcbnxcXFxcclxcXFxuKS8pO1xcblxcblxcdCAgLy8gSWdub3JlIHRoZSBmaW5hbCBlbXB0eSB0b2tlbiB0aGF0IG9jY3VycyBpZiB0aGUgc3RyaW5nIGVuZHMgd2l0aCBhIG5ldyBsaW5lXFxuXFx0ICBpZiAoIWxpbmVzQW5kTmV3bGluZXNbbGluZXNBbmROZXdsaW5lcy5sZW5ndGggLSAxXSkge1xcblxcdCAgICBsaW5lc0FuZE5ld2xpbmVzLnBvcCgpO1xcblxcdCAgfVxcblxcblxcdCAgLy8gTWVyZ2UgdGhlIGNvbnRlbnQgYW5kIGxpbmUgc2VwYXJhdG9ycyBpbnRvIHNpbmdsZSB0b2tlbnNcXG5cXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXNBbmROZXdsaW5lcy5sZW5ndGg7IGkrKykge1xcblxcdCAgICB2YXIgbGluZSA9IGxpbmVzQW5kTmV3bGluZXNbaV07XFxuXFxuXFx0ICAgIGlmIChpICUgMiAmJiAhdGhpcy5vcHRpb25zLm5ld2xpbmVJc1Rva2VuKSB7XFxuXFx0ICAgICAgcmV0TGluZXNbcmV0TGluZXMubGVuZ3RoIC0gMV0gKz0gbGluZTtcXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZVdoaXRlc3BhY2UpIHtcXG5cXHQgICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgICAgcmV0TGluZXMucHVzaChsaW5lKTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgcmV0dXJuIHJldExpbmVzO1xcblxcdH07XFxuXFxuXFx0ZnVuY3Rpb24gZGlmZkxpbmVzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xcblxcdCAgcmV0dXJuIGxpbmVEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKTtcXG5cXHR9XFxuXFx0ZnVuY3Rpb24gZGlmZlRyaW1tZWRMaW5lcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcXG5cXHQgIHZhciBvcHRpb25zID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLygwLCBfcGFyYW1zLmdlbmVyYXRlT3B0aW9ucykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oY2FsbGJhY2ssIHsgaWdub3JlV2hpdGVzcGFjZTogdHJ1ZSB9KTtcXG5cXHQgIHJldHVybiBsaW5lRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcXG5cXHR9XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogNiAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0cy5zZW50ZW5jZURpZmYgPSB1bmRlZmluZWQ7XFxuXFx0ZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmU2VudGVuY2VzID0gZGlmZlNlbnRlbmNlcztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xcblxcblxcdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3ZhciBzZW50ZW5jZURpZmYgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9zZW50ZW5jZURpZmYgPSBuZXcgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlMlsnZGVmYXVsdCddIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCk7XFxuXFx0c2VudGVuY2VEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuXFx0ICByZXR1cm4gdmFsdWUuc3BsaXQoLyhcXFxcUy4rP1suIT9dKSg/PVxcXFxzK3wkKS8pO1xcblxcdH07XFxuXFxuXFx0ZnVuY3Rpb24gZGlmZlNlbnRlbmNlcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcXG5cXHQgIHJldHVybiBzZW50ZW5jZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spO1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiA3ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLmNzc0RpZmYgPSB1bmRlZmluZWQ7XFxuXFx0ZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmQ3NzID0gZGlmZkNzcztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xcblxcblxcdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3ZhciBjc3NEaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY3NzRGlmZiA9IG5ldyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UyWydkZWZhdWx0J10gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oKTtcXG5cXHRjc3NEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuXFx0ICByZXR1cm4gdmFsdWUuc3BsaXQoLyhbe306OyxdfFxcXFxzKykvKTtcXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIGRpZmZDc3Mob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XFxuXFx0ICByZXR1cm4gY3NzRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDggKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcdGV4cG9ydHMuanNvbkRpZmYgPSB1bmRlZmluZWQ7XFxuXFxuXFx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTtcXG5cXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZKc29uID0gZGlmZkpzb247XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY2Fub25pY2FsaXplID0gY2Fub25pY2FsaXplO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi92YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19saW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIGVuZCovdmFyIG9iamVjdFByb3RvdHlwZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcXG5cXG5cXHR2YXIganNvbkRpZmYgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9qc29uRGlmZiA9IG5ldyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UyWydkZWZhdWx0J10gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oKTtcXG5cXHQvLyBEaXNjcmltaW5hdGUgYmV0d2VlbiB0d28gbGluZXMgb2YgcHJldHR5LXByaW50ZWQsIHNlcmlhbGl6ZWQgSlNPTiB3aGVyZSBvbmUgb2YgdGhlbSBoYXMgYVxcblxcdC8vIGRhbmdsaW5nIGNvbW1hIGFuZCB0aGUgb3RoZXIgZG9lc24ndC4gVHVybnMgb3V0IGluY2x1ZGluZyB0aGUgZGFuZ2xpbmcgY29tbWEgeWllbGRzIHRoZSBuaWNlc3Qgb3V0cHV0OlxcblxcdGpzb25EaWZmLnVzZUxvbmdlc3RUb2tlbiA9IHRydWU7XFxuXFxuXFx0anNvbkRpZmYudG9rZW5pemUgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2xpbmUubGluZURpZmYgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8udG9rZW5pemU7XFxuXFx0anNvbkRpZmYuY2FzdElucHV0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuXFx0ICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9vcHRpb25zID0gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi90aGlzLm9wdGlvbnMsXFxuXFx0ICAgICAgdW5kZWZpbmVkUmVwbGFjZW1lbnQgPSBfb3B0aW9ucy51bmRlZmluZWRSZXBsYWNlbWVudCxcXG5cXHQgICAgICBfb3B0aW9ucyRzdHJpbmdpZnlSZXAgPSBfb3B0aW9ucy5zdHJpbmdpZnlSZXBsYWNlcixcXG5cXHQgICAgICBzdHJpbmdpZnlSZXBsYWNlciA9IF9vcHRpb25zJHN0cmluZ2lmeVJlcCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGssIHYpIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki97XFxuXFx0ICAgIHJldHVybiAoLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi90eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWRSZXBsYWNlbWVudCA6IHZcXG5cXHQgICAgKTtcXG5cXHQgIH0gOiBfb3B0aW9ucyRzdHJpbmdpZnlSZXA7XFxuXFxuXFxuXFx0ICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkoY2Fub25pY2FsaXplKHZhbHVlLCBudWxsLCBudWxsLCBzdHJpbmdpZnlSZXBsYWNlciksIHN0cmluZ2lmeVJlcGxhY2VyLCAnICAnKTtcXG5cXHR9O1xcblxcdGpzb25EaWZmLmVxdWFscyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xcblxcdCAgcmV0dXJuICgvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UyWydkZWZhdWx0J10gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8ucHJvdG90eXBlLmVxdWFscy5jYWxsKGpzb25EaWZmLCBsZWZ0LnJlcGxhY2UoLywoW1xcXFxyXFxcXG5dKS9nLCAnJDEnKSwgcmlnaHQucmVwbGFjZSgvLChbXFxcXHJcXFxcbl0pL2csICckMScpKVxcblxcdCAgKTtcXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIGRpZmZKc29uKG9sZE9iaiwgbmV3T2JqLCBvcHRpb25zKSB7XFxuXFx0ICByZXR1cm4ganNvbkRpZmYuZGlmZihvbGRPYmosIG5ld09iaiwgb3B0aW9ucyk7XFxuXFx0fVxcblxcblxcdC8vIFRoaXMgZnVuY3Rpb24gaGFuZGxlcyB0aGUgcHJlc2VuY2Ugb2YgY2lyY3VsYXIgcmVmZXJlbmNlcyBieSBiYWlsaW5nIG91dCB3aGVuIGVuY291bnRlcmluZyBhblxcblxcdC8vIG9iamVjdCB0aGF0IGlzIGFscmVhZHkgb24gdGhlIFxcXCJzdGFja1xcXCIgb2YgaXRlbXMgYmVpbmcgcHJvY2Vzc2VkLiBBY2NlcHRzIGFuIG9wdGlvbmFsIHJlcGxhY2VyXFxuXFx0ZnVuY3Rpb24gY2Fub25pY2FsaXplKG9iaiwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBrZXkpIHtcXG5cXHQgIHN0YWNrID0gc3RhY2sgfHwgW107XFxuXFx0ICByZXBsYWNlbWVudFN0YWNrID0gcmVwbGFjZW1lbnRTdGFjayB8fCBbXTtcXG5cXG5cXHQgIGlmIChyZXBsYWNlcikge1xcblxcdCAgICBvYmogPSByZXBsYWNlcihrZXksIG9iaik7XFxuXFx0ICB9XFxuXFxuXFx0ICB2YXIgaSA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92b2lkIDAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0ICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpICs9IDEpIHtcXG5cXHQgICAgaWYgKHN0YWNrW2ldID09PSBvYmopIHtcXG5cXHQgICAgICByZXR1cm4gcmVwbGFjZW1lbnRTdGFja1tpXTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgdmFyIGNhbm9uaWNhbGl6ZWRPYmogPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdm9pZCAwIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdCAgaWYgKCdbb2JqZWN0IEFycmF5XScgPT09IG9iamVjdFByb3RvdHlwZVRvU3RyaW5nLmNhbGwob2JqKSkge1xcblxcdCAgICBzdGFjay5wdXNoKG9iaik7XFxuXFx0ICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBuZXcgQXJyYXkob2JqLmxlbmd0aCk7XFxuXFx0ICAgIHJlcGxhY2VtZW50U3RhY2sucHVzaChjYW5vbmljYWxpemVkT2JqKTtcXG5cXHQgICAgZm9yIChpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkgKz0gMSkge1xcblxcdCAgICAgIGNhbm9uaWNhbGl6ZWRPYmpbaV0gPSBjYW5vbmljYWxpemUob2JqW2ldLCBzdGFjaywgcmVwbGFjZW1lbnRTdGFjaywgcmVwbGFjZXIsIGtleSk7XFxuXFx0ICAgIH1cXG5cXHQgICAgc3RhY2sucG9wKCk7XFxuXFx0ICAgIHJlcGxhY2VtZW50U3RhY2sucG9wKCk7XFxuXFx0ICAgIHJldHVybiBjYW5vbmljYWxpemVkT2JqO1xcblxcdCAgfVxcblxcblxcdCAgaWYgKG9iaiAmJiBvYmoudG9KU09OKSB7XFxuXFx0ICAgIG9iaiA9IG9iai50b0pTT04oKTtcXG5cXHQgIH1cXG5cXG5cXHQgIGlmICggLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyh0eXBlb2YgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9vYmogPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iaikpID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcXG5cXHQgICAgc3RhY2sucHVzaChvYmopO1xcblxcdCAgICBjYW5vbmljYWxpemVkT2JqID0ge307XFxuXFx0ICAgIHJlcGxhY2VtZW50U3RhY2sucHVzaChjYW5vbmljYWxpemVkT2JqKTtcXG5cXHQgICAgdmFyIHNvcnRlZEtleXMgPSBbXSxcXG5cXHQgICAgICAgIF9rZXkgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdm9pZCAwIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcdCAgICBmb3IgKF9rZXkgaW4gb2JqKSB7XFxuXFx0ICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cXG5cXHQgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KF9rZXkpKSB7XFxuXFx0ICAgICAgICBzb3J0ZWRLZXlzLnB1c2goX2tleSk7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICAgIHNvcnRlZEtleXMuc29ydCgpO1xcblxcdCAgICBmb3IgKGkgPSAwOyBpIDwgc29ydGVkS2V5cy5sZW5ndGg7IGkgKz0gMSkge1xcblxcdCAgICAgIF9rZXkgPSBzb3J0ZWRLZXlzW2ldO1xcblxcdCAgICAgIGNhbm9uaWNhbGl6ZWRPYmpbX2tleV0gPSBjYW5vbmljYWxpemUob2JqW19rZXldLCBzdGFjaywgcmVwbGFjZW1lbnRTdGFjaywgcmVwbGFjZXIsIF9rZXkpO1xcblxcdCAgICB9XFxuXFx0ICAgIHN0YWNrLnBvcCgpO1xcblxcdCAgICByZXBsYWNlbWVudFN0YWNrLnBvcCgpO1xcblxcdCAgfSBlbHNlIHtcXG5cXHQgICAgY2Fub25pY2FsaXplZE9iaiA9IG9iajtcXG5cXHQgIH1cXG5cXHQgIHJldHVybiBjYW5vbmljYWxpemVkT2JqO1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiA5ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLmFycmF5RGlmZiA9IHVuZGVmaW5lZDtcXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZBcnJheXMgPSBkaWZmQXJyYXlzO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XFxuXFxuXFx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIGVuZCovdmFyIGFycmF5RGlmZiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2FycmF5RGlmZiA9IG5ldyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UyWydkZWZhdWx0J10gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oKTtcXG5cXHRhcnJheURpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG5cXHQgIHJldHVybiB2YWx1ZS5zbGljZSgpO1xcblxcdH07XFxuXFx0YXJyYXlEaWZmLmpvaW4gPSBhcnJheURpZmYucmVtb3ZlRW1wdHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG5cXHQgIHJldHVybiB2YWx1ZTtcXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIGRpZmZBcnJheXMob2xkQXJyLCBuZXdBcnIsIGNhbGxiYWNrKSB7XFxuXFx0ICByZXR1cm4gYXJyYXlEaWZmLmRpZmYob2xkQXJyLCBuZXdBcnIsIGNhbGxiYWNrKTtcXG5cXHR9XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMTAgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovYXBwbHlQYXRjaCA9IGFwcGx5UGF0Y2g7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovYXBwbHlQYXRjaGVzID0gYXBwbHlQYXRjaGVzO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3BhcnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fZGlzdGFuY2VJdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2Rpc3RhbmNlSXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzdGFuY2VJdGVyYXRvcik7XFxuXFxuXFx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIGVuZCovZnVuY3Rpb24gYXBwbHlQYXRjaChzb3VyY2UsIHVuaURpZmYpIHtcXG5cXHQgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9vcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcXG5cXG5cXHQgIGlmICh0eXBlb2YgdW5pRGlmZiA9PT0gJ3N0cmluZycpIHtcXG5cXHQgICAgdW5pRGlmZiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX3BhcnNlLnBhcnNlUGF0Y2gpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKHVuaURpZmYpO1xcblxcdCAgfVxcblxcblxcdCAgaWYgKEFycmF5LmlzQXJyYXkodW5pRGlmZikpIHtcXG5cXHQgICAgaWYgKHVuaURpZmYubGVuZ3RoID4gMSkge1xcblxcdCAgICAgIHRocm93IG5ldyBFcnJvcignYXBwbHlQYXRjaCBvbmx5IHdvcmtzIHdpdGggYSBzaW5nbGUgaW5wdXQuJyk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgdW5pRGlmZiA9IHVuaURpZmZbMF07XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBBcHBseSB0aGUgZGlmZiB0byB0aGUgaW5wdXRcXG5cXHQgIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxcXHJcXFxcbnxbXFxcXG5cXFxcdlxcXFxmXFxcXHJcXFxceDg1XS8pLFxcblxcdCAgICAgIGRlbGltaXRlcnMgPSBzb3VyY2UubWF0Y2goL1xcXFxyXFxcXG58W1xcXFxuXFxcXHZcXFxcZlxcXFxyXFxcXHg4NV0vZykgfHwgW10sXFxuXFx0ICAgICAgaHVua3MgPSB1bmlEaWZmLmh1bmtzLFxcblxcdCAgICAgIGNvbXBhcmVMaW5lID0gb3B0aW9ucy5jb21wYXJlTGluZSB8fCBmdW5jdGlvbiAobGluZU51bWJlciwgbGluZSwgb3BlcmF0aW9uLCBwYXRjaENvbnRlbnQpIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki97XFxuXFx0ICAgIHJldHVybiAoLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9saW5lID09PSBwYXRjaENvbnRlbnRcXG5cXHQgICAgKTtcXG5cXHQgIH0sXFxuXFx0ICAgICAgZXJyb3JDb3VudCA9IDAsXFxuXFx0ICAgICAgZnV6ekZhY3RvciA9IG9wdGlvbnMuZnV6ekZhY3RvciB8fCAwLFxcblxcdCAgICAgIG1pbkxpbmUgPSAwLFxcblxcdCAgICAgIG9mZnNldCA9IDAsXFxuXFx0ICAgICAgcmVtb3ZlRU9GTkwgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdm9pZCAwIC8qaXN0YW5idWwgaWdub3JlIGVuZCovLFxcblxcdCAgICAgIGFkZEVPRk5MID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZvaWQgMCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQgIC8qKlxcblxcdCAgICogQ2hlY2tzIGlmIHRoZSBodW5rIGV4YWN0bHkgZml0cyBvbiB0aGUgcHJvdmlkZWQgbG9jYXRpb25cXG5cXHQgICAqL1xcblxcdCAgZnVuY3Rpb24gaHVua0ZpdHMoaHVuaywgdG9Qb3MpIHtcXG5cXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCBodW5rLmxpbmVzLmxlbmd0aDsgaisrKSB7XFxuXFx0ICAgICAgdmFyIGxpbmUgPSBodW5rLmxpbmVzW2pdLFxcblxcdCAgICAgICAgICBvcGVyYXRpb24gPSBsaW5lLmxlbmd0aCA+IDAgPyBsaW5lWzBdIDogJyAnLFxcblxcdCAgICAgICAgICBjb250ZW50ID0gbGluZS5sZW5ndGggPiAwID8gbGluZS5zdWJzdHIoMSkgOiBsaW5lO1xcblxcblxcdCAgICAgIGlmIChvcGVyYXRpb24gPT09ICcgJyB8fCBvcGVyYXRpb24gPT09ICctJykge1xcblxcdCAgICAgICAgLy8gQ29udGV4dCBzYW5pdHkgY2hlY2tcXG5cXHQgICAgICAgIGlmICghY29tcGFyZUxpbmUodG9Qb3MgKyAxLCBsaW5lc1t0b1Bvc10sIG9wZXJhdGlvbiwgY29udGVudCkpIHtcXG5cXHQgICAgICAgICAgZXJyb3JDb3VudCsrO1xcblxcblxcdCAgICAgICAgICBpZiAoZXJyb3JDb3VudCA+IGZ1enpGYWN0b3IpIHtcXG5cXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuXFx0ICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHRvUG9zKys7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFxuXFx0ICAgIHJldHVybiB0cnVlO1xcblxcdCAgfVxcblxcblxcdCAgLy8gU2VhcmNoIGJlc3QgZml0IG9mZnNldHMgZm9yIGVhY2ggaHVuayBiYXNlZCBvbiB0aGUgcHJldmlvdXMgb25lc1xcblxcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBodW5rcy5sZW5ndGg7IGkrKykge1xcblxcdCAgICB2YXIgaHVuayA9IGh1bmtzW2ldLFxcblxcdCAgICAgICAgbWF4TGluZSA9IGxpbmVzLmxlbmd0aCAtIGh1bmsub2xkTGluZXMsXFxuXFx0ICAgICAgICBsb2NhbE9mZnNldCA9IDAsXFxuXFx0ICAgICAgICB0b1BvcyA9IG9mZnNldCArIGh1bmsub2xkU3RhcnQgLSAxO1xcblxcblxcdCAgICB2YXIgaXRlcmF0b3IgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKDAsIF9kaXN0YW5jZUl0ZXJhdG9yMlsnZGVmYXVsdCddKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyh0b1BvcywgbWluTGluZSwgbWF4TGluZSk7XFxuXFxuXFx0ICAgIGZvciAoOyBsb2NhbE9mZnNldCAhPT0gdW5kZWZpbmVkOyBsb2NhbE9mZnNldCA9IGl0ZXJhdG9yKCkpIHtcXG5cXHQgICAgICBpZiAoaHVua0ZpdHMoaHVuaywgdG9Qb3MgKyBsb2NhbE9mZnNldCkpIHtcXG5cXHQgICAgICAgIGh1bmsub2Zmc2V0ID0gb2Zmc2V0ICs9IGxvY2FsT2Zmc2V0O1xcblxcdCAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFxuXFx0ICAgIGlmIChsb2NhbE9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0ICAgICAgcmV0dXJuIGZhbHNlO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIFNldCBsb3dlciB0ZXh0IGxpbWl0IHRvIGVuZCBvZiB0aGUgY3VycmVudCBodW5rLCBzbyBuZXh0IG9uZXMgZG9uJ3QgdHJ5XFxuXFx0ICAgIC8vIHRvIGZpdCBvdmVyIGFscmVhZHkgcGF0Y2hlZCB0ZXh0XFxuXFx0ICAgIG1pbkxpbmUgPSBodW5rLm9mZnNldCArIGh1bmsub2xkU3RhcnQgKyBodW5rLm9sZExpbmVzO1xcblxcdCAgfVxcblxcblxcdCAgLy8gQXBwbHkgcGF0Y2ggaHVua3NcXG5cXHQgIHZhciBkaWZmT2Zmc2V0ID0gMDtcXG5cXHQgIGZvciAodmFyIF9pID0gMDsgX2kgPCBodW5rcy5sZW5ndGg7IF9pKyspIHtcXG5cXHQgICAgdmFyIF9odW5rID0gaHVua3NbX2ldLFxcblxcdCAgICAgICAgX3RvUG9zID0gX2h1bmsub2xkU3RhcnQgKyBfaHVuay5vZmZzZXQgKyBkaWZmT2Zmc2V0IC0gMTtcXG5cXHQgICAgZGlmZk9mZnNldCArPSBfaHVuay5uZXdMaW5lcyAtIF9odW5rLm9sZExpbmVzO1xcblxcblxcdCAgICBpZiAoX3RvUG9zIDwgMCkge1xcblxcdCAgICAgIC8vIENyZWF0aW5nIGEgbmV3IGZpbGVcXG5cXHQgICAgICBfdG9Qb3MgPSAwO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgX2h1bmsubGluZXMubGVuZ3RoOyBqKyspIHtcXG5cXHQgICAgICB2YXIgbGluZSA9IF9odW5rLmxpbmVzW2pdLFxcblxcdCAgICAgICAgICBvcGVyYXRpb24gPSBsaW5lLmxlbmd0aCA+IDAgPyBsaW5lWzBdIDogJyAnLFxcblxcdCAgICAgICAgICBjb250ZW50ID0gbGluZS5sZW5ndGggPiAwID8gbGluZS5zdWJzdHIoMSkgOiBsaW5lLFxcblxcdCAgICAgICAgICBkZWxpbWl0ZXIgPSBfaHVuay5saW5lZGVsaW1pdGVyc1tqXTtcXG5cXG5cXHQgICAgICBpZiAob3BlcmF0aW9uID09PSAnICcpIHtcXG5cXHQgICAgICAgIF90b1BvcysrO1xcblxcdCAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnLScpIHtcXG5cXHQgICAgICAgIGxpbmVzLnNwbGljZShfdG9Qb3MsIDEpO1xcblxcdCAgICAgICAgZGVsaW1pdGVycy5zcGxpY2UoX3RvUG9zLCAxKTtcXG5cXHQgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXFxuXFx0ICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICcrJykge1xcblxcdCAgICAgICAgbGluZXMuc3BsaWNlKF90b1BvcywgMCwgY29udGVudCk7XFxuXFx0ICAgICAgICBkZWxpbWl0ZXJzLnNwbGljZShfdG9Qb3MsIDAsIGRlbGltaXRlcik7XFxuXFx0ICAgICAgICBfdG9Qb3MrKztcXG5cXHQgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJ1xcXFxcXFxcJykge1xcblxcdCAgICAgICAgdmFyIHByZXZpb3VzT3BlcmF0aW9uID0gX2h1bmsubGluZXNbaiAtIDFdID8gX2h1bmsubGluZXNbaiAtIDFdWzBdIDogbnVsbDtcXG5cXHQgICAgICAgIGlmIChwcmV2aW91c09wZXJhdGlvbiA9PT0gJysnKSB7XFxuXFx0ICAgICAgICAgIHJlbW92ZUVPRk5MID0gdHJ1ZTtcXG5cXHQgICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNPcGVyYXRpb24gPT09ICctJykge1xcblxcdCAgICAgICAgICBhZGRFT0ZOTCA9IHRydWU7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBIYW5kbGUgRU9GTkwgaW5zZXJ0aW9uL3JlbW92YWxcXG5cXHQgIGlmIChyZW1vdmVFT0ZOTCkge1xcblxcdCAgICB3aGlsZSAoIWxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdKSB7XFxuXFx0ICAgICAgbGluZXMucG9wKCk7XFxuXFx0ICAgICAgZGVsaW1pdGVycy5wb3AoKTtcXG5cXHQgICAgfVxcblxcdCAgfSBlbHNlIGlmIChhZGRFT0ZOTCkge1xcblxcdCAgICBsaW5lcy5wdXNoKCcnKTtcXG5cXHQgICAgZGVsaW1pdGVycy5wdXNoKCdcXFxcbicpO1xcblxcdCAgfVxcblxcdCAgZm9yICh2YXIgX2sgPSAwOyBfayA8IGxpbmVzLmxlbmd0aCAtIDE7IF9rKyspIHtcXG5cXHQgICAgbGluZXNbX2tdID0gbGluZXNbX2tdICsgZGVsaW1pdGVyc1tfa107XFxuXFx0ICB9XFxuXFx0ICByZXR1cm4gbGluZXMuam9pbignJyk7XFxuXFx0fVxcblxcblxcdC8vIFdyYXBwZXIgdGhhdCBzdXBwb3J0cyBtdWx0aXBsZSBmaWxlIHBhdGNoZXMgdmlhIGNhbGxiYWNrcy5cXG5cXHRmdW5jdGlvbiBhcHBseVBhdGNoZXModW5pRGlmZiwgb3B0aW9ucykge1xcblxcdCAgaWYgKHR5cGVvZiB1bmlEaWZmID09PSAnc3RyaW5nJykge1xcblxcdCAgICB1bmlEaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLygwLCBfcGFyc2UucGFyc2VQYXRjaCkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8odW5pRGlmZik7XFxuXFx0ICB9XFxuXFxuXFx0ICB2YXIgY3VycmVudEluZGV4ID0gMDtcXG5cXHQgIGZ1bmN0aW9uIHByb2Nlc3NJbmRleCgpIHtcXG5cXHQgICAgdmFyIGluZGV4ID0gdW5pRGlmZltjdXJyZW50SW5kZXgrK107XFxuXFx0ICAgIGlmICghaW5kZXgpIHtcXG5cXHQgICAgICByZXR1cm4gb3B0aW9ucy5jb21wbGV0ZSgpO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIG9wdGlvbnMubG9hZEZpbGUoaW5kZXgsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcXG5cXHQgICAgICBpZiAoZXJyKSB7XFxuXFx0ICAgICAgICByZXR1cm4gb3B0aW9ucy5jb21wbGV0ZShlcnIpO1xcblxcdCAgICAgIH1cXG5cXG5cXHQgICAgICB2YXIgdXBkYXRlZENvbnRlbnQgPSBhcHBseVBhdGNoKGRhdGEsIGluZGV4LCBvcHRpb25zKTtcXG5cXHQgICAgICBvcHRpb25zLnBhdGNoZWQoaW5kZXgsIHVwZGF0ZWRDb250ZW50LCBmdW5jdGlvbiAoZXJyKSB7XFxuXFx0ICAgICAgICBpZiAoZXJyKSB7XFxuXFx0ICAgICAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKGVycik7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBwcm9jZXNzSW5kZXgoKTtcXG5cXHQgICAgICB9KTtcXG5cXHQgICAgfSk7XFxuXFx0ICB9XFxuXFx0ICBwcm9jZXNzSW5kZXgoKTtcXG5cXHR9XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMTEgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovcGFyc2VQYXRjaCA9IHBhcnNlUGF0Y2g7XFxuXFx0ZnVuY3Rpb24gcGFyc2VQYXRjaCh1bmlEaWZmKSB7XFxuXFx0ICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIC8qaXN0YW5idWwgaWdub3JlIGVuZCovb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XFxuXFxuXFx0ICB2YXIgZGlmZnN0ciA9IHVuaURpZmYuc3BsaXQoL1xcXFxyXFxcXG58W1xcXFxuXFxcXHZcXFxcZlxcXFxyXFxcXHg4NV0vKSxcXG5cXHQgICAgICBkZWxpbWl0ZXJzID0gdW5pRGlmZi5tYXRjaCgvXFxcXHJcXFxcbnxbXFxcXG5cXFxcdlxcXFxmXFxcXHJcXFxceDg1XS9nKSB8fCBbXSxcXG5cXHQgICAgICBsaXN0ID0gW10sXFxuXFx0ICAgICAgaSA9IDA7XFxuXFxuXFx0ICBmdW5jdGlvbiBwYXJzZUluZGV4KCkge1xcblxcdCAgICB2YXIgaW5kZXggPSB7fTtcXG5cXHQgICAgbGlzdC5wdXNoKGluZGV4KTtcXG5cXG5cXHQgICAgLy8gUGFyc2UgZGlmZiBtZXRhZGF0YVxcblxcdCAgICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XFxuXFx0ICAgICAgdmFyIGxpbmUgPSBkaWZmc3RyW2ldO1xcblxcblxcdCAgICAgIC8vIEZpbGUgaGVhZGVyIGZvdW5kLCBlbmQgcGFyc2luZyBkaWZmIG1ldGFkYXRhXFxuXFx0ICAgICAgaWYgKC9eKFxcXFwtXFxcXC1cXFxcLXxcXFxcK1xcXFwrXFxcXCt8QEApXFxcXHMvLnRlc3QobGluZSkpIHtcXG5cXHQgICAgICAgIGJyZWFrO1xcblxcdCAgICAgIH1cXG5cXG5cXHQgICAgICAvLyBEaWZmIGluZGV4XFxuXFx0ICAgICAgdmFyIGhlYWRlciA9IC9eKD86SW5kZXg6fGRpZmYoPzogLXIgXFxcXHcrKSspXFxcXHMrKC4rPylcXFxccyokLy5leGVjKGxpbmUpO1xcblxcdCAgICAgIGlmIChoZWFkZXIpIHtcXG5cXHQgICAgICAgIGluZGV4LmluZGV4ID0gaGVhZGVyWzFdO1xcblxcdCAgICAgIH1cXG5cXG5cXHQgICAgICBpKys7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgLy8gUGFyc2UgZmlsZSBoZWFkZXJzIGlmIHRoZXkgYXJlIGRlZmluZWQuIFVuaWZpZWQgZGlmZiByZXF1aXJlcyB0aGVtLCBidXRcXG5cXHQgICAgLy8gdGhlcmUncyBubyB0ZWNobmljYWwgaXNzdWVzIHRvIGhhdmUgYW4gaXNvbGF0ZWQgaHVuayB3aXRob3V0IGZpbGUgaGVhZGVyXFxuXFx0ICAgIHBhcnNlRmlsZUhlYWRlcihpbmRleCk7XFxuXFx0ICAgIHBhcnNlRmlsZUhlYWRlcihpbmRleCk7XFxuXFxuXFx0ICAgIC8vIFBhcnNlIGh1bmtzXFxuXFx0ICAgIGluZGV4Lmh1bmtzID0gW107XFxuXFxuXFx0ICAgIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcXG5cXHQgICAgICB2YXIgX2xpbmUgPSBkaWZmc3RyW2ldO1xcblxcblxcdCAgICAgIGlmICgvXihJbmRleDp8ZGlmZnxcXFxcLVxcXFwtXFxcXC18XFxcXCtcXFxcK1xcXFwrKVxcXFxzLy50ZXN0KF9saW5lKSkge1xcblxcdCAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgfSBlbHNlIGlmICgvXkBALy50ZXN0KF9saW5lKSkge1xcblxcdCAgICAgICAgaW5kZXguaHVua3MucHVzaChwYXJzZUh1bmsoKSk7XFxuXFx0ICAgICAgfSBlbHNlIGlmIChfbGluZSAmJiBvcHRpb25zLnN0cmljdCkge1xcblxcdCAgICAgICAgLy8gSWdub3JlIHVuZXhwZWN0ZWQgY29udGVudCB1bmxlc3MgaW4gc3RyaWN0IG1vZGVcXG5cXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsaW5lICcgKyAoaSArIDEpICsgJyAnICsgSlNPTi5zdHJpbmdpZnkoX2xpbmUpKTtcXG5cXHQgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgaSsrO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgLy8gUGFyc2VzIHRoZSAtLS0gYW5kICsrKyBoZWFkZXJzLCBpZiBub25lIGFyZSBmb3VuZCwgbm8gbGluZXNcXG5cXHQgIC8vIGFyZSBjb25zdW1lZC5cXG5cXHQgIGZ1bmN0aW9uIHBhcnNlRmlsZUhlYWRlcihpbmRleCkge1xcblxcdCAgICB2YXIgZmlsZUhlYWRlciA9IC9eKC0tLXxcXFxcK1xcXFwrXFxcXCspXFxcXHMrKC4qKSQvLmV4ZWMoZGlmZnN0cltpXSk7XFxuXFx0ICAgIGlmIChmaWxlSGVhZGVyKSB7XFxuXFx0ICAgICAgdmFyIGtleVByZWZpeCA9IGZpbGVIZWFkZXJbMV0gPT09ICctLS0nID8gJ29sZCcgOiAnbmV3JztcXG5cXHQgICAgICB2YXIgZGF0YSA9IGZpbGVIZWFkZXJbMl0uc3BsaXQoJ1xcXFx0JywgMik7XFxuXFx0ICAgICAgdmFyIGZpbGVOYW1lID0gZGF0YVswXS5yZXBsYWNlKC9cXFxcXFxcXFxcXFxcXFxcL2csICdcXFxcXFxcXCcpO1xcblxcdCAgICAgIGlmICgvXlxcXCIuKlxcXCIkLy50ZXN0KGZpbGVOYW1lKSkge1xcblxcdCAgICAgICAgZmlsZU5hbWUgPSBmaWxlTmFtZS5zdWJzdHIoMSwgZmlsZU5hbWUubGVuZ3RoIC0gMik7XFxuXFx0ICAgICAgfVxcblxcdCAgICAgIGluZGV4W2tleVByZWZpeCArICdGaWxlTmFtZSddID0gZmlsZU5hbWU7XFxuXFx0ICAgICAgaW5kZXhba2V5UHJlZml4ICsgJ0hlYWRlciddID0gKGRhdGFbMV0gfHwgJycpLnRyaW0oKTtcXG5cXG5cXHQgICAgICBpKys7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIC8vIFBhcnNlcyBhIGh1bmtcXG5cXHQgIC8vIFRoaXMgYXNzdW1lcyB0aGF0IHdlIGFyZSBhdCB0aGUgc3RhcnQgb2YgYSBodW5rLlxcblxcdCAgZnVuY3Rpb24gcGFyc2VIdW5rKCkge1xcblxcdCAgICB2YXIgY2h1bmtIZWFkZXJJbmRleCA9IGksXFxuXFx0ICAgICAgICBjaHVua0hlYWRlckxpbmUgPSBkaWZmc3RyW2krK10sXFxuXFx0ICAgICAgICBjaHVua0hlYWRlciA9IGNodW5rSGVhZGVyTGluZS5zcGxpdCgvQEAgLShcXFxcZCspKD86LChcXFxcZCspKT8gXFxcXCsoXFxcXGQrKSg/OiwoXFxcXGQrKSk/IEBALyk7XFxuXFxuXFx0ICAgIHZhciBodW5rID0ge1xcblxcdCAgICAgIG9sZFN0YXJ0OiArY2h1bmtIZWFkZXJbMV0sXFxuXFx0ICAgICAgb2xkTGluZXM6ICtjaHVua0hlYWRlclsyXSB8fCAxLFxcblxcdCAgICAgIG5ld1N0YXJ0OiArY2h1bmtIZWFkZXJbM10sXFxuXFx0ICAgICAgbmV3TGluZXM6ICtjaHVua0hlYWRlcls0XSB8fCAxLFxcblxcdCAgICAgIGxpbmVzOiBbXSxcXG5cXHQgICAgICBsaW5lZGVsaW1pdGVyczogW11cXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdmFyIGFkZENvdW50ID0gMCxcXG5cXHQgICAgICAgIHJlbW92ZUNvdW50ID0gMDtcXG5cXHQgICAgZm9yICg7IGkgPCBkaWZmc3RyLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgICAgLy8gTGluZXMgc3RhcnRpbmcgd2l0aCAnLS0tJyBjb3VsZCBiZSBtaXN0YWtlbiBmb3IgdGhlIFxcXCJyZW1vdmUgbGluZVxcXCIgb3BlcmF0aW9uXFxuXFx0ICAgICAgLy8gQnV0IHRoZXkgY291bGQgYmUgdGhlIGhlYWRlciBmb3IgdGhlIG5leHQgZmlsZS4gVGhlcmVmb3JlIHBydW5lIHN1Y2ggY2FzZXMgb3V0LlxcblxcdCAgICAgIGlmIChkaWZmc3RyW2ldLmluZGV4T2YoJy0tLSAnKSA9PT0gMCAmJiBpICsgMiA8IGRpZmZzdHIubGVuZ3RoICYmIGRpZmZzdHJbaSArIDFdLmluZGV4T2YoJysrKyAnKSA9PT0gMCAmJiBkaWZmc3RyW2kgKyAyXS5pbmRleE9mKCdAQCcpID09PSAwKSB7XFxuXFx0ICAgICAgICBicmVhaztcXG5cXHQgICAgICB9XFxuXFx0ICAgICAgdmFyIG9wZXJhdGlvbiA9IGRpZmZzdHJbaV0ubGVuZ3RoID09IDAgJiYgaSAhPSBkaWZmc3RyLmxlbmd0aCAtIDEgPyAnICcgOiBkaWZmc3RyW2ldWzBdO1xcblxcblxcdCAgICAgIGlmIChvcGVyYXRpb24gPT09ICcrJyB8fCBvcGVyYXRpb24gPT09ICctJyB8fCBvcGVyYXRpb24gPT09ICcgJyB8fCBvcGVyYXRpb24gPT09ICdcXFxcXFxcXCcpIHtcXG5cXHQgICAgICAgIGh1bmsubGluZXMucHVzaChkaWZmc3RyW2ldKTtcXG5cXHQgICAgICAgIGh1bmsubGluZWRlbGltaXRlcnMucHVzaChkZWxpbWl0ZXJzW2ldIHx8ICdcXFxcbicpO1xcblxcblxcdCAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJysnKSB7XFxuXFx0ICAgICAgICAgIGFkZENvdW50Kys7XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJy0nKSB7XFxuXFx0ICAgICAgICAgIHJlbW92ZUNvdW50Kys7XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJyAnKSB7XFxuXFx0ICAgICAgICAgIGFkZENvdW50Kys7XFxuXFx0ICAgICAgICAgIHJlbW92ZUNvdW50Kys7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgIGJyZWFrO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcblxcdCAgICAvLyBIYW5kbGUgdGhlIGVtcHR5IGJsb2NrIGNvdW50IGNhc2VcXG5cXHQgICAgaWYgKCFhZGRDb3VudCAmJiBodW5rLm5ld0xpbmVzID09PSAxKSB7XFxuXFx0ICAgICAgaHVuay5uZXdMaW5lcyA9IDA7XFxuXFx0ICAgIH1cXG5cXHQgICAgaWYgKCFyZW1vdmVDb3VudCAmJiBodW5rLm9sZExpbmVzID09PSAxKSB7XFxuXFx0ICAgICAgaHVuay5vbGRMaW5lcyA9IDA7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgLy8gUGVyZm9ybSBvcHRpb25hbCBzYW5pdHkgY2hlY2tpbmdcXG5cXHQgICAgaWYgKG9wdGlvbnMuc3RyaWN0KSB7XFxuXFx0ICAgICAgaWYgKGFkZENvdW50ICE9PSBodW5rLm5ld0xpbmVzKSB7XFxuXFx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkZGVkIGxpbmUgY291bnQgZGlkIG5vdCBtYXRjaCBmb3IgaHVuayBhdCBsaW5lICcgKyAoY2h1bmtIZWFkZXJJbmRleCArIDEpKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgICAgaWYgKHJlbW92ZUNvdW50ICE9PSBodW5rLm9sZExpbmVzKSB7XFxuXFx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbW92ZWQgbGluZSBjb3VudCBkaWQgbm90IG1hdGNoIGZvciBodW5rIGF0IGxpbmUgJyArIChjaHVua0hlYWRlckluZGV4ICsgMSkpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcblxcdCAgICByZXR1cm4gaHVuaztcXG5cXHQgIH1cXG5cXG5cXHQgIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcXG5cXHQgICAgcGFyc2VJbmRleCgpO1xcblxcdCAgfVxcblxcblxcdCAgcmV0dXJuIGxpc3Q7XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDEyICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXG5cXHRleHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2Z1bmN0aW9uIChzdGFydCwgbWluTGluZSwgbWF4TGluZSkge1xcblxcdCAgdmFyIHdhbnRGb3J3YXJkID0gdHJ1ZSxcXG5cXHQgICAgICBiYWNrd2FyZEV4aGF1c3RlZCA9IGZhbHNlLFxcblxcdCAgICAgIGZvcndhcmRFeGhhdXN0ZWQgPSBmYWxzZSxcXG5cXHQgICAgICBsb2NhbE9mZnNldCA9IDE7XFxuXFxuXFx0ICByZXR1cm4gZnVuY3Rpb24gaXRlcmF0b3IoKSB7XFxuXFx0ICAgIGlmICh3YW50Rm9yd2FyZCAmJiAhZm9yd2FyZEV4aGF1c3RlZCkge1xcblxcdCAgICAgIGlmIChiYWNrd2FyZEV4aGF1c3RlZCkge1xcblxcdCAgICAgICAgbG9jYWxPZmZzZXQrKztcXG5cXHQgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgd2FudEZvcndhcmQgPSBmYWxzZTtcXG5cXHQgICAgICB9XFxuXFxuXFx0ICAgICAgLy8gQ2hlY2sgaWYgdHJ5aW5nIHRvIGZpdCBiZXlvbmQgdGV4dCBsZW5ndGgsIGFuZCBpZiBub3QsIGNoZWNrIGl0IGZpdHNcXG5cXHQgICAgICAvLyBhZnRlciBvZmZzZXQgbG9jYXRpb24gKG9yIGRlc2lyZWQgbG9jYXRpb24gb24gZmlyc3QgaXRlcmF0aW9uKVxcblxcdCAgICAgIGlmIChzdGFydCArIGxvY2FsT2Zmc2V0IDw9IG1heExpbmUpIHtcXG5cXHQgICAgICAgIHJldHVybiBsb2NhbE9mZnNldDtcXG5cXHQgICAgICB9XFxuXFxuXFx0ICAgICAgZm9yd2FyZEV4aGF1c3RlZCA9IHRydWU7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgaWYgKCFiYWNrd2FyZEV4aGF1c3RlZCkge1xcblxcdCAgICAgIGlmICghZm9yd2FyZEV4aGF1c3RlZCkge1xcblxcdCAgICAgICAgd2FudEZvcndhcmQgPSB0cnVlO1xcblxcdCAgICAgIH1cXG5cXG5cXHQgICAgICAvLyBDaGVjayBpZiB0cnlpbmcgdG8gZml0IGJlZm9yZSB0ZXh0IGJlZ2lubmluZywgYW5kIGlmIG5vdCwgY2hlY2sgaXQgZml0c1xcblxcdCAgICAgIC8vIGJlZm9yZSBvZmZzZXQgbG9jYXRpb25cXG5cXHQgICAgICBpZiAobWluTGluZSA8PSBzdGFydCAtIGxvY2FsT2Zmc2V0KSB7XFxuXFx0ICAgICAgICByZXR1cm4gLWxvY2FsT2Zmc2V0Kys7XFxuXFx0ICAgICAgfVxcblxcblxcdCAgICAgIGJhY2t3YXJkRXhoYXVzdGVkID0gdHJ1ZTtcXG5cXHQgICAgICByZXR1cm4gaXRlcmF0b3IoKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICAvLyBXZSB0cmllZCB0byBmaXQgaHVuayBiZWZvcmUgdGV4dCBiZWdpbm5pbmcgYW5kIGJleW9uZCB0ZXh0IGxlbmd0aCwgdGhlblxcblxcdCAgICAvLyBodW5rIGNhbid0IGZpdCBvbiB0aGUgdGV4dC4gUmV0dXJuIHVuZGVmaW5lZFxcblxcdCAgfTtcXG5cXHR9O1xcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDEzICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NhbGNMaW5lQ291bnQgPSBjYWxjTGluZUNvdW50O1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL21lcmdlID0gbWVyZ2U7XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fcGFyc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19hcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2Z1bmN0aW9uIGNhbGNMaW5lQ291bnQoaHVuaykge1xcblxcdCAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfY2FsY09sZE5ld0xpbmVDb3VudCA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovY2FsY09sZE5ld0xpbmVDb3VudChodW5rLmxpbmVzKSxcXG5cXHQgICAgICBvbGRMaW5lcyA9IF9jYWxjT2xkTmV3TGluZUNvdW50Lm9sZExpbmVzLFxcblxcdCAgICAgIG5ld0xpbmVzID0gX2NhbGNPbGROZXdMaW5lQ291bnQubmV3TGluZXM7XFxuXFxuXFx0ICBpZiAob2xkTGluZXMgIT09IHVuZGVmaW5lZCkge1xcblxcdCAgICBodW5rLm9sZExpbmVzID0gb2xkTGluZXM7XFxuXFx0ICB9IGVsc2Uge1xcblxcdCAgICBkZWxldGUgaHVuay5vbGRMaW5lcztcXG5cXHQgIH1cXG5cXG5cXHQgIGlmIChuZXdMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0ICAgIGh1bmsubmV3TGluZXMgPSBuZXdMaW5lcztcXG5cXHQgIH0gZWxzZSB7XFxuXFx0ICAgIGRlbGV0ZSBodW5rLm5ld0xpbmVzO1xcblxcdCAgfVxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBtZXJnZShtaW5lLCB0aGVpcnMsIGJhc2UpIHtcXG5cXHQgIG1pbmUgPSBsb2FkUGF0Y2gobWluZSwgYmFzZSk7XFxuXFx0ICB0aGVpcnMgPSBsb2FkUGF0Y2godGhlaXJzLCBiYXNlKTtcXG5cXG5cXHQgIHZhciByZXQgPSB7fTtcXG5cXG5cXHQgIC8vIEZvciBpbmRleCB3ZSBqdXN0IGxldCBpdCBwYXNzIHRocm91Z2ggYXMgaXQgZG9lc24ndCBoYXZlIGFueSBuZWNlc3NhcnkgbWVhbmluZy5cXG5cXHQgIC8vIExlYXZpbmcgc2FuaXR5IGNoZWNrcyBvbiB0aGlzIHRvIHRoZSBBUEkgY29uc3VtZXIgdGhhdCBtYXkga25vdyBtb3JlIGFib3V0IHRoZVxcblxcdCAgLy8gbWVhbmluZyBpbiB0aGVpciBvd24gY29udGV4dC5cXG5cXHQgIGlmIChtaW5lLmluZGV4IHx8IHRoZWlycy5pbmRleCkge1xcblxcdCAgICByZXQuaW5kZXggPSBtaW5lLmluZGV4IHx8IHRoZWlycy5pbmRleDtcXG5cXHQgIH1cXG5cXG5cXHQgIGlmIChtaW5lLm5ld0ZpbGVOYW1lIHx8IHRoZWlycy5uZXdGaWxlTmFtZSkge1xcblxcdCAgICBpZiAoIWZpbGVOYW1lQ2hhbmdlZChtaW5lKSkge1xcblxcdCAgICAgIC8vIE5vIGhlYWRlciBvciBubyBjaGFuZ2UgaW4gb3VycywgdXNlIHRoZWlycyAoYW5kIG91cnMgaWYgdGhlaXJzIGRvZXMgbm90IGV4aXN0KVxcblxcdCAgICAgIHJldC5vbGRGaWxlTmFtZSA9IHRoZWlycy5vbGRGaWxlTmFtZSB8fCBtaW5lLm9sZEZpbGVOYW1lO1xcblxcdCAgICAgIHJldC5uZXdGaWxlTmFtZSA9IHRoZWlycy5uZXdGaWxlTmFtZSB8fCBtaW5lLm5ld0ZpbGVOYW1lO1xcblxcdCAgICAgIHJldC5vbGRIZWFkZXIgPSB0aGVpcnMub2xkSGVhZGVyIHx8IG1pbmUub2xkSGVhZGVyO1xcblxcdCAgICAgIHJldC5uZXdIZWFkZXIgPSB0aGVpcnMubmV3SGVhZGVyIHx8IG1pbmUubmV3SGVhZGVyO1xcblxcdCAgICB9IGVsc2UgaWYgKCFmaWxlTmFtZUNoYW5nZWQodGhlaXJzKSkge1xcblxcdCAgICAgIC8vIE5vIGhlYWRlciBvciBubyBjaGFuZ2UgaW4gdGhlaXJzLCB1c2Ugb3Vyc1xcblxcdCAgICAgIHJldC5vbGRGaWxlTmFtZSA9IG1pbmUub2xkRmlsZU5hbWU7XFxuXFx0ICAgICAgcmV0Lm5ld0ZpbGVOYW1lID0gbWluZS5uZXdGaWxlTmFtZTtcXG5cXHQgICAgICByZXQub2xkSGVhZGVyID0gbWluZS5vbGRIZWFkZXI7XFxuXFx0ICAgICAgcmV0Lm5ld0hlYWRlciA9IG1pbmUubmV3SGVhZGVyO1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIC8vIEJvdGggY2hhbmdlZC4uLiBmaWd1cmUgaXQgb3V0XFxuXFx0ICAgICAgcmV0Lm9sZEZpbGVOYW1lID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm9sZEZpbGVOYW1lLCB0aGVpcnMub2xkRmlsZU5hbWUpO1xcblxcdCAgICAgIHJldC5uZXdGaWxlTmFtZSA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5uZXdGaWxlTmFtZSwgdGhlaXJzLm5ld0ZpbGVOYW1lKTtcXG5cXHQgICAgICByZXQub2xkSGVhZGVyID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm9sZEhlYWRlciwgdGhlaXJzLm9sZEhlYWRlcik7XFxuXFx0ICAgICAgcmV0Lm5ld0hlYWRlciA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5uZXdIZWFkZXIsIHRoZWlycy5uZXdIZWFkZXIpO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICByZXQuaHVua3MgPSBbXTtcXG5cXG5cXHQgIHZhciBtaW5lSW5kZXggPSAwLFxcblxcdCAgICAgIHRoZWlyc0luZGV4ID0gMCxcXG5cXHQgICAgICBtaW5lT2Zmc2V0ID0gMCxcXG5cXHQgICAgICB0aGVpcnNPZmZzZXQgPSAwO1xcblxcblxcdCAgd2hpbGUgKG1pbmVJbmRleCA8IG1pbmUuaHVua3MubGVuZ3RoIHx8IHRoZWlyc0luZGV4IDwgdGhlaXJzLmh1bmtzLmxlbmd0aCkge1xcblxcdCAgICB2YXIgbWluZUN1cnJlbnQgPSBtaW5lLmh1bmtzW21pbmVJbmRleF0gfHwgeyBvbGRTdGFydDogSW5maW5pdHkgfSxcXG5cXHQgICAgICAgIHRoZWlyc0N1cnJlbnQgPSB0aGVpcnMuaHVua3NbdGhlaXJzSW5kZXhdIHx8IHsgb2xkU3RhcnQ6IEluZmluaXR5IH07XFxuXFxuXFx0ICAgIGlmIChodW5rQmVmb3JlKG1pbmVDdXJyZW50LCB0aGVpcnNDdXJyZW50KSkge1xcblxcdCAgICAgIC8vIFRoaXMgcGF0Y2ggZG9lcyBub3Qgb3ZlcmxhcCB3aXRoIGFueSBvZiB0aGUgb3RoZXJzLCB5YXkuXFxuXFx0ICAgICAgcmV0Lmh1bmtzLnB1c2goY2xvbmVIdW5rKG1pbmVDdXJyZW50LCBtaW5lT2Zmc2V0KSk7XFxuXFx0ICAgICAgbWluZUluZGV4Kys7XFxuXFx0ICAgICAgdGhlaXJzT2Zmc2V0ICs9IG1pbmVDdXJyZW50Lm5ld0xpbmVzIC0gbWluZUN1cnJlbnQub2xkTGluZXM7XFxuXFx0ICAgIH0gZWxzZSBpZiAoaHVua0JlZm9yZSh0aGVpcnNDdXJyZW50LCBtaW5lQ3VycmVudCkpIHtcXG5cXHQgICAgICAvLyBUaGlzIHBhdGNoIGRvZXMgbm90IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIG90aGVycywgeWF5LlxcblxcdCAgICAgIHJldC5odW5rcy5wdXNoKGNsb25lSHVuayh0aGVpcnNDdXJyZW50LCB0aGVpcnNPZmZzZXQpKTtcXG5cXHQgICAgICB0aGVpcnNJbmRleCsrO1xcblxcdCAgICAgIG1pbmVPZmZzZXQgKz0gdGhlaXJzQ3VycmVudC5uZXdMaW5lcyAtIHRoZWlyc0N1cnJlbnQub2xkTGluZXM7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgLy8gT3ZlcmxhcCwgbWVyZ2UgYXMgYmVzdCB3ZSBjYW5cXG5cXHQgICAgICB2YXIgbWVyZ2VkSHVuayA9IHtcXG5cXHQgICAgICAgIG9sZFN0YXJ0OiBNYXRoLm1pbihtaW5lQ3VycmVudC5vbGRTdGFydCwgdGhlaXJzQ3VycmVudC5vbGRTdGFydCksXFxuXFx0ICAgICAgICBvbGRMaW5lczogMCxcXG5cXHQgICAgICAgIG5ld1N0YXJ0OiBNYXRoLm1pbihtaW5lQ3VycmVudC5uZXdTdGFydCArIG1pbmVPZmZzZXQsIHRoZWlyc0N1cnJlbnQub2xkU3RhcnQgKyB0aGVpcnNPZmZzZXQpLFxcblxcdCAgICAgICAgbmV3TGluZXM6IDAsXFxuXFx0ICAgICAgICBsaW5lczogW11cXG5cXHQgICAgICB9O1xcblxcdCAgICAgIG1lcmdlTGluZXMobWVyZ2VkSHVuaywgbWluZUN1cnJlbnQub2xkU3RhcnQsIG1pbmVDdXJyZW50LmxpbmVzLCB0aGVpcnNDdXJyZW50Lm9sZFN0YXJ0LCB0aGVpcnNDdXJyZW50LmxpbmVzKTtcXG5cXHQgICAgICB0aGVpcnNJbmRleCsrO1xcblxcdCAgICAgIG1pbmVJbmRleCsrO1xcblxcblxcdCAgICAgIHJldC5odW5rcy5wdXNoKG1lcmdlZEh1bmspO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICByZXR1cm4gcmV0O1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBsb2FkUGF0Y2gocGFyYW0sIGJhc2UpIHtcXG5cXHQgIGlmICh0eXBlb2YgcGFyYW0gPT09ICdzdHJpbmcnKSB7XFxuXFx0ICAgIGlmICgvXkBAL20udGVzdChwYXJhbSkgfHwgL15JbmRleDovbS50ZXN0KHBhcmFtKSkge1xcblxcdCAgICAgIHJldHVybiAoLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLygwLCBfcGFyc2UucGFyc2VQYXRjaCkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8ocGFyYW0pWzBdXFxuXFx0ICAgICAgKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICBpZiAoIWJhc2UpIHtcXG5cXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhIGJhc2UgcmVmZXJlbmNlIG9yIHBhc3MgaW4gYSBwYXRjaCcpO1xcblxcdCAgICB9XFxuXFx0ICAgIHJldHVybiAoLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLygwLCBfY3JlYXRlLnN0cnVjdHVyZWRQYXRjaCkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8odW5kZWZpbmVkLCB1bmRlZmluZWQsIGJhc2UsIHBhcmFtKVxcblxcdCAgICApO1xcblxcdCAgfVxcblxcblxcdCAgcmV0dXJuIHBhcmFtO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBmaWxlTmFtZUNoYW5nZWQocGF0Y2gpIHtcXG5cXHQgIHJldHVybiBwYXRjaC5uZXdGaWxlTmFtZSAmJiBwYXRjaC5uZXdGaWxlTmFtZSAhPT0gcGF0Y2gub2xkRmlsZU5hbWU7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHNlbGVjdEZpZWxkKGluZGV4LCBtaW5lLCB0aGVpcnMpIHtcXG5cXHQgIGlmIChtaW5lID09PSB0aGVpcnMpIHtcXG5cXHQgICAgcmV0dXJuIG1pbmU7XFxuXFx0ICB9IGVsc2Uge1xcblxcdCAgICBpbmRleC5jb25mbGljdCA9IHRydWU7XFxuXFx0ICAgIHJldHVybiB7IG1pbmU6IG1pbmUsIHRoZWlyczogdGhlaXJzIH07XFxuXFx0ICB9XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGh1bmtCZWZvcmUodGVzdCwgY2hlY2spIHtcXG5cXHQgIHJldHVybiB0ZXN0Lm9sZFN0YXJ0IDwgY2hlY2sub2xkU3RhcnQgJiYgdGVzdC5vbGRTdGFydCArIHRlc3Qub2xkTGluZXMgPCBjaGVjay5vbGRTdGFydDtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gY2xvbmVIdW5rKGh1bmssIG9mZnNldCkge1xcblxcdCAgcmV0dXJuIHtcXG5cXHQgICAgb2xkU3RhcnQ6IGh1bmsub2xkU3RhcnQsIG9sZExpbmVzOiBodW5rLm9sZExpbmVzLFxcblxcdCAgICBuZXdTdGFydDogaHVuay5uZXdTdGFydCArIG9mZnNldCwgbmV3TGluZXM6IGh1bmsubmV3TGluZXMsXFxuXFx0ICAgIGxpbmVzOiBodW5rLmxpbmVzXFxuXFx0ICB9O1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBtZXJnZUxpbmVzKGh1bmssIG1pbmVPZmZzZXQsIG1pbmVMaW5lcywgdGhlaXJPZmZzZXQsIHRoZWlyTGluZXMpIHtcXG5cXHQgIC8vIFRoaXMgd2lsbCBnZW5lcmFsbHkgcmVzdWx0IGluIGEgY29uZmxpY3RlZCBodW5rLCBidXQgdGhlcmUgYXJlIGNhc2VzIHdoZXJlIHRoZSBjb250ZXh0XFxuXFx0ICAvLyBpcyB0aGUgb25seSBvdmVybGFwIHdoZXJlIHdlIGNhbiBzdWNjZXNzZnVsbHkgbWVyZ2UgdGhlIGNvbnRlbnQgaGVyZS5cXG5cXHQgIHZhciBtaW5lID0geyBvZmZzZXQ6IG1pbmVPZmZzZXQsIGxpbmVzOiBtaW5lTGluZXMsIGluZGV4OiAwIH0sXFxuXFx0ICAgICAgdGhlaXIgPSB7IG9mZnNldDogdGhlaXJPZmZzZXQsIGxpbmVzOiB0aGVpckxpbmVzLCBpbmRleDogMCB9O1xcblxcblxcdCAgLy8gSGFuZGxlIGFueSBsZWFkaW5nIGNvbnRlbnRcXG5cXHQgIGluc2VydExlYWRpbmcoaHVuaywgbWluZSwgdGhlaXIpO1xcblxcdCAgaW5zZXJ0TGVhZGluZyhodW5rLCB0aGVpciwgbWluZSk7XFxuXFxuXFx0ICAvLyBOb3cgaW4gdGhlIG92ZXJsYXAgY29udGVudC4gU2NhbiB0aHJvdWdoIGFuZCBzZWxlY3QgdGhlIGJlc3QgY2hhbmdlcyBmcm9tIGVhY2guXFxuXFx0ICB3aGlsZSAobWluZS5pbmRleCA8IG1pbmUubGluZXMubGVuZ3RoICYmIHRoZWlyLmluZGV4IDwgdGhlaXIubGluZXMubGVuZ3RoKSB7XFxuXFx0ICAgIHZhciBtaW5lQ3VycmVudCA9IG1pbmUubGluZXNbbWluZS5pbmRleF0sXFxuXFx0ICAgICAgICB0aGVpckN1cnJlbnQgPSB0aGVpci5saW5lc1t0aGVpci5pbmRleF07XFxuXFxuXFx0ICAgIGlmICgobWluZUN1cnJlbnRbMF0gPT09ICctJyB8fCBtaW5lQ3VycmVudFswXSA9PT0gJysnKSAmJiAodGhlaXJDdXJyZW50WzBdID09PSAnLScgfHwgdGhlaXJDdXJyZW50WzBdID09PSAnKycpKSB7XFxuXFx0ICAgICAgLy8gQm90aCBtb2RpZmllZCAuLi5cXG5cXHQgICAgICBtdXR1YWxDaGFuZ2UoaHVuaywgbWluZSwgdGhlaXIpO1xcblxcdCAgICB9IGVsc2UgaWYgKG1pbmVDdXJyZW50WzBdID09PSAnKycgJiYgdGhlaXJDdXJyZW50WzBdID09PSAnICcpIHtcXG5cXHQgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9odW5rJGxpbmVzO1xcblxcblxcdCAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovIC8vIE1pbmUgaW5zZXJ0ZWRcXG5cXHQgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKF9odW5rJGxpbmVzID0gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9odW5rLmxpbmVzKS5wdXNoLiAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovYXBwbHkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9faHVuayRsaW5lcyAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLywgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL190b0NvbnN1bWFibGVBcnJheSggLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jb2xsZWN0Q2hhbmdlKG1pbmUpKSk7XFxuXFx0ICAgIH0gZWxzZSBpZiAodGhlaXJDdXJyZW50WzBdID09PSAnKycgJiYgbWluZUN1cnJlbnRbMF0gPT09ICcgJykge1xcblxcdCAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2h1bmskbGluZXMyO1xcblxcblxcdCAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovIC8vIFRoZWlycyBpbnNlcnRlZFxcblxcdCAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oX2h1bmskbGluZXMyID0gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9odW5rLmxpbmVzKS5wdXNoLiAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovYXBwbHkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9faHVuayRsaW5lczIgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8sIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fdG9Db25zdW1hYmxlQXJyYXkoIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY29sbGVjdENoYW5nZSh0aGVpcikpKTtcXG5cXHQgICAgfSBlbHNlIGlmIChtaW5lQ3VycmVudFswXSA9PT0gJy0nICYmIHRoZWlyQ3VycmVudFswXSA9PT0gJyAnKSB7XFxuXFx0ICAgICAgLy8gTWluZSByZW1vdmVkIG9yIGVkaXRlZFxcblxcdCAgICAgIHJlbW92YWwoaHVuaywgbWluZSwgdGhlaXIpO1xcblxcdCAgICB9IGVsc2UgaWYgKHRoZWlyQ3VycmVudFswXSA9PT0gJy0nICYmIG1pbmVDdXJyZW50WzBdID09PSAnICcpIHtcXG5cXHQgICAgICAvLyBUaGVpciByZW1vdmVkIG9yIGVkaXRlZFxcblxcdCAgICAgIHJlbW92YWwoaHVuaywgdGhlaXIsIG1pbmUsIHRydWUpO1xcblxcdCAgICB9IGVsc2UgaWYgKG1pbmVDdXJyZW50ID09PSB0aGVpckN1cnJlbnQpIHtcXG5cXHQgICAgICAvLyBDb250ZXh0IGlkZW50aXR5XFxuXFx0ICAgICAgaHVuay5saW5lcy5wdXNoKG1pbmVDdXJyZW50KTtcXG5cXHQgICAgICBtaW5lLmluZGV4Kys7XFxuXFx0ICAgICAgdGhlaXIuaW5kZXgrKztcXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICAvLyBDb250ZXh0IG1pc21hdGNoXFxuXFx0ICAgICAgY29uZmxpY3QoaHVuaywgY29sbGVjdENoYW5nZShtaW5lKSwgY29sbGVjdENoYW5nZSh0aGVpcikpO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBOb3cgcHVzaCBhbnl0aGluZyB0aGF0IG1heSBiZSByZW1haW5pbmdcXG5cXHQgIGluc2VydFRyYWlsaW5nKGh1bmssIG1pbmUpO1xcblxcdCAgaW5zZXJ0VHJhaWxpbmcoaHVuaywgdGhlaXIpO1xcblxcblxcdCAgY2FsY0xpbmVDb3VudChodW5rKTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gbXV0dWFsQ2hhbmdlKGh1bmssIG1pbmUsIHRoZWlyKSB7XFxuXFx0ICB2YXIgbXlDaGFuZ2VzID0gY29sbGVjdENoYW5nZShtaW5lKSxcXG5cXHQgICAgICB0aGVpckNoYW5nZXMgPSBjb2xsZWN0Q2hhbmdlKHRoZWlyKTtcXG5cXG5cXHQgIGlmIChhbGxSZW1vdmVzKG15Q2hhbmdlcykgJiYgYWxsUmVtb3Zlcyh0aGVpckNoYW5nZXMpKSB7XFxuXFx0ICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgcmVtb3ZlIGNoYW5nZXMgdGhhdCBhcmUgc3VwZXJzZXRzIG9mIG9uZSBhbm90aGVyXFxuXFx0ICAgIGlmICggLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLygwLCBfYXJyYXkuYXJyYXlTdGFydHNXaXRoKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyhteUNoYW5nZXMsIHRoZWlyQ2hhbmdlcykgJiYgc2tpcFJlbW92ZVN1cGVyc2V0KHRoZWlyLCBteUNoYW5nZXMsIG15Q2hhbmdlcy5sZW5ndGggLSB0aGVpckNoYW5nZXMubGVuZ3RoKSkge1xcblxcdCAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2h1bmskbGluZXMzO1xcblxcblxcdCAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oX2h1bmskbGluZXMzID0gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9odW5rLmxpbmVzKS5wdXNoLiAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovYXBwbHkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9faHVuayRsaW5lczMgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8sIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fdG9Db25zdW1hYmxlQXJyYXkoIC8qaXN0YW5idWwgaWdub3JlIGVuZCovbXlDaGFuZ2VzKSk7XFxuXFx0ICAgICAgcmV0dXJuO1xcblxcdCAgICB9IGVsc2UgaWYgKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKDAsIF9hcnJheS5hcnJheVN0YXJ0c1dpdGgpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKHRoZWlyQ2hhbmdlcywgbXlDaGFuZ2VzKSAmJiBza2lwUmVtb3ZlU3VwZXJzZXQobWluZSwgdGhlaXJDaGFuZ2VzLCB0aGVpckNoYW5nZXMubGVuZ3RoIC0gbXlDaGFuZ2VzLmxlbmd0aCkpIHtcXG5cXHQgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9odW5rJGxpbmVzNDtcXG5cXG5cXHQgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKF9odW5rJGxpbmVzNCA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovaHVuay5saW5lcykucHVzaC4gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2FwcGx5IC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2h1bmskbGluZXM0IC8qaXN0YW5idWwgaWdub3JlIGVuZCovLCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3RvQ29uc3VtYWJsZUFycmF5KCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3RoZWlyQ2hhbmdlcykpO1xcblxcdCAgICAgIHJldHVybjtcXG5cXHQgICAgfVxcblxcdCAgfSBlbHNlIGlmICggLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLygwLCBfYXJyYXkuYXJyYXlFcXVhbCkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8obXlDaGFuZ2VzLCB0aGVpckNoYW5nZXMpKSB7XFxuXFx0ICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2h1bmskbGluZXM1O1xcblxcblxcdCAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKF9odW5rJGxpbmVzNSA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovaHVuay5saW5lcykucHVzaC4gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2FwcGx5IC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2h1bmskbGluZXM1IC8qaXN0YW5idWwgaWdub3JlIGVuZCovLCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3RvQ29uc3VtYWJsZUFycmF5KCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL215Q2hhbmdlcykpO1xcblxcdCAgICByZXR1cm47XFxuXFx0ICB9XFxuXFxuXFx0ICBjb25mbGljdChodW5rLCBteUNoYW5nZXMsIHRoZWlyQ2hhbmdlcyk7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHJlbW92YWwoaHVuaywgbWluZSwgdGhlaXIsIHN3YXApIHtcXG5cXHQgIHZhciBteUNoYW5nZXMgPSBjb2xsZWN0Q2hhbmdlKG1pbmUpLFxcblxcdCAgICAgIHRoZWlyQ2hhbmdlcyA9IGNvbGxlY3RDb250ZXh0KHRoZWlyLCBteUNoYW5nZXMpO1xcblxcdCAgaWYgKHRoZWlyQ2hhbmdlcy5tZXJnZWQpIHtcXG5cXHQgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfaHVuayRsaW5lczY7XFxuXFxuXFx0ICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oX2h1bmskbGluZXM2ID0gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9odW5rLmxpbmVzKS5wdXNoLiAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovYXBwbHkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9faHVuayRsaW5lczYgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8sIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fdG9Db25zdW1hYmxlQXJyYXkoIC8qaXN0YW5idWwgaWdub3JlIGVuZCovdGhlaXJDaGFuZ2VzLm1lcmdlZCkpO1xcblxcdCAgfSBlbHNlIHtcXG5cXHQgICAgY29uZmxpY3QoaHVuaywgc3dhcCA/IHRoZWlyQ2hhbmdlcyA6IG15Q2hhbmdlcywgc3dhcCA/IG15Q2hhbmdlcyA6IHRoZWlyQ2hhbmdlcyk7XFxuXFx0ICB9XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGNvbmZsaWN0KGh1bmssIG1pbmUsIHRoZWlyKSB7XFxuXFx0ICBodW5rLmNvbmZsaWN0ID0gdHJ1ZTtcXG5cXHQgIGh1bmsubGluZXMucHVzaCh7XFxuXFx0ICAgIGNvbmZsaWN0OiB0cnVlLFxcblxcdCAgICBtaW5lOiBtaW5lLFxcblxcdCAgICB0aGVpcnM6IHRoZWlyXFxuXFx0ICB9KTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gaW5zZXJ0TGVhZGluZyhodW5rLCBpbnNlcnQsIHRoZWlyKSB7XFxuXFx0ICB3aGlsZSAoaW5zZXJ0Lm9mZnNldCA8IHRoZWlyLm9mZnNldCAmJiBpbnNlcnQuaW5kZXggPCBpbnNlcnQubGluZXMubGVuZ3RoKSB7XFxuXFx0ICAgIHZhciBsaW5lID0gaW5zZXJ0LmxpbmVzW2luc2VydC5pbmRleCsrXTtcXG5cXHQgICAgaHVuay5saW5lcy5wdXNoKGxpbmUpO1xcblxcdCAgICBpbnNlcnQub2Zmc2V0Kys7XFxuXFx0ICB9XFxuXFx0fVxcblxcdGZ1bmN0aW9uIGluc2VydFRyYWlsaW5nKGh1bmssIGluc2VydCkge1xcblxcdCAgd2hpbGUgKGluc2VydC5pbmRleCA8IGluc2VydC5saW5lcy5sZW5ndGgpIHtcXG5cXHQgICAgdmFyIGxpbmUgPSBpbnNlcnQubGluZXNbaW5zZXJ0LmluZGV4KytdO1xcblxcdCAgICBodW5rLmxpbmVzLnB1c2gobGluZSk7XFxuXFx0ICB9XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGNvbGxlY3RDaGFuZ2Uoc3RhdGUpIHtcXG5cXHQgIHZhciByZXQgPSBbXSxcXG5cXHQgICAgICBvcGVyYXRpb24gPSBzdGF0ZS5saW5lc1tzdGF0ZS5pbmRleF1bMF07XFxuXFx0ICB3aGlsZSAoc3RhdGUuaW5kZXggPCBzdGF0ZS5saW5lcy5sZW5ndGgpIHtcXG5cXHQgICAgdmFyIGxpbmUgPSBzdGF0ZS5saW5lc1tzdGF0ZS5pbmRleF07XFxuXFxuXFx0ICAgIC8vIEdyb3VwIGFkZGl0aW9ucyB0aGF0IGFyZSBpbW1lZGlhdGVseSBhZnRlciBzdWJ0cmFjdGlvbnMgYW5kIHRyZWF0IHRoZW0gYXMgb25lIFxcXCJhdG9taWNcXFwiIG1vZGlmeSBjaGFuZ2UuXFxuXFx0ICAgIGlmIChvcGVyYXRpb24gPT09ICctJyAmJiBsaW5lWzBdID09PSAnKycpIHtcXG5cXHQgICAgICBvcGVyYXRpb24gPSAnKyc7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgaWYgKG9wZXJhdGlvbiA9PT0gbGluZVswXSkge1xcblxcdCAgICAgIHJldC5wdXNoKGxpbmUpO1xcblxcdCAgICAgIHN0YXRlLmluZGV4Kys7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgYnJlYWs7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiByZXQ7XFxuXFx0fVxcblxcdGZ1bmN0aW9uIGNvbGxlY3RDb250ZXh0KHN0YXRlLCBtYXRjaENoYW5nZXMpIHtcXG5cXHQgIHZhciBjaGFuZ2VzID0gW10sXFxuXFx0ICAgICAgbWVyZ2VkID0gW10sXFxuXFx0ICAgICAgbWF0Y2hJbmRleCA9IDAsXFxuXFx0ICAgICAgY29udGV4dENoYW5nZXMgPSBmYWxzZSxcXG5cXHQgICAgICBjb25mbGljdGVkID0gZmFsc2U7XFxuXFx0ICB3aGlsZSAobWF0Y2hJbmRleCA8IG1hdGNoQ2hhbmdlcy5sZW5ndGggJiYgc3RhdGUuaW5kZXggPCBzdGF0ZS5saW5lcy5sZW5ndGgpIHtcXG5cXHQgICAgdmFyIGNoYW5nZSA9IHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4XSxcXG5cXHQgICAgICAgIG1hdGNoID0gbWF0Y2hDaGFuZ2VzW21hdGNoSW5kZXhdO1xcblxcblxcdCAgICAvLyBPbmNlIHdlJ3ZlIGhpdCBvdXIgYWRkLCB0aGVuIHdlIGFyZSBkb25lXFxuXFx0ICAgIGlmIChtYXRjaFswXSA9PT0gJysnKSB7XFxuXFx0ICAgICAgYnJlYWs7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgY29udGV4dENoYW5nZXMgPSBjb250ZXh0Q2hhbmdlcyB8fCBjaGFuZ2VbMF0gIT09ICcgJztcXG5cXG5cXHQgICAgbWVyZ2VkLnB1c2gobWF0Y2gpO1xcblxcdCAgICBtYXRjaEluZGV4Kys7XFxuXFxuXFx0ICAgIC8vIENvbnN1bWUgYW55IGFkZGl0aW9ucyBpbiB0aGUgb3RoZXIgYmxvY2sgYXMgYSBjb25mbGljdCB0byBhdHRlbXB0XFxuXFx0ICAgIC8vIHRvIHB1bGwgaW4gdGhlIHJlbWFpbmluZyBjb250ZXh0IGFmdGVyIHRoaXNcXG5cXHQgICAgaWYgKGNoYW5nZVswXSA9PT0gJysnKSB7XFxuXFx0ICAgICAgY29uZmxpY3RlZCA9IHRydWU7XFxuXFxuXFx0ICAgICAgd2hpbGUgKGNoYW5nZVswXSA9PT0gJysnKSB7XFxuXFx0ICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcXG5cXHQgICAgICAgIGNoYW5nZSA9IHN0YXRlLmxpbmVzWysrc3RhdGUuaW5kZXhdO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcblxcdCAgICBpZiAobWF0Y2guc3Vic3RyKDEpID09PSBjaGFuZ2Uuc3Vic3RyKDEpKSB7XFxuXFx0ICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XFxuXFx0ICAgICAgc3RhdGUuaW5kZXgrKztcXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICBjb25mbGljdGVkID0gdHJ1ZTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgaWYgKChtYXRjaENoYW5nZXNbbWF0Y2hJbmRleF0gfHwgJycpWzBdID09PSAnKycgJiYgY29udGV4dENoYW5nZXMpIHtcXG5cXHQgICAgY29uZmxpY3RlZCA9IHRydWU7XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAoY29uZmxpY3RlZCkge1xcblxcdCAgICByZXR1cm4gY2hhbmdlcztcXG5cXHQgIH1cXG5cXG5cXHQgIHdoaWxlIChtYXRjaEluZGV4IDwgbWF0Y2hDaGFuZ2VzLmxlbmd0aCkge1xcblxcdCAgICBtZXJnZWQucHVzaChtYXRjaENoYW5nZXNbbWF0Y2hJbmRleCsrXSk7XFxuXFx0ICB9XFxuXFxuXFx0ICByZXR1cm4ge1xcblxcdCAgICBtZXJnZWQ6IG1lcmdlZCxcXG5cXHQgICAgY2hhbmdlczogY2hhbmdlc1xcblxcdCAgfTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gYWxsUmVtb3ZlcyhjaGFuZ2VzKSB7XFxuXFx0ICByZXR1cm4gY2hhbmdlcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGNoYW5nZSkge1xcblxcdCAgICByZXR1cm4gcHJldiAmJiBjaGFuZ2VbMF0gPT09ICctJztcXG5cXHQgIH0sIHRydWUpO1xcblxcdH1cXG5cXHRmdW5jdGlvbiBza2lwUmVtb3ZlU3VwZXJzZXQoc3RhdGUsIHJlbW92ZUNoYW5nZXMsIGRlbHRhKSB7XFxuXFx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbHRhOyBpKyspIHtcXG5cXHQgICAgdmFyIGNoYW5nZUNvbnRlbnQgPSByZW1vdmVDaGFuZ2VzW3JlbW92ZUNoYW5nZXMubGVuZ3RoIC0gZGVsdGEgKyBpXS5zdWJzdHIoMSk7XFxuXFx0ICAgIGlmIChzdGF0ZS5saW5lc1tzdGF0ZS5pbmRleCArIGldICE9PSAnICcgKyBjaGFuZ2VDb250ZW50KSB7XFxuXFx0ICAgICAgcmV0dXJuIGZhbHNlO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICBzdGF0ZS5pbmRleCArPSBkZWx0YTtcXG5cXHQgIHJldHVybiB0cnVlO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBjYWxjT2xkTmV3TGluZUNvdW50KGxpbmVzKSB7XFxuXFx0ICB2YXIgb2xkTGluZXMgPSAwO1xcblxcdCAgdmFyIG5ld0xpbmVzID0gMDtcXG5cXG5cXHQgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcXG5cXHQgICAgaWYgKHR5cGVvZiBsaW5lICE9PSAnc3RyaW5nJykge1xcblxcdCAgICAgIHZhciBteUNvdW50ID0gY2FsY09sZE5ld0xpbmVDb3VudChsaW5lLm1pbmUpO1xcblxcdCAgICAgIHZhciB0aGVpckNvdW50ID0gY2FsY09sZE5ld0xpbmVDb3VudChsaW5lLnRoZWlycyk7XFxuXFxuXFx0ICAgICAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQpIHtcXG5cXHQgICAgICAgIGlmIChteUNvdW50Lm9sZExpbmVzID09PSB0aGVpckNvdW50Lm9sZExpbmVzKSB7XFxuXFx0ICAgICAgICAgIG9sZExpbmVzICs9IG15Q291bnQub2xkTGluZXM7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICBvbGRMaW5lcyA9IHVuZGVmaW5lZDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9XFxuXFxuXFx0ICAgICAgaWYgKG5ld0xpbmVzICE9PSB1bmRlZmluZWQpIHtcXG5cXHQgICAgICAgIGlmIChteUNvdW50Lm5ld0xpbmVzID09PSB0aGVpckNvdW50Lm5ld0xpbmVzKSB7XFxuXFx0ICAgICAgICAgIG5ld0xpbmVzICs9IG15Q291bnQubmV3TGluZXM7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICBuZXdMaW5lcyA9IHVuZGVmaW5lZDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgaWYgKG5ld0xpbmVzICE9PSB1bmRlZmluZWQgJiYgKGxpbmVbMF0gPT09ICcrJyB8fCBsaW5lWzBdID09PSAnICcpKSB7XFxuXFx0ICAgICAgICBuZXdMaW5lcysrO1xcblxcdCAgICAgIH1cXG5cXHQgICAgICBpZiAob2xkTGluZXMgIT09IHVuZGVmaW5lZCAmJiAobGluZVswXSA9PT0gJy0nIHx8IGxpbmVbMF0gPT09ICcgJykpIHtcXG5cXHQgICAgICAgIG9sZExpbmVzKys7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICB9KTtcXG5cXG5cXHQgIHJldHVybiB7IG9sZExpbmVzOiBvbGRMaW5lcywgbmV3TGluZXM6IG5ld0xpbmVzIH07XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDE0ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3N0cnVjdHVyZWRQYXRjaCA9IHN0cnVjdHVyZWRQYXRjaDtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jcmVhdGVUd29GaWxlc1BhdGNoID0gY3JlYXRlVHdvRmlsZXNQYXRjaDtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jcmVhdGVQYXRjaCA9IGNyZWF0ZVBhdGNoO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2xpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2Z1bmN0aW9uIHN0cnVjdHVyZWRQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucykge1xcblxcdCAgaWYgKCFvcHRpb25zKSB7XFxuXFx0ICAgIG9wdGlvbnMgPSB7fTtcXG5cXHQgIH1cXG5cXHQgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb250ZXh0ID09PSAndW5kZWZpbmVkJykge1xcblxcdCAgICBvcHRpb25zLmNvbnRleHQgPSA0O1xcblxcdCAgfVxcblxcblxcdCAgdmFyIGRpZmYgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKDAsIF9saW5lLmRpZmZMaW5lcykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8ob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xcblxcdCAgZGlmZi5wdXNoKHsgdmFsdWU6ICcnLCBsaW5lczogW10gfSk7IC8vIEFwcGVuZCBhbiBlbXB0eSB2YWx1ZSB0byBtYWtlIGNsZWFudXAgZWFzaWVyXFxuXFxuXFx0ICBmdW5jdGlvbiBjb250ZXh0TGluZXMobGluZXMpIHtcXG5cXHQgICAgcmV0dXJuIGxpbmVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcXG5cXHQgICAgICByZXR1cm4gJyAnICsgZW50cnk7XFxuXFx0ICAgIH0pO1xcblxcdCAgfVxcblxcblxcdCAgdmFyIGh1bmtzID0gW107XFxuXFx0ICB2YXIgb2xkUmFuZ2VTdGFydCA9IDAsXFxuXFx0ICAgICAgbmV3UmFuZ2VTdGFydCA9IDAsXFxuXFx0ICAgICAgY3VyUmFuZ2UgPSBbXSxcXG5cXHQgICAgICBvbGRMaW5lID0gMSxcXG5cXHQgICAgICBuZXdMaW5lID0gMTtcXG5cXG5cXHQgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCggLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9pKSB7XFxuXFx0ICAgIHZhciBjdXJyZW50ID0gZGlmZltpXSxcXG5cXHQgICAgICAgIGxpbmVzID0gY3VycmVudC5saW5lcyB8fCBjdXJyZW50LnZhbHVlLnJlcGxhY2UoL1xcXFxuJC8sICcnKS5zcGxpdCgnXFxcXG4nKTtcXG5cXHQgICAgY3VycmVudC5saW5lcyA9IGxpbmVzO1xcblxcblxcdCAgICBpZiAoY3VycmVudC5hZGRlZCB8fCBjdXJyZW50LnJlbW92ZWQpIHtcXG5cXHQgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9jdXJSYW5nZTtcXG5cXG5cXHQgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyAvLyBJZiB3ZSBoYXZlIHByZXZpb3VzIGNvbnRleHQsIHN0YXJ0IHdpdGggdGhhdFxcblxcdCAgICAgIGlmICghb2xkUmFuZ2VTdGFydCkge1xcblxcdCAgICAgICAgdmFyIHByZXYgPSBkaWZmW2kgLSAxXTtcXG5cXHQgICAgICAgIG9sZFJhbmdlU3RhcnQgPSBvbGRMaW5lO1xcblxcdCAgICAgICAgbmV3UmFuZ2VTdGFydCA9IG5ld0xpbmU7XFxuXFxuXFx0ICAgICAgICBpZiAocHJldikge1xcblxcdCAgICAgICAgICBjdXJSYW5nZSA9IG9wdGlvbnMuY29udGV4dCA+IDAgPyBjb250ZXh0TGluZXMocHJldi5saW5lcy5zbGljZSgtb3B0aW9ucy5jb250ZXh0KSkgOiBbXTtcXG5cXHQgICAgICAgICAgb2xkUmFuZ2VTdGFydCAtPSBjdXJSYW5nZS5sZW5ndGg7XFxuXFx0ICAgICAgICAgIG5ld1JhbmdlU3RhcnQgLT0gY3VyUmFuZ2UubGVuZ3RoO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgIH1cXG5cXG5cXHQgICAgICAvLyBPdXRwdXQgb3VyIGNoYW5nZXNcXG5cXHQgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKF9jdXJSYW5nZSA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovY3VyUmFuZ2UpLnB1c2guIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9hcHBseSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyggLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19jdXJSYW5nZSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLywgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL190b0NvbnN1bWFibGVBcnJheSggLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9saW5lcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XFxuXFx0ICAgICAgICByZXR1cm4gKGN1cnJlbnQuYWRkZWQgPyAnKycgOiAnLScpICsgZW50cnk7XFxuXFx0ICAgICAgfSkpKTtcXG5cXG5cXHQgICAgICAvLyBUcmFjayB0aGUgdXBkYXRlZCBmaWxlIHBvc2l0aW9uXFxuXFx0ICAgICAgaWYgKGN1cnJlbnQuYWRkZWQpIHtcXG5cXHQgICAgICAgIG5ld0xpbmUgKz0gbGluZXMubGVuZ3RoO1xcblxcdCAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICBvbGRMaW5lICs9IGxpbmVzLmxlbmd0aDtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgLy8gSWRlbnRpY2FsIGNvbnRleHQgbGluZXMuIFRyYWNrIGxpbmUgY2hhbmdlc1xcblxcdCAgICAgIGlmIChvbGRSYW5nZVN0YXJ0KSB7XFxuXFx0ICAgICAgICAvLyBDbG9zZSBvdXQgYW55IGNoYW5nZXMgdGhhdCBoYXZlIGJlZW4gb3V0cHV0IChvciBqb2luIG92ZXJsYXBwaW5nKVxcblxcdCAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA8PSBvcHRpb25zLmNvbnRleHQgKiAyICYmIGkgPCBkaWZmLmxlbmd0aCAtIDIpIHtcXG5cXHQgICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfY3VyUmFuZ2UyO1xcblxcblxcdCAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyAvLyBPdmVybGFwcGluZ1xcblxcdCAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKF9jdXJSYW5nZTIgPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2N1clJhbmdlKS5wdXNoLiAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovYXBwbHkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fY3VyUmFuZ2UyIC8qaXN0YW5idWwgaWdub3JlIGVuZCovLCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3RvQ29uc3VtYWJsZUFycmF5KCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NvbnRleHRMaW5lcyhsaW5lcykpKTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2N1clJhbmdlMztcXG5cXG5cXHQgICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8gLy8gZW5kIHRoZSByYW5nZSBhbmQgb3V0cHV0XFxuXFx0ICAgICAgICAgIHZhciBjb250ZXh0U2l6ZSA9IE1hdGgubWluKGxpbmVzLmxlbmd0aCwgb3B0aW9ucy5jb250ZXh0KTtcXG5cXHQgICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyhfY3VyUmFuZ2UzID0gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jdXJSYW5nZSkucHVzaC4gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2FwcGx5IC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2N1clJhbmdlMyAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLywgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL190b0NvbnN1bWFibGVBcnJheSggLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jb250ZXh0TGluZXMobGluZXMuc2xpY2UoMCwgY29udGV4dFNpemUpKSkpO1xcblxcblxcdCAgICAgICAgICB2YXIgaHVuayA9IHtcXG5cXHQgICAgICAgICAgICBvbGRTdGFydDogb2xkUmFuZ2VTdGFydCxcXG5cXHQgICAgICAgICAgICBvbGRMaW5lczogb2xkTGluZSAtIG9sZFJhbmdlU3RhcnQgKyBjb250ZXh0U2l6ZSxcXG5cXHQgICAgICAgICAgICBuZXdTdGFydDogbmV3UmFuZ2VTdGFydCxcXG5cXHQgICAgICAgICAgICBuZXdMaW5lczogbmV3TGluZSAtIG5ld1JhbmdlU3RhcnQgKyBjb250ZXh0U2l6ZSxcXG5cXHQgICAgICAgICAgICBsaW5lczogY3VyUmFuZ2VcXG5cXHQgICAgICAgICAgfTtcXG5cXHQgICAgICAgICAgaWYgKGkgPj0gZGlmZi5sZW5ndGggLSAyICYmIGxpbmVzLmxlbmd0aCA8PSBvcHRpb25zLmNvbnRleHQpIHtcXG5cXHQgICAgICAgICAgICAvLyBFT0YgaXMgaW5zaWRlIHRoaXMgaHVua1xcblxcdCAgICAgICAgICAgIHZhciBvbGRFT0ZOZXdsaW5lID0gL1xcXFxuJC8udGVzdChvbGRTdHIpO1xcblxcdCAgICAgICAgICAgIHZhciBuZXdFT0ZOZXdsaW5lID0gL1xcXFxuJC8udGVzdChuZXdTdHIpO1xcblxcdCAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT0gMCAmJiAhb2xkRU9GTmV3bGluZSkge1xcblxcdCAgICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlOiBvbGQgaGFzIG5vIGVvbCBhbmQgbm8gdHJhaWxpbmcgY29udGV4dDsgbm8tbmwgY2FuIGVuZCB1cCBiZWZvcmUgYWRkc1xcblxcdCAgICAgICAgICAgICAgY3VyUmFuZ2Uuc3BsaWNlKGh1bmsub2xkTGluZXMsIDAsICdcXFxcXFxcXCBObyBuZXdsaW5lIGF0IGVuZCBvZiBmaWxlJyk7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIGlmICghb2xkRU9GTmV3bGluZSB8fCAhbmV3RU9GTmV3bGluZSkge1xcblxcdCAgICAgICAgICAgICAgY3VyUmFuZ2UucHVzaCgnXFxcXFxcXFwgTm8gbmV3bGluZSBhdCBlbmQgb2YgZmlsZScpO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgfVxcblxcdCAgICAgICAgICBodW5rcy5wdXNoKGh1bmspO1xcblxcblxcdCAgICAgICAgICBvbGRSYW5nZVN0YXJ0ID0gMDtcXG5cXHQgICAgICAgICAgbmV3UmFuZ2VTdGFydCA9IDA7XFxuXFx0ICAgICAgICAgIGN1clJhbmdlID0gW107XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgfVxcblxcdCAgICAgIG9sZExpbmUgKz0gbGluZXMubGVuZ3RoO1xcblxcdCAgICAgIG5ld0xpbmUgKz0gbGluZXMubGVuZ3RoO1xcblxcdCAgICB9XFxuXFx0ICB9O1xcblxcblxcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fbG9vcCggLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9pKTtcXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiB7XFxuXFx0ICAgIG9sZEZpbGVOYW1lOiBvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWU6IG5ld0ZpbGVOYW1lLFxcblxcdCAgICBvbGRIZWFkZXI6IG9sZEhlYWRlciwgbmV3SGVhZGVyOiBuZXdIZWFkZXIsXFxuXFx0ICAgIGh1bmtzOiBodW5rc1xcblxcdCAgfTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gY3JlYXRlVHdvRmlsZXNQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucykge1xcblxcdCAgdmFyIGRpZmYgPSBzdHJ1Y3R1cmVkUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpO1xcblxcblxcdCAgdmFyIHJldCA9IFtdO1xcblxcdCAgaWYgKG9sZEZpbGVOYW1lID09IG5ld0ZpbGVOYW1lKSB7XFxuXFx0ICAgIHJldC5wdXNoKCdJbmRleDogJyArIG9sZEZpbGVOYW1lKTtcXG5cXHQgIH1cXG5cXHQgIHJldC5wdXNoKCc9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Jyk7XFxuXFx0ICByZXQucHVzaCgnLS0tICcgKyBkaWZmLm9sZEZpbGVOYW1lICsgKHR5cGVvZiBkaWZmLm9sZEhlYWRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICdcXFxcdCcgKyBkaWZmLm9sZEhlYWRlcikpO1xcblxcdCAgcmV0LnB1c2goJysrKyAnICsgZGlmZi5uZXdGaWxlTmFtZSArICh0eXBlb2YgZGlmZi5uZXdIZWFkZXIgPT09ICd1bmRlZmluZWQnID8gJycgOiAnXFxcXHQnICsgZGlmZi5uZXdIZWFkZXIpKTtcXG5cXG5cXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZi5odW5rcy5sZW5ndGg7IGkrKykge1xcblxcdCAgICB2YXIgaHVuayA9IGRpZmYuaHVua3NbaV07XFxuXFx0ICAgIHJldC5wdXNoKCdAQCAtJyArIGh1bmsub2xkU3RhcnQgKyAnLCcgKyBodW5rLm9sZExpbmVzICsgJyArJyArIGh1bmsubmV3U3RhcnQgKyAnLCcgKyBodW5rLm5ld0xpbmVzICsgJyBAQCcpO1xcblxcdCAgICByZXQucHVzaC5hcHBseShyZXQsIGh1bmsubGluZXMpO1xcblxcdCAgfVxcblxcblxcdCAgcmV0dXJuIHJldC5qb2luKCdcXFxcbicpICsgJ1xcXFxuJztcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gY3JlYXRlUGF0Y2goZmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucykge1xcblxcdCAgcmV0dXJuIGNyZWF0ZVR3b0ZpbGVzUGF0Y2goZmlsZU5hbWUsIGZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpO1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAxNSAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9hcnJheUVxdWFsID0gYXJyYXlFcXVhbDtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9hcnJheVN0YXJ0c1dpdGggPSBhcnJheVN0YXJ0c1dpdGg7XFxuXFx0ZnVuY3Rpb24gYXJyYXlFcXVhbChhLCBiKSB7XFxuXFx0ICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XFxuXFx0ICAgIHJldHVybiBmYWxzZTtcXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiBhcnJheVN0YXJ0c1dpdGgoYSwgYik7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGFycmF5U3RhcnRzV2l0aChhcnJheSwgc3RhcnQpIHtcXG5cXHQgIGlmIChzdGFydC5sZW5ndGggPiBhcnJheS5sZW5ndGgpIHtcXG5cXHQgICAgcmV0dXJuIGZhbHNlO1xcblxcdCAgfVxcblxcblxcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFydC5sZW5ndGg7IGkrKykge1xcblxcdCAgICBpZiAoc3RhcnRbaV0gIT09IGFycmF5W2ldKSB7XFxuXFx0ICAgICAgcmV0dXJuIGZhbHNlO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICByZXR1cm4gdHJ1ZTtcXG5cXHR9XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMTYgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY29udmVydENoYW5nZXNUb0RNUCA9IGNvbnZlcnRDaGFuZ2VzVG9ETVA7XFxuXFx0Ly8gU2VlOiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZ29vZ2xlLWRpZmYtbWF0Y2gtcGF0Y2gvd2lraS9BUElcXG5cXHRmdW5jdGlvbiBjb252ZXJ0Q2hhbmdlc1RvRE1QKGNoYW5nZXMpIHtcXG5cXHQgIHZhciByZXQgPSBbXSxcXG5cXHQgICAgICBjaGFuZ2UgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdm9pZCAwIC8qaXN0YW5idWwgaWdub3JlIGVuZCovLFxcblxcdCAgICAgIG9wZXJhdGlvbiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92b2lkIDAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgY2hhbmdlID0gY2hhbmdlc1tpXTtcXG5cXHQgICAgaWYgKGNoYW5nZS5hZGRlZCkge1xcblxcdCAgICAgIG9wZXJhdGlvbiA9IDE7XFxuXFx0ICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcXG5cXHQgICAgICBvcGVyYXRpb24gPSAtMTtcXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICBvcGVyYXRpb24gPSAwO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIHJldC5wdXNoKFtvcGVyYXRpb24sIGNoYW5nZS52YWx1ZV0pO1xcblxcdCAgfVxcblxcdCAgcmV0dXJuIHJldDtcXG5cXHR9XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMTcgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY29udmVydENoYW5nZXNUb1hNTCA9IGNvbnZlcnRDaGFuZ2VzVG9YTUw7XFxuXFx0ZnVuY3Rpb24gY29udmVydENoYW5nZXNUb1hNTChjaGFuZ2VzKSB7XFxuXFx0ICB2YXIgcmV0ID0gW107XFxuXFx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbaV07XFxuXFx0ICAgIGlmIChjaGFuZ2UuYWRkZWQpIHtcXG5cXHQgICAgICByZXQucHVzaCgnPGlucz4nKTtcXG5cXHQgICAgfSBlbHNlIGlmIChjaGFuZ2UucmVtb3ZlZCkge1xcblxcdCAgICAgIHJldC5wdXNoKCc8ZGVsPicpO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIHJldC5wdXNoKGVzY2FwZUhUTUwoY2hhbmdlLnZhbHVlKSk7XFxuXFxuXFx0ICAgIGlmIChjaGFuZ2UuYWRkZWQpIHtcXG5cXHQgICAgICByZXQucHVzaCgnPC9pbnM+Jyk7XFxuXFx0ICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcXG5cXHQgICAgICByZXQucHVzaCgnPC9kZWw+Jyk7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHQgIHJldHVybiByZXQuam9pbignJyk7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGVzY2FwZUhUTUwocykge1xcblxcdCAgdmFyIG4gPSBzO1xcblxcdCAgbiA9IG4ucmVwbGFjZSgvJi9nLCAnJmFtcDsnKTtcXG5cXHQgIG4gPSBuLnJlcGxhY2UoLzwvZywgJyZsdDsnKTtcXG5cXHQgIG4gPSBuLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcXG5cXHQgIG4gPSBuLnJlcGxhY2UoL1xcXCIvZywgJyZxdW90OycpO1xcblxcblxcdCAgcmV0dXJuIG47XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pXFxuLyoqKioqKi8gXSlcXG59KTtcXG47XFxufSx7fV0sNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG52YXIgbWF0Y2hPcGVyYXRvcnNSZSA9IC9bfFxcXFxcXFxce30oKVtcXFxcXV4kKyo/Ll0vZztcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcXG5cXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcXG5cXHRcXHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gc3RyLnJlcGxhY2UobWF0Y2hPcGVyYXRvcnNSZSwgJ1xcXFxcXFxcJCYnKTtcXG59O1xcblxcbn0se31dLDQ3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcbi8vIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXFxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXFxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG5cXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XFxuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XFxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xcbn1cXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcXG5cXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XFxuXFxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXFxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xcblxcbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xcbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcXG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcXG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XFxuXFxuICBpZiAoIXRoaXMuX2V2ZW50cylcXG4gICAgdGhpcy5fZXZlbnRzID0ge307XFxuXFxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXFxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XFxuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XFxuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcXG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXFxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXFxcImVycm9yXFxcIiBldmVudC4gKCcgKyBlciArICcpJyk7XFxuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xcbiAgICAgICAgdGhyb3cgZXJyO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcXG5cXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcXG4gICAgcmV0dXJuIGZhbHNlO1xcblxcbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgICAgLy8gZmFzdCBjYXNlc1xcbiAgICAgIGNhc2UgMTpcXG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgMjpcXG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAzOlxcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIC8vIHNsb3dlclxcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcXG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XFxuICAgIH1cXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcXG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XFxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcXG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcXG4gIH1cXG5cXG4gIHJldHVybiB0cnVlO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XFxuICB2YXIgbTtcXG5cXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXFxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XFxuXFxuICBpZiAoIXRoaXMuX2V2ZW50cylcXG4gICAgdGhpcy5fZXZlbnRzID0ge307XFxuXFxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcXFwibmV3TGlzdGVuZXJcXFwiISBCZWZvcmVcXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFxcXCJuZXdMaXN0ZW5lclxcXCIuXFxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cXG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xcblxcbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXFxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxcbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcXG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXFxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xcbiAgZWxzZVxcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xcblxcbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XFxuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xcbiAgICB9XFxuXFxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XFxuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XFxuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXFxuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XFxuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XFxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xcblxcbiAgdmFyIGZpcmVkID0gZmFsc2U7XFxuXFxuICBmdW5jdGlvbiBnKCkge1xcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xcblxcbiAgICBpZiAoIWZpcmVkKSB7XFxuICAgICAgZmlyZWQgPSB0cnVlO1xcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcXG4gIHRoaXMub24odHlwZSwgZyk7XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XFxuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcXG5cXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXFxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XFxuXFxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxcbiAgICByZXR1cm4gdGhpcztcXG5cXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XFxuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcXG4gIHBvc2l0aW9uID0gLTE7XFxuXFxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcXG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcXG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xcblxcbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XFxuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xcbiAgICAgICAgcG9zaXRpb24gPSBpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChwb3NpdGlvbiA8IDApXFxuICAgICAgcmV0dXJuIHRoaXM7XFxuXFxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xcblxcbiAgaWYgKCF0aGlzLl9ldmVudHMpXFxuICAgIHJldHVybiB0aGlzO1xcblxcbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXFxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XFxuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG5cXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcXG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XFxuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XFxuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcXG4gICAgfVxcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcXG4gICAgdGhpcy5fZXZlbnRzID0ge307XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcblxcbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xcblxcbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XFxuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xcbiAgICAvLyBMSUZPIG9yZGVyXFxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XFxuICB9XFxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcXG4gIHZhciByZXQ7XFxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxcbiAgICByZXQgPSBbXTtcXG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XFxuICBlbHNlXFxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xcbiAgcmV0dXJuIHJldDtcXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcXG4gIGlmICh0aGlzLl9ldmVudHMpIHtcXG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XFxuXFxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxcbiAgICAgIHJldHVybiAxO1xcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcXG4gIH1cXG4gIHJldHVybiAwO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XFxuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xcbn07XFxuXFxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xcbn1cXG5cXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcXG59XFxuXFxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xcbn1cXG5cXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcXG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcXG59XFxuXFxufSx7fV0sNDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAoZ2xvYmFsKXtcXG4vKiEgaHR0cHM6Ly9tdGhzLmJlL2hlIHYxLjEuMSBieSBAbWF0aGlhcyB8IE1JVCBsaWNlbnNlICovXFxuOyhmdW5jdGlvbihyb290KSB7XFxuXFxuXFx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYC5cXG5cXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xcblxcblxcdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLlxcblxcdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XFxuXFxuXFx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcXG5cXHQvLyBhbmQgdXNlIGl0IGFzIGByb290YC5cXG5cXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xcblxcdGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkge1xcblxcdFxcdHJvb3QgPSBmcmVlR2xvYmFsO1xcblxcdH1cXG5cXG5cXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG5cXHQvLyBBbGwgYXN0cmFsIHN5bWJvbHMuXFxuXFx0dmFyIHJlZ2V4QXN0cmFsU3ltYm9scyA9IC9bXFxcXHVEODAwLVxcXFx1REJGRl1bXFxcXHVEQzAwLVxcXFx1REZGRl0vZztcXG5cXHQvLyBBbGwgQVNDSUkgc3ltYm9scyAobm90IGp1c3QgcHJpbnRhYmxlIEFTQ0lJKSBleGNlcHQgdGhvc2UgbGlzdGVkIGluIHRoZVxcblxcdC8vIGZpcnN0IGNvbHVtbiBvZiB0aGUgb3ZlcnJpZGVzIHRhYmxlLlxcblxcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3RhYmxlLWNoYXJyZWYtb3ZlcnJpZGVzXFxuXFx0dmFyIHJlZ2V4QXNjaWlXaGl0ZWxpc3QgPSAvW1xcXFx4MDEtXFxcXHg3Rl0vZztcXG5cXHQvLyBBbGwgQk1QIHN5bWJvbHMgdGhhdCBhcmUgbm90IEFTQ0lJIG5ld2xpbmVzLCBwcmludGFibGUgQVNDSUkgc3ltYm9scywgb3JcXG5cXHQvLyBjb2RlIHBvaW50cyBsaXN0ZWQgaW4gdGhlIGZpcnN0IGNvbHVtbiBvZiB0aGUgb3ZlcnJpZGVzIHRhYmxlIG9uXFxuXFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjdGFibGUtY2hhcnJlZi1vdmVycmlkZXMuXFxuXFx0dmFyIHJlZ2V4Qm1wV2hpdGVsaXN0ID0gL1tcXFxceDAxLVxcXFx0XFxcXHgwQlxcXFxmXFxcXHgwRS1cXFxceDFGXFxcXHg3RlxcXFx4ODFcXFxceDhEXFxcXHg4RlxcXFx4OTBcXFxceDlEXFxcXHhBMC1cXFxcdUZGRkZdL2c7XFxuXFxuXFx0dmFyIHJlZ2V4RW5jb2RlTm9uQXNjaWkgPSAvPFxcXFx1MjBEMnw9XFxcXHUyMEU1fD5cXFxcdTIwRDJ8XFxcXHUyMDVGXFxcXHUyMDBBfFxcXFx1MjE5RFxcXFx1MDMzOHxcXFxcdTIyMDJcXFxcdTAzMzh8XFxcXHUyMjIwXFxcXHUyMEQyfFxcXFx1MjIyOVxcXFx1RkUwMHxcXFxcdTIyMkFcXFxcdUZFMDB8XFxcXHUyMjNDXFxcXHUyMEQyfFxcXFx1MjIzRFxcXFx1MDMzMXxcXFxcdTIyM0VcXFxcdTAzMzN8XFxcXHUyMjQyXFxcXHUwMzM4fFxcXFx1MjI0QlxcXFx1MDMzOHxcXFxcdTIyNERcXFxcdTIwRDJ8XFxcXHUyMjRFXFxcXHUwMzM4fFxcXFx1MjI0RlxcXFx1MDMzOHxcXFxcdTIyNTBcXFxcdTAzMzh8XFxcXHUyMjYxXFxcXHUyMEU1fFxcXFx1MjI2NFxcXFx1MjBEMnxcXFxcdTIyNjVcXFxcdTIwRDJ8XFxcXHUyMjY2XFxcXHUwMzM4fFxcXFx1MjI2N1xcXFx1MDMzOHxcXFxcdTIyNjhcXFxcdUZFMDB8XFxcXHUyMjY5XFxcXHVGRTAwfFxcXFx1MjI2QVxcXFx1MDMzOHxcXFxcdTIyNkFcXFxcdTIwRDJ8XFxcXHUyMjZCXFxcXHUwMzM4fFxcXFx1MjI2QlxcXFx1MjBEMnxcXFxcdTIyN0ZcXFxcdTAzMzh8XFxcXHUyMjgyXFxcXHUyMEQyfFxcXFx1MjI4M1xcXFx1MjBEMnxcXFxcdTIyOEFcXFxcdUZFMDB8XFxcXHUyMjhCXFxcXHVGRTAwfFxcXFx1MjI4RlxcXFx1MDMzOHxcXFxcdTIyOTBcXFxcdTAzMzh8XFxcXHUyMjkzXFxcXHVGRTAwfFxcXFx1MjI5NFxcXFx1RkUwMHxcXFxcdTIyQjRcXFxcdTIwRDJ8XFxcXHUyMkI1XFxcXHUyMEQyfFxcXFx1MjJEOFxcXFx1MDMzOHxcXFxcdTIyRDlcXFxcdTAzMzh8XFxcXHUyMkRBXFxcXHVGRTAwfFxcXFx1MjJEQlxcXFx1RkUwMHxcXFxcdTIyRjVcXFxcdTAzMzh8XFxcXHUyMkY5XFxcXHUwMzM4fFxcXFx1MjkzM1xcXFx1MDMzOHxcXFxcdTI5Q0ZcXFxcdTAzMzh8XFxcXHUyOUQwXFxcXHUwMzM4fFxcXFx1MkE2RFxcXFx1MDMzOHxcXFxcdTJBNzBcXFxcdTAzMzh8XFxcXHUyQTdEXFxcXHUwMzM4fFxcXFx1MkE3RVxcXFx1MDMzOHxcXFxcdTJBQTFcXFxcdTAzMzh8XFxcXHUyQUEyXFxcXHUwMzM4fFxcXFx1MkFBQ1xcXFx1RkUwMHxcXFxcdTJBQURcXFxcdUZFMDB8XFxcXHUyQUFGXFxcXHUwMzM4fFxcXFx1MkFCMFxcXFx1MDMzOHxcXFxcdTJBQzVcXFxcdTAzMzh8XFxcXHUyQUM2XFxcXHUwMzM4fFxcXFx1MkFDQlxcXFx1RkUwMHxcXFxcdTJBQ0NcXFxcdUZFMDB8XFxcXHUyQUZEXFxcXHUyMEU1fFtcXFxceEEwLVxcXFx1MDExM1xcXFx1MDExNi1cXFxcdTAxMjJcXFxcdTAxMjQtXFxcXHUwMTJCXFxcXHUwMTJFLVxcXFx1MDE0RFxcXFx1MDE1MC1cXFxcdTAxN0VcXFxcdTAxOTJcXFxcdTAxQjVcXFxcdTAxRjVcXFxcdTAyMzdcXFxcdTAyQzZcXFxcdTAyQzdcXFxcdTAyRDgtXFxcXHUwMkREXFxcXHUwMzExXFxcXHUwMzkxLVxcXFx1MDNBMVxcXFx1MDNBMy1cXFxcdTAzQTlcXFxcdTAzQjEtXFxcXHUwM0M5XFxcXHUwM0QxXFxcXHUwM0QyXFxcXHUwM0Q1XFxcXHUwM0Q2XFxcXHUwM0RDXFxcXHUwM0REXFxcXHUwM0YwXFxcXHUwM0YxXFxcXHUwM0Y1XFxcXHUwM0Y2XFxcXHUwNDAxLVxcXFx1MDQwQ1xcXFx1MDQwRS1cXFxcdTA0NEZcXFxcdTA0NTEtXFxcXHUwNDVDXFxcXHUwNDVFXFxcXHUwNDVGXFxcXHUyMDAyLVxcXFx1MjAwNVxcXFx1MjAwNy1cXFxcdTIwMTBcXFxcdTIwMTMtXFxcXHUyMDE2XFxcXHUyMDE4LVxcXFx1MjAxQVxcXFx1MjAxQy1cXFxcdTIwMUVcXFxcdTIwMjAtXFxcXHUyMDIyXFxcXHUyMDI1XFxcXHUyMDI2XFxcXHUyMDMwLVxcXFx1MjAzNVxcXFx1MjAzOVxcXFx1MjAzQVxcXFx1MjAzRVxcXFx1MjA0MVxcXFx1MjA0M1xcXFx1MjA0NFxcXFx1MjA0RlxcXFx1MjA1N1xcXFx1MjA1Ri1cXFxcdTIwNjNcXFxcdTIwQUNcXFxcdTIwREJcXFxcdTIwRENcXFxcdTIxMDJcXFxcdTIxMDVcXFxcdTIxMEEtXFxcXHUyMTEzXFxcXHUyMTE1LVxcXFx1MjExRVxcXFx1MjEyMlxcXFx1MjEyNFxcXFx1MjEyNy1cXFxcdTIxMjlcXFxcdTIxMkNcXFxcdTIxMkRcXFxcdTIxMkYtXFxcXHUyMTMxXFxcXHUyMTMzLVxcXFx1MjEzOFxcXFx1MjE0NS1cXFxcdTIxNDhcXFxcdTIxNTMtXFxcXHUyMTVFXFxcXHUyMTkwLVxcXFx1MjE5QlxcXFx1MjE5RC1cXFxcdTIxQTdcXFxcdTIxQTktXFxcXHUyMUFFXFxcXHUyMUIwLVxcXFx1MjFCM1xcXFx1MjFCNS1cXFxcdTIxQjdcXFxcdTIxQkEtXFxcXHUyMURCXFxcXHUyMUREXFxcXHUyMUU0XFxcXHUyMUU1XFxcXHUyMUY1XFxcXHUyMUZELVxcXFx1MjIwNVxcXFx1MjIwNy1cXFxcdTIyMDlcXFxcdTIyMEJcXFxcdTIyMENcXFxcdTIyMEYtXFxcXHUyMjE0XFxcXHUyMjE2LVxcXFx1MjIxOFxcXFx1MjIxQVxcXFx1MjIxRC1cXFxcdTIyMzhcXFxcdTIyM0EtXFxcXHUyMjU3XFxcXHUyMjU5XFxcXHUyMjVBXFxcXHUyMjVDXFxcXHUyMjVGLVxcXFx1MjI2MlxcXFx1MjI2NC1cXFxcdTIyOEJcXFxcdTIyOEQtXFxcXHUyMjlCXFxcXHUyMjlELVxcXFx1MjJBNVxcXFx1MjJBNy1cXFxcdTIyQjBcXFxcdTIyQjItXFxcXHUyMkJCXFxcXHUyMkJELVxcXFx1MjJEQlxcXFx1MjJERS1cXFxcdTIyRTNcXFxcdTIyRTYtXFxcXHUyMkY3XFxcXHUyMkY5LVxcXFx1MjJGRVxcXFx1MjMwNVxcXFx1MjMwNlxcXFx1MjMwOC1cXFxcdTIzMTBcXFxcdTIzMTJcXFxcdTIzMTNcXFxcdTIzMTVcXFxcdTIzMTZcXFxcdTIzMUMtXFxcXHUyMzFGXFxcXHUyMzIyXFxcXHUyMzIzXFxcXHUyMzJEXFxcXHUyMzJFXFxcXHUyMzM2XFxcXHUyMzNEXFxcXHUyMzNGXFxcXHUyMzdDXFxcXHUyM0IwXFxcXHUyM0IxXFxcXHUyM0I0LVxcXFx1MjNCNlxcXFx1MjNEQy1cXFxcdTIzREZcXFxcdTIzRTJcXFxcdTIzRTdcXFxcdTI0MjNcXFxcdTI0QzhcXFxcdTI1MDBcXFxcdTI1MDJcXFxcdTI1MENcXFxcdTI1MTBcXFxcdTI1MTRcXFxcdTI1MThcXFxcdTI1MUNcXFxcdTI1MjRcXFxcdTI1MkNcXFxcdTI1MzRcXFxcdTI1M0NcXFxcdTI1NTAtXFxcXHUyNTZDXFxcXHUyNTgwXFxcXHUyNTg0XFxcXHUyNTg4XFxcXHUyNTkxLVxcXFx1MjU5M1xcXFx1MjVBMVxcXFx1MjVBQVxcXFx1MjVBQlxcXFx1MjVBRFxcXFx1MjVBRVxcXFx1MjVCMVxcXFx1MjVCMy1cXFxcdTI1QjVcXFxcdTI1QjhcXFxcdTI1QjlcXFxcdTI1QkQtXFxcXHUyNUJGXFxcXHUyNUMyXFxcXHUyNUMzXFxcXHUyNUNBXFxcXHUyNUNCXFxcXHUyNUVDXFxcXHUyNUVGXFxcXHUyNUY4LVxcXFx1MjVGQ1xcXFx1MjYwNVxcXFx1MjYwNlxcXFx1MjYwRVxcXFx1MjY0MFxcXFx1MjY0MlxcXFx1MjY2MFxcXFx1MjY2M1xcXFx1MjY2NVxcXFx1MjY2NlxcXFx1MjY2QVxcXFx1MjY2RC1cXFxcdTI2NkZcXFxcdTI3MTNcXFxcdTI3MTdcXFxcdTI3MjBcXFxcdTI3MzZcXFxcdTI3NThcXFxcdTI3NzJcXFxcdTI3NzNcXFxcdTI3QzhcXFxcdTI3QzlcXFxcdTI3RTYtXFxcXHUyN0VEXFxcXHUyN0Y1LVxcXFx1MjdGQVxcXFx1MjdGQ1xcXFx1MjdGRlxcXFx1MjkwMi1cXFxcdTI5MDVcXFxcdTI5MEMtXFxcXHUyOTEzXFxcXHUyOTE2XFxcXHUyOTE5LVxcXFx1MjkyMFxcXFx1MjkyMy1cXFxcdTI5MkFcXFxcdTI5MzNcXFxcdTI5MzUtXFxcXHUyOTM5XFxcXHUyOTNDXFxcXHUyOTNEXFxcXHUyOTQ1XFxcXHUyOTQ4LVxcXFx1Mjk0QlxcXFx1Mjk0RS1cXFxcdTI5NzZcXFxcdTI5NzhcXFxcdTI5NzlcXFxcdTI5N0ItXFxcXHUyOTdGXFxcXHUyOTg1XFxcXHUyOTg2XFxcXHUyOThCLVxcXFx1Mjk5NlxcXFx1Mjk5QVxcXFx1Mjk5Q1xcXFx1Mjk5RFxcXFx1MjlBNC1cXFxcdTI5QjdcXFxcdTI5QjlcXFxcdTI5QkJcXFxcdTI5QkNcXFxcdTI5QkUtXFxcXHUyOUM1XFxcXHUyOUM5XFxcXHUyOUNELVxcXFx1MjlEMFxcXFx1MjlEQy1cXFxcdTI5REVcXFxcdTI5RTMtXFxcXHUyOUU1XFxcXHUyOUVCXFxcXHUyOUY0XFxcXHUyOUY2XFxcXHUyQTAwLVxcXFx1MkEwMlxcXFx1MkEwNFxcXFx1MkEwNlxcXFx1MkEwQ1xcXFx1MkEwRFxcXFx1MkExMC1cXFxcdTJBMTdcXFxcdTJBMjItXFxcXHUyQTI3XFxcXHUyQTI5XFxcXHUyQTJBXFxcXHUyQTJELVxcXFx1MkEzMVxcXFx1MkEzMy1cXFxcdTJBM0NcXFxcdTJBM0ZcXFxcdTJBNDBcXFxcdTJBNDItXFxcXHUyQTREXFxcXHUyQTUwXFxcXHUyQTUzLVxcXFx1MkE1OFxcXFx1MkE1QS1cXFxcdTJBNURcXFxcdTJBNUZcXFxcdTJBNjZcXFxcdTJBNkFcXFxcdTJBNkQtXFxcXHUyQTc1XFxcXHUyQTc3LVxcXFx1MkE5QVxcXFx1MkE5RC1cXFxcdTJBQTJcXFxcdTJBQTQtXFxcXHUyQUIwXFxcXHUyQUIzLVxcXFx1MkFDOFxcXFx1MkFDQlxcXFx1MkFDQ1xcXFx1MkFDRi1cXFxcdTJBREJcXFxcdTJBRTRcXFxcdTJBRTYtXFxcXHUyQUU5XFxcXHUyQUVCLVxcXFx1MkFGM1xcXFx1MkFGRFxcXFx1RkIwMC1cXFxcdUZCMDRdfFxcXFx1RDgzNVtcXFxcdURDOUNcXFxcdURDOUVcXFxcdURDOUZcXFxcdURDQTJcXFxcdURDQTVcXFxcdURDQTZcXFxcdURDQTktXFxcXHVEQ0FDXFxcXHVEQ0FFLVxcXFx1RENCOVxcXFx1RENCQlxcXFx1RENCRC1cXFxcdURDQzNcXFxcdURDQzUtXFxcXHVEQ0NGXFxcXHVERDA0XFxcXHVERDA1XFxcXHVERDA3LVxcXFx1REQwQVxcXFx1REQwRC1cXFxcdUREMTRcXFxcdUREMTYtXFxcXHVERDFDXFxcXHVERDFFLVxcXFx1REQzOVxcXFx1REQzQi1cXFxcdUREM0VcXFxcdURENDAtXFxcXHVERDQ0XFxcXHVERDQ2XFxcXHVERDRBLVxcXFx1REQ1MFxcXFx1REQ1Mi1cXFxcdURENkJdL2c7XFxuXFx0dmFyIGVuY29kZU1hcCA9IHsnXFxcXHhBRCc6J3NoeScsJ1xcXFx1MjAwQyc6J3p3bmonLCdcXFxcdTIwMEQnOid6d2onLCdcXFxcdTIwMEUnOidscm0nLCdcXFxcdTIwNjMnOidpYycsJ1xcXFx1MjA2Mic6J2l0JywnXFxcXHUyMDYxJzonYWYnLCdcXFxcdTIwMEYnOidybG0nLCdcXFxcdTIwMEInOidaZXJvV2lkdGhTcGFjZScsJ1xcXFx1MjA2MCc6J05vQnJlYWsnLCdcXFxcdTAzMTEnOidEb3duQnJldmUnLCdcXFxcdTIwREInOid0ZG90JywnXFxcXHUyMERDJzonRG90RG90JywnXFxcXHQnOidUYWInLCdcXFxcbic6J05ld0xpbmUnLCdcXFxcdTIwMDgnOidwdW5jc3AnLCdcXFxcdTIwNUYnOidNZWRpdW1TcGFjZScsJ1xcXFx1MjAwOSc6J3RoaW5zcCcsJ1xcXFx1MjAwQSc6J2hhaXJzcCcsJ1xcXFx1MjAwNCc6J2Vtc3AxMycsJ1xcXFx1MjAwMic6J2Vuc3AnLCdcXFxcdTIwMDUnOidlbXNwMTQnLCdcXFxcdTIwMDMnOidlbXNwJywnXFxcXHUyMDA3JzonbnVtc3AnLCdcXFxceEEwJzonbmJzcCcsJ1xcXFx1MjA1RlxcXFx1MjAwQSc6J1RoaWNrU3BhY2UnLCdcXFxcdTIwM0UnOidvbGluZScsJ18nOidsb3diYXInLCdcXFxcdTIwMTAnOidkYXNoJywnXFxcXHUyMDEzJzonbmRhc2gnLCdcXFxcdTIwMTQnOidtZGFzaCcsJ1xcXFx1MjAxNSc6J2hvcmJhcicsJywnOidjb21tYScsJzsnOidzZW1pJywnXFxcXHUyMDRGJzonYnNlbWknLCc6JzonY29sb24nLCdcXFxcdTJBNzQnOidDb2xvbmUnLCchJzonZXhjbCcsJ1xcXFx4QTEnOidpZXhjbCcsJz8nOidxdWVzdCcsJ1xcXFx4QkYnOidpcXVlc3QnLCcuJzoncGVyaW9kJywnXFxcXHUyMDI1JzonbmxkcicsJ1xcXFx1MjAyNic6J21sZHInLCdcXFxceEI3JzonbWlkZG90JywnXFxcXCcnOidhcG9zJywnXFxcXHUyMDE4JzonbHNxdW8nLCdcXFxcdTIwMTknOidyc3F1bycsJ1xcXFx1MjAxQSc6J3NicXVvJywnXFxcXHUyMDM5JzonbHNhcXVvJywnXFxcXHUyMDNBJzoncnNhcXVvJywnXFxcIic6J3F1b3QnLCdcXFxcdTIwMUMnOidsZHF1bycsJ1xcXFx1MjAxRCc6J3JkcXVvJywnXFxcXHUyMDFFJzonYmRxdW8nLCdcXFxceEFCJzonbGFxdW8nLCdcXFxceEJCJzoncmFxdW8nLCcoJzonbHBhcicsJyknOidycGFyJywnWyc6J2xzcWInLCddJzoncnNxYicsJ3snOidsY3ViJywnfSc6J3JjdWInLCdcXFxcdTIzMDgnOidsY2VpbCcsJ1xcXFx1MjMwOSc6J3JjZWlsJywnXFxcXHUyMzBBJzonbGZsb29yJywnXFxcXHUyMzBCJzoncmZsb29yJywnXFxcXHUyOTg1JzonbG9wYXInLCdcXFxcdTI5ODYnOidyb3BhcicsJ1xcXFx1Mjk4Qic6J2xicmtlJywnXFxcXHUyOThDJzoncmJya2UnLCdcXFxcdTI5OEQnOidsYnJrc2x1JywnXFxcXHUyOThFJzoncmJya3NsZCcsJ1xcXFx1Mjk4Ric6J2xicmtzbGQnLCdcXFxcdTI5OTAnOidyYnJrc2x1JywnXFxcXHUyOTkxJzonbGFuZ2QnLCdcXFxcdTI5OTInOidyYW5nZCcsJ1xcXFx1Mjk5Myc6J2xwYXJsdCcsJ1xcXFx1Mjk5NCc6J3JwYXJndCcsJ1xcXFx1Mjk5NSc6J2d0bFBhcicsJ1xcXFx1Mjk5Nic6J2x0clBhcicsJ1xcXFx1MjdFNic6J2xvYnJrJywnXFxcXHUyN0U3Jzoncm9icmsnLCdcXFxcdTI3RTgnOidsYW5nJywnXFxcXHUyN0U5JzoncmFuZycsJ1xcXFx1MjdFQSc6J0xhbmcnLCdcXFxcdTI3RUInOidSYW5nJywnXFxcXHUyN0VDJzonbG9hbmcnLCdcXFxcdTI3RUQnOidyb2FuZycsJ1xcXFx1Mjc3Mic6J2xiYnJrJywnXFxcXHUyNzczJzoncmJicmsnLCdcXFxcdTIwMTYnOidWZXJ0JywnXFxcXHhBNyc6J3NlY3QnLCdcXFxceEI2JzoncGFyYScsJ0AnOidjb21tYXQnLCcqJzonYXN0JywnLyc6J3NvbCcsJ3VuZGVmaW5lZCc6bnVsbCwnJic6J2FtcCcsJyMnOidudW0nLCclJzoncGVyY250JywnXFxcXHUyMDMwJzoncGVybWlsJywnXFxcXHUyMDMxJzoncGVydGVuaycsJ1xcXFx1MjAyMCc6J2RhZ2dlcicsJ1xcXFx1MjAyMSc6J0RhZ2dlcicsJ1xcXFx1MjAyMic6J2J1bGwnLCdcXFxcdTIwNDMnOidoeWJ1bGwnLCdcXFxcdTIwMzInOidwcmltZScsJ1xcXFx1MjAzMyc6J1ByaW1lJywnXFxcXHUyMDM0JzondHByaW1lJywnXFxcXHUyMDU3JzoncXByaW1lJywnXFxcXHUyMDM1JzonYnByaW1lJywnXFxcXHUyMDQxJzonY2FyZXQnLCdgJzonZ3JhdmUnLCdcXFxceEI0JzonYWN1dGUnLCdcXFxcdTAyREMnOid0aWxkZScsJ14nOidIYXQnLCdcXFxceEFGJzonbWFjcicsJ1xcXFx1MDJEOCc6J2JyZXZlJywnXFxcXHUwMkQ5JzonZG90JywnXFxcXHhBOCc6J2RpZScsJ1xcXFx1MDJEQSc6J3JpbmcnLCdcXFxcdTAyREQnOidkYmxhYycsJ1xcXFx4QjgnOidjZWRpbCcsJ1xcXFx1MDJEQic6J29nb24nLCdcXFxcdTAyQzYnOidjaXJjJywnXFxcXHUwMkM3JzonY2Fyb24nLCdcXFxceEIwJzonZGVnJywnXFxcXHhBOSc6J2NvcHknLCdcXFxceEFFJzoncmVnJywnXFxcXHUyMTE3JzonY29weXNyJywnXFxcXHUyMTE4Jzond3AnLCdcXFxcdTIxMUUnOidyeCcsJ1xcXFx1MjEyNyc6J21obycsJ1xcXFx1MjEyOSc6J2lpb3RhJywnXFxcXHUyMTkwJzonbGFycicsJ1xcXFx1MjE5QSc6J25sYXJyJywnXFxcXHUyMTkyJzoncmFycicsJ1xcXFx1MjE5Qic6J25yYXJyJywnXFxcXHUyMTkxJzondWFycicsJ1xcXFx1MjE5Myc6J2RhcnInLCdcXFxcdTIxOTQnOidoYXJyJywnXFxcXHUyMUFFJzonbmhhcnInLCdcXFxcdTIxOTUnOid2YXJyJywnXFxcXHUyMTk2JzonbndhcnInLCdcXFxcdTIxOTcnOiduZWFycicsJ1xcXFx1MjE5OCc6J3NlYXJyJywnXFxcXHUyMTk5Jzonc3dhcnInLCdcXFxcdTIxOUQnOidyYXJydycsJ1xcXFx1MjE5RFxcXFx1MDMzOCc6J25yYXJydycsJ1xcXFx1MjE5RSc6J0xhcnInLCdcXFxcdTIxOUYnOidVYXJyJywnXFxcXHUyMUEwJzonUmFycicsJ1xcXFx1MjFBMSc6J0RhcnInLCdcXFxcdTIxQTInOidsYXJydGwnLCdcXFxcdTIxQTMnOidyYXJydGwnLCdcXFxcdTIxQTQnOidtYXBzdG9sZWZ0JywnXFxcXHUyMUE1JzonbWFwc3RvdXAnLCdcXFxcdTIxQTYnOidtYXAnLCdcXFxcdTIxQTcnOidtYXBzdG9kb3duJywnXFxcXHUyMUE5JzonbGFycmhrJywnXFxcXHUyMUFBJzoncmFycmhrJywnXFxcXHUyMUFCJzonbGFycmxwJywnXFxcXHUyMUFDJzoncmFycmxwJywnXFxcXHUyMUFEJzonaGFycncnLCdcXFxcdTIxQjAnOidsc2gnLCdcXFxcdTIxQjEnOidyc2gnLCdcXFxcdTIxQjInOidsZHNoJywnXFxcXHUyMUIzJzoncmRzaCcsJ1xcXFx1MjFCNSc6J2NyYXJyJywnXFxcXHUyMUI2JzonY3VsYXJyJywnXFxcXHUyMUI3JzonY3VyYXJyJywnXFxcXHUyMUJBJzonb2xhcnInLCdcXFxcdTIxQkInOidvcmFycicsJ1xcXFx1MjFCQyc6J2xoYXJ1JywnXFxcXHUyMUJEJzonbGhhcmQnLCdcXFxcdTIxQkUnOid1aGFycicsJ1xcXFx1MjFCRic6J3VoYXJsJywnXFxcXHUyMUMwJzoncmhhcnUnLCdcXFxcdTIxQzEnOidyaGFyZCcsJ1xcXFx1MjFDMic6J2RoYXJyJywnXFxcXHUyMUMzJzonZGhhcmwnLCdcXFxcdTIxQzQnOidybGFycicsJ1xcXFx1MjFDNSc6J3VkYXJyJywnXFxcXHUyMUM2JzonbHJhcnInLCdcXFxcdTIxQzcnOidsbGFycicsJ1xcXFx1MjFDOCc6J3V1YXJyJywnXFxcXHUyMUM5JzoncnJhcnInLCdcXFxcdTIxQ0EnOidkZGFycicsJ1xcXFx1MjFDQic6J2xyaGFyJywnXFxcXHUyMUNDJzoncmxoYXInLCdcXFxcdTIxRDAnOidsQXJyJywnXFxcXHUyMUNEJzonbmxBcnInLCdcXFxcdTIxRDEnOid1QXJyJywnXFxcXHUyMUQyJzonckFycicsJ1xcXFx1MjFDRic6J25yQXJyJywnXFxcXHUyMUQzJzonZEFycicsJ1xcXFx1MjFENCc6J2lmZicsJ1xcXFx1MjFDRSc6J25oQXJyJywnXFxcXHUyMUQ1JzondkFycicsJ1xcXFx1MjFENic6J253QXJyJywnXFxcXHUyMUQ3JzonbmVBcnInLCdcXFxcdTIxRDgnOidzZUFycicsJ1xcXFx1MjFEOSc6J3N3QXJyJywnXFxcXHUyMURBJzonbEFhcnInLCdcXFxcdTIxREInOidyQWFycicsJ1xcXFx1MjFERCc6J3ppZ3JhcnInLCdcXFxcdTIxRTQnOidsYXJyYicsJ1xcXFx1MjFFNSc6J3JhcnJiJywnXFxcXHUyMUY1JzonZHVhcnInLCdcXFxcdTIxRkQnOidsb2FycicsJ1xcXFx1MjFGRSc6J3JvYXJyJywnXFxcXHUyMUZGJzonaG9hcnInLCdcXFxcdTIyMDAnOidmb3JhbGwnLCdcXFxcdTIyMDEnOidjb21wJywnXFxcXHUyMjAyJzoncGFydCcsJ1xcXFx1MjIwMlxcXFx1MDMzOCc6J25wYXJ0JywnXFxcXHUyMjAzJzonZXhpc3QnLCdcXFxcdTIyMDQnOiduZXhpc3QnLCdcXFxcdTIyMDUnOidlbXB0eScsJ1xcXFx1MjIwNyc6J0RlbCcsJ1xcXFx1MjIwOCc6J2luJywnXFxcXHUyMjA5Jzonbm90aW4nLCdcXFxcdTIyMEInOiduaScsJ1xcXFx1MjIwQyc6J25vdG5pJywnXFxcXHUwM0Y2JzonYmVwc2knLCdcXFxcdTIyMEYnOidwcm9kJywnXFxcXHUyMjEwJzonY29wcm9kJywnXFxcXHUyMjExJzonc3VtJywnKyc6J3BsdXMnLCdcXFxceEIxJzoncG0nLCdcXFxceEY3JzonZGl2JywnXFxcXHhENyc6J3RpbWVzJywnPCc6J2x0JywnXFxcXHUyMjZFJzonbmx0JywnPFxcXFx1MjBEMic6J252bHQnLCc9JzonZXF1YWxzJywnXFxcXHUyMjYwJzonbmUnLCc9XFxcXHUyMEU1JzonYm5lJywnXFxcXHUyQTc1JzonRXF1YWwnLCc+JzonZ3QnLCdcXFxcdTIyNkYnOiduZ3QnLCc+XFxcXHUyMEQyJzonbnZndCcsJ1xcXFx4QUMnOidub3QnLCd8JzondmVydCcsJ1xcXFx4QTYnOidicnZiYXInLCdcXFxcdTIyMTInOidtaW51cycsJ1xcXFx1MjIxMyc6J21wJywnXFxcXHUyMjE0JzoncGx1c2RvJywnXFxcXHUyMDQ0JzonZnJhc2wnLCdcXFxcdTIyMTYnOidzZXRtbicsJ1xcXFx1MjIxNyc6J2xvd2FzdCcsJ1xcXFx1MjIxOCc6J2NvbXBmbicsJ1xcXFx1MjIxQSc6J1NxcnQnLCdcXFxcdTIyMUQnOidwcm9wJywnXFxcXHUyMjFFJzonaW5maW4nLCdcXFxcdTIyMUYnOidhbmdydCcsJ1xcXFx1MjIyMCc6J2FuZycsJ1xcXFx1MjIyMFxcXFx1MjBEMic6J25hbmcnLCdcXFxcdTIyMjEnOidhbmdtc2QnLCdcXFxcdTIyMjInOidhbmdzcGgnLCdcXFxcdTIyMjMnOidtaWQnLCdcXFxcdTIyMjQnOidubWlkJywnXFxcXHUyMjI1JzoncGFyJywnXFxcXHUyMjI2JzonbnBhcicsJ1xcXFx1MjIyNyc6J2FuZCcsJ1xcXFx1MjIyOCc6J29yJywnXFxcXHUyMjI5JzonY2FwJywnXFxcXHUyMjI5XFxcXHVGRTAwJzonY2FwcycsJ1xcXFx1MjIyQSc6J2N1cCcsJ1xcXFx1MjIyQVxcXFx1RkUwMCc6J2N1cHMnLCdcXFxcdTIyMkInOidpbnQnLCdcXFxcdTIyMkMnOidJbnQnLCdcXFxcdTIyMkQnOid0aW50JywnXFxcXHUyQTBDJzoncWludCcsJ1xcXFx1MjIyRSc6J29pbnQnLCdcXFxcdTIyMkYnOidDb25pbnQnLCdcXFxcdTIyMzAnOidDY29uaW50JywnXFxcXHUyMjMxJzonY3dpbnQnLCdcXFxcdTIyMzInOidjd2NvbmludCcsJ1xcXFx1MjIzMyc6J2F3Y29uaW50JywnXFxcXHUyMjM0JzondGhlcmU0JywnXFxcXHUyMjM1JzonYmVjYXVzJywnXFxcXHUyMjM2JzoncmF0aW8nLCdcXFxcdTIyMzcnOidDb2xvbicsJ1xcXFx1MjIzOCc6J21pbnVzZCcsJ1xcXFx1MjIzQSc6J21ERG90JywnXFxcXHUyMjNCJzonaG9tdGh0JywnXFxcXHUyMjNDJzonc2ltJywnXFxcXHUyMjQxJzonbnNpbScsJ1xcXFx1MjIzQ1xcXFx1MjBEMic6J252c2ltJywnXFxcXHUyMjNEJzonYnNpbScsJ1xcXFx1MjIzRFxcXFx1MDMzMSc6J3JhY2UnLCdcXFxcdTIyM0UnOidhYycsJ1xcXFx1MjIzRVxcXFx1MDMzMyc6J2FjRScsJ1xcXFx1MjIzRic6J2FjZCcsJ1xcXFx1MjI0MCc6J3dyJywnXFxcXHUyMjQyJzonZXNpbScsJ1xcXFx1MjI0MlxcXFx1MDMzOCc6J25lc2ltJywnXFxcXHUyMjQzJzonc2ltZScsJ1xcXFx1MjI0NCc6J25zaW1lJywnXFxcXHUyMjQ1JzonY29uZycsJ1xcXFx1MjI0Nyc6J25jb25nJywnXFxcXHUyMjQ2Jzonc2ltbmUnLCdcXFxcdTIyNDgnOidhcCcsJ1xcXFx1MjI0OSc6J25hcCcsJ1xcXFx1MjI0QSc6J2FwZScsJ1xcXFx1MjI0Qic6J2FwaWQnLCdcXFxcdTIyNEJcXFxcdTAzMzgnOiduYXBpZCcsJ1xcXFx1MjI0Qyc6J2Jjb25nJywnXFxcXHUyMjREJzonQ3VwQ2FwJywnXFxcXHUyMjZEJzonTm90Q3VwQ2FwJywnXFxcXHUyMjREXFxcXHUyMEQyJzonbnZhcCcsJ1xcXFx1MjI0RSc6J2J1bXAnLCdcXFxcdTIyNEVcXFxcdTAzMzgnOiduYnVtcCcsJ1xcXFx1MjI0Ric6J2J1bXBlJywnXFxcXHUyMjRGXFxcXHUwMzM4JzonbmJ1bXBlJywnXFxcXHUyMjUwJzonZG90ZXEnLCdcXFxcdTIyNTBcXFxcdTAzMzgnOiduZWRvdCcsJ1xcXFx1MjI1MSc6J2VEb3QnLCdcXFxcdTIyNTInOidlZkRvdCcsJ1xcXFx1MjI1Myc6J2VyRG90JywnXFxcXHUyMjU0JzonY29sb25lJywnXFxcXHUyMjU1JzonZWNvbG9uJywnXFxcXHUyMjU2JzonZWNpcicsJ1xcXFx1MjI1Nyc6J2NpcmUnLCdcXFxcdTIyNTknOid3ZWRnZXEnLCdcXFxcdTIyNUEnOid2ZWVlcScsJ1xcXFx1MjI1Qyc6J3RyaWUnLCdcXFxcdTIyNUYnOidlcXVlc3QnLCdcXFxcdTIyNjEnOidlcXVpdicsJ1xcXFx1MjI2Mic6J25lcXVpdicsJ1xcXFx1MjI2MVxcXFx1MjBFNSc6J2JuZXF1aXYnLCdcXFxcdTIyNjQnOidsZScsJ1xcXFx1MjI3MCc6J25sZScsJ1xcXFx1MjI2NFxcXFx1MjBEMic6J252bGUnLCdcXFxcdTIyNjUnOidnZScsJ1xcXFx1MjI3MSc6J25nZScsJ1xcXFx1MjI2NVxcXFx1MjBEMic6J252Z2UnLCdcXFxcdTIyNjYnOidsRScsJ1xcXFx1MjI2NlxcXFx1MDMzOCc6J25sRScsJ1xcXFx1MjI2Nyc6J2dFJywnXFxcXHUyMjY3XFxcXHUwMzM4JzonbmdFJywnXFxcXHUyMjY4XFxcXHVGRTAwJzonbHZuRScsJ1xcXFx1MjI2OCc6J2xuRScsJ1xcXFx1MjI2OSc6J2duRScsJ1xcXFx1MjI2OVxcXFx1RkUwMCc6J2d2bkUnLCdcXFxcdTIyNkEnOidsbCcsJ1xcXFx1MjI2QVxcXFx1MDMzOCc6J25MdHYnLCdcXFxcdTIyNkFcXFxcdTIwRDInOiduTHQnLCdcXFxcdTIyNkInOidnZycsJ1xcXFx1MjI2QlxcXFx1MDMzOCc6J25HdHYnLCdcXFxcdTIyNkJcXFxcdTIwRDInOiduR3QnLCdcXFxcdTIyNkMnOid0d2l4dCcsJ1xcXFx1MjI3Mic6J2xzaW0nLCdcXFxcdTIyNzQnOidubHNpbScsJ1xcXFx1MjI3Myc6J2dzaW0nLCdcXFxcdTIyNzUnOiduZ3NpbScsJ1xcXFx1MjI3Nic6J2xnJywnXFxcXHUyMjc4JzonbnRsZycsJ1xcXFx1MjI3Nyc6J2dsJywnXFxcXHUyMjc5JzonbnRnbCcsJ1xcXFx1MjI3QSc6J3ByJywnXFxcXHUyMjgwJzonbnByJywnXFxcXHUyMjdCJzonc2MnLCdcXFxcdTIyODEnOiduc2MnLCdcXFxcdTIyN0MnOidwcmN1ZScsJ1xcXFx1MjJFMCc6J25wcmN1ZScsJ1xcXFx1MjI3RCc6J3NjY3VlJywnXFxcXHUyMkUxJzonbnNjY3VlJywnXFxcXHUyMjdFJzoncHJzaW0nLCdcXFxcdTIyN0YnOidzY3NpbScsJ1xcXFx1MjI3RlxcXFx1MDMzOCc6J05vdFN1Y2NlZWRzVGlsZGUnLCdcXFxcdTIyODInOidzdWInLCdcXFxcdTIyODQnOiduc3ViJywnXFxcXHUyMjgyXFxcXHUyMEQyJzondm5zdWInLCdcXFxcdTIyODMnOidzdXAnLCdcXFxcdTIyODUnOiduc3VwJywnXFxcXHUyMjgzXFxcXHUyMEQyJzondm5zdXAnLCdcXFxcdTIyODYnOidzdWJlJywnXFxcXHUyMjg4JzonbnN1YmUnLCdcXFxcdTIyODcnOidzdXBlJywnXFxcXHUyMjg5JzonbnN1cGUnLCdcXFxcdTIyOEFcXFxcdUZFMDAnOid2c3VibmUnLCdcXFxcdTIyOEEnOidzdWJuZScsJ1xcXFx1MjI4QlxcXFx1RkUwMCc6J3ZzdXBuZScsJ1xcXFx1MjI4Qic6J3N1cG5lJywnXFxcXHUyMjhEJzonY3VwZG90JywnXFxcXHUyMjhFJzondXBsdXMnLCdcXFxcdTIyOEYnOidzcXN1YicsJ1xcXFx1MjI4RlxcXFx1MDMzOCc6J05vdFNxdWFyZVN1YnNldCcsJ1xcXFx1MjI5MCc6J3Nxc3VwJywnXFxcXHUyMjkwXFxcXHUwMzM4JzonTm90U3F1YXJlU3VwZXJzZXQnLCdcXFxcdTIyOTEnOidzcXN1YmUnLCdcXFxcdTIyRTInOiduc3FzdWJlJywnXFxcXHUyMjkyJzonc3FzdXBlJywnXFxcXHUyMkUzJzonbnNxc3VwZScsJ1xcXFx1MjI5Myc6J3NxY2FwJywnXFxcXHUyMjkzXFxcXHVGRTAwJzonc3FjYXBzJywnXFxcXHUyMjk0Jzonc3FjdXAnLCdcXFxcdTIyOTRcXFxcdUZFMDAnOidzcWN1cHMnLCdcXFxcdTIyOTUnOidvcGx1cycsJ1xcXFx1MjI5Nic6J29taW51cycsJ1xcXFx1MjI5Nyc6J290aW1lcycsJ1xcXFx1MjI5OCc6J29zb2wnLCdcXFxcdTIyOTknOidvZG90JywnXFxcXHUyMjlBJzonb2NpcicsJ1xcXFx1MjI5Qic6J29hc3QnLCdcXFxcdTIyOUQnOidvZGFzaCcsJ1xcXFx1MjI5RSc6J3BsdXNiJywnXFxcXHUyMjlGJzonbWludXNiJywnXFxcXHUyMkEwJzondGltZXNiJywnXFxcXHUyMkExJzonc2RvdGInLCdcXFxcdTIyQTInOid2ZGFzaCcsJ1xcXFx1MjJBQyc6J252ZGFzaCcsJ1xcXFx1MjJBMyc6J2Rhc2h2JywnXFxcXHUyMkE0JzondG9wJywnXFxcXHUyMkE1JzonYm90JywnXFxcXHUyMkE3JzonbW9kZWxzJywnXFxcXHUyMkE4JzondkRhc2gnLCdcXFxcdTIyQUQnOidudkRhc2gnLCdcXFxcdTIyQTknOidWZGFzaCcsJ1xcXFx1MjJBRSc6J25WZGFzaCcsJ1xcXFx1MjJBQSc6J1Z2ZGFzaCcsJ1xcXFx1MjJBQic6J1ZEYXNoJywnXFxcXHUyMkFGJzonblZEYXNoJywnXFxcXHUyMkIwJzoncHJ1cmVsJywnXFxcXHUyMkIyJzondmx0cmknLCdcXFxcdTIyRUEnOidubHRyaScsJ1xcXFx1MjJCMyc6J3ZydHJpJywnXFxcXHUyMkVCJzonbnJ0cmknLCdcXFxcdTIyQjQnOidsdHJpZScsJ1xcXFx1MjJFQyc6J25sdHJpZScsJ1xcXFx1MjJCNFxcXFx1MjBEMic6J252bHRyaWUnLCdcXFxcdTIyQjUnOidydHJpZScsJ1xcXFx1MjJFRCc6J25ydHJpZScsJ1xcXFx1MjJCNVxcXFx1MjBEMic6J252cnRyaWUnLCdcXFxcdTIyQjYnOidvcmlnb2YnLCdcXFxcdTIyQjcnOidpbW9mJywnXFxcXHUyMkI4JzonbXVtYXAnLCdcXFxcdTIyQjknOidoZXJjb24nLCdcXFxcdTIyQkEnOidpbnRjYWwnLCdcXFxcdTIyQkInOid2ZWViYXInLCdcXFxcdTIyQkQnOidiYXJ2ZWUnLCdcXFxcdTIyQkUnOidhbmdydHZiJywnXFxcXHUyMkJGJzonbHJ0cmknLCdcXFxcdTIyQzAnOidXZWRnZScsJ1xcXFx1MjJDMSc6J1ZlZScsJ1xcXFx1MjJDMic6J3hjYXAnLCdcXFxcdTIyQzMnOid4Y3VwJywnXFxcXHUyMkM0JzonZGlhbScsJ1xcXFx1MjJDNSc6J3Nkb3QnLCdcXFxcdTIyQzYnOidTdGFyJywnXFxcXHUyMkM3JzonZGl2b254JywnXFxcXHUyMkM4JzonYm93dGllJywnXFxcXHUyMkM5JzonbHRpbWVzJywnXFxcXHUyMkNBJzoncnRpbWVzJywnXFxcXHUyMkNCJzonbHRocmVlJywnXFxcXHUyMkNDJzoncnRocmVlJywnXFxcXHUyMkNEJzonYnNpbWUnLCdcXFxcdTIyQ0UnOidjdXZlZScsJ1xcXFx1MjJDRic6J2N1d2VkJywnXFxcXHUyMkQwJzonU3ViJywnXFxcXHUyMkQxJzonU3VwJywnXFxcXHUyMkQyJzonQ2FwJywnXFxcXHUyMkQzJzonQ3VwJywnXFxcXHUyMkQ0JzonZm9yaycsJ1xcXFx1MjJENSc6J2VwYXInLCdcXFxcdTIyRDYnOidsdGRvdCcsJ1xcXFx1MjJENyc6J2d0ZG90JywnXFxcXHUyMkQ4JzonTGwnLCdcXFxcdTIyRDhcXFxcdTAzMzgnOiduTGwnLCdcXFxcdTIyRDknOidHZycsJ1xcXFx1MjJEOVxcXFx1MDMzOCc6J25HZycsJ1xcXFx1MjJEQVxcXFx1RkUwMCc6J2xlc2cnLCdcXFxcdTIyREEnOidsZWcnLCdcXFxcdTIyREInOidnZWwnLCdcXFxcdTIyREJcXFxcdUZFMDAnOidnZXNsJywnXFxcXHUyMkRFJzonY3VlcHInLCdcXFxcdTIyREYnOidjdWVzYycsJ1xcXFx1MjJFNic6J2xuc2ltJywnXFxcXHUyMkU3JzonZ25zaW0nLCdcXFxcdTIyRTgnOidwcm5zaW0nLCdcXFxcdTIyRTknOidzY25zaW0nLCdcXFxcdTIyRUUnOid2ZWxsaXAnLCdcXFxcdTIyRUYnOidjdGRvdCcsJ1xcXFx1MjJGMCc6J3V0ZG90JywnXFxcXHUyMkYxJzonZHRkb3QnLCdcXFxcdTIyRjInOidkaXNpbicsJ1xcXFx1MjJGMyc6J2lzaW5zdicsJ1xcXFx1MjJGNCc6J2lzaW5zJywnXFxcXHUyMkY1JzonaXNpbmRvdCcsJ1xcXFx1MjJGNVxcXFx1MDMzOCc6J25vdGluZG90JywnXFxcXHUyMkY2Jzonbm90aW52YycsJ1xcXFx1MjJGNyc6J25vdGludmInLCdcXFxcdTIyRjknOidpc2luRScsJ1xcXFx1MjJGOVxcXFx1MDMzOCc6J25vdGluRScsJ1xcXFx1MjJGQSc6J25pc2QnLCdcXFxcdTIyRkInOid4bmlzJywnXFxcXHUyMkZDJzonbmlzJywnXFxcXHUyMkZEJzonbm90bml2YycsJ1xcXFx1MjJGRSc6J25vdG5pdmInLCdcXFxcdTIzMDUnOidiYXJ3ZWQnLCdcXFxcdTIzMDYnOidCYXJ3ZWQnLCdcXFxcdTIzMEMnOidkcmNyb3AnLCdcXFxcdTIzMEQnOidkbGNyb3AnLCdcXFxcdTIzMEUnOid1cmNyb3AnLCdcXFxcdTIzMEYnOid1bGNyb3AnLCdcXFxcdTIzMTAnOidibm90JywnXFxcXHUyMzEyJzoncHJvZmxpbmUnLCdcXFxcdTIzMTMnOidwcm9mc3VyZicsJ1xcXFx1MjMxNSc6J3RlbHJlYycsJ1xcXFx1MjMxNic6J3RhcmdldCcsJ1xcXFx1MjMxQyc6J3VsY29ybicsJ1xcXFx1MjMxRCc6J3VyY29ybicsJ1xcXFx1MjMxRSc6J2RsY29ybicsJ1xcXFx1MjMxRic6J2RyY29ybicsJ1xcXFx1MjMyMic6J2Zyb3duJywnXFxcXHUyMzIzJzonc21pbGUnLCdcXFxcdTIzMkQnOidjeWxjdHknLCdcXFxcdTIzMkUnOidwcm9mYWxhcicsJ1xcXFx1MjMzNic6J3RvcGJvdCcsJ1xcXFx1MjMzRCc6J292YmFyJywnXFxcXHUyMzNGJzonc29sYmFyJywnXFxcXHUyMzdDJzonYW5nemFycicsJ1xcXFx1MjNCMCc6J2xtb3VzdCcsJ1xcXFx1MjNCMSc6J3Jtb3VzdCcsJ1xcXFx1MjNCNCc6J3RicmsnLCdcXFxcdTIzQjUnOidiYnJrJywnXFxcXHUyM0I2JzonYmJya3RicmsnLCdcXFxcdTIzREMnOidPdmVyUGFyZW50aGVzaXMnLCdcXFxcdTIzREQnOidVbmRlclBhcmVudGhlc2lzJywnXFxcXHUyM0RFJzonT3ZlckJyYWNlJywnXFxcXHUyM0RGJzonVW5kZXJCcmFjZScsJ1xcXFx1MjNFMic6J3RycGV6aXVtJywnXFxcXHUyM0U3JzonZWxpbnRlcnMnLCdcXFxcdTI0MjMnOidibGFuaycsJ1xcXFx1MjUwMCc6J2JveGgnLCdcXFxcdTI1MDInOidib3h2JywnXFxcXHUyNTBDJzonYm94ZHInLCdcXFxcdTI1MTAnOidib3hkbCcsJ1xcXFx1MjUxNCc6J2JveHVyJywnXFxcXHUyNTE4JzonYm94dWwnLCdcXFxcdTI1MUMnOidib3h2cicsJ1xcXFx1MjUyNCc6J2JveHZsJywnXFxcXHUyNTJDJzonYm94aGQnLCdcXFxcdTI1MzQnOidib3hodScsJ1xcXFx1MjUzQyc6J2JveHZoJywnXFxcXHUyNTUwJzonYm94SCcsJ1xcXFx1MjU1MSc6J2JveFYnLCdcXFxcdTI1NTInOidib3hkUicsJ1xcXFx1MjU1Myc6J2JveERyJywnXFxcXHUyNTU0JzonYm94RFInLCdcXFxcdTI1NTUnOidib3hkTCcsJ1xcXFx1MjU1Nic6J2JveERsJywnXFxcXHUyNTU3JzonYm94REwnLCdcXFxcdTI1NTgnOidib3h1UicsJ1xcXFx1MjU1OSc6J2JveFVyJywnXFxcXHUyNTVBJzonYm94VVInLCdcXFxcdTI1NUInOidib3h1TCcsJ1xcXFx1MjU1Qyc6J2JveFVsJywnXFxcXHUyNTVEJzonYm94VUwnLCdcXFxcdTI1NUUnOidib3h2UicsJ1xcXFx1MjU1Ric6J2JveFZyJywnXFxcXHUyNTYwJzonYm94VlInLCdcXFxcdTI1NjEnOidib3h2TCcsJ1xcXFx1MjU2Mic6J2JveFZsJywnXFxcXHUyNTYzJzonYm94VkwnLCdcXFxcdTI1NjQnOidib3hIZCcsJ1xcXFx1MjU2NSc6J2JveGhEJywnXFxcXHUyNTY2JzonYm94SEQnLCdcXFxcdTI1NjcnOidib3hIdScsJ1xcXFx1MjU2OCc6J2JveGhVJywnXFxcXHUyNTY5JzonYm94SFUnLCdcXFxcdTI1NkEnOidib3h2SCcsJ1xcXFx1MjU2Qic6J2JveFZoJywnXFxcXHUyNTZDJzonYm94VkgnLCdcXFxcdTI1ODAnOid1aGJsaycsJ1xcXFx1MjU4NCc6J2xoYmxrJywnXFxcXHUyNTg4JzonYmxvY2snLCdcXFxcdTI1OTEnOidibGsxNCcsJ1xcXFx1MjU5Mic6J2JsazEyJywnXFxcXHUyNTkzJzonYmxrMzQnLCdcXFxcdTI1QTEnOidzcXUnLCdcXFxcdTI1QUEnOidzcXVmJywnXFxcXHUyNUFCJzonRW1wdHlWZXJ5U21hbGxTcXVhcmUnLCdcXFxcdTI1QUQnOidyZWN0JywnXFxcXHUyNUFFJzonbWFya2VyJywnXFxcXHUyNUIxJzonZmx0bnMnLCdcXFxcdTI1QjMnOid4dXRyaScsJ1xcXFx1MjVCNCc6J3V0cmlmJywnXFxcXHUyNUI1JzondXRyaScsJ1xcXFx1MjVCOCc6J3J0cmlmJywnXFxcXHUyNUI5JzoncnRyaScsJ1xcXFx1MjVCRCc6J3hkdHJpJywnXFxcXHUyNUJFJzonZHRyaWYnLCdcXFxcdTI1QkYnOidkdHJpJywnXFxcXHUyNUMyJzonbHRyaWYnLCdcXFxcdTI1QzMnOidsdHJpJywnXFxcXHUyNUNBJzonbG96JywnXFxcXHUyNUNCJzonY2lyJywnXFxcXHUyNUVDJzondHJpZG90JywnXFxcXHUyNUVGJzoneGNpcmMnLCdcXFxcdTI1RjgnOid1bHRyaScsJ1xcXFx1MjVGOSc6J3VydHJpJywnXFxcXHUyNUZBJzonbGx0cmknLCdcXFxcdTI1RkInOidFbXB0eVNtYWxsU3F1YXJlJywnXFxcXHUyNUZDJzonRmlsbGVkU21hbGxTcXVhcmUnLCdcXFxcdTI2MDUnOidzdGFyZicsJ1xcXFx1MjYwNic6J3N0YXInLCdcXFxcdTI2MEUnOidwaG9uZScsJ1xcXFx1MjY0MCc6J2ZlbWFsZScsJ1xcXFx1MjY0Mic6J21hbGUnLCdcXFxcdTI2NjAnOidzcGFkZXMnLCdcXFxcdTI2NjMnOidjbHVicycsJ1xcXFx1MjY2NSc6J2hlYXJ0cycsJ1xcXFx1MjY2Nic6J2RpYW1zJywnXFxcXHUyNjZBJzonc3VuZycsJ1xcXFx1MjcxMyc6J2NoZWNrJywnXFxcXHUyNzE3JzonY3Jvc3MnLCdcXFxcdTI3MjAnOidtYWx0JywnXFxcXHUyNzM2Jzonc2V4dCcsJ1xcXFx1Mjc1OCc6J1ZlcnRpY2FsU2VwYXJhdG9yJywnXFxcXHUyN0M4JzonYnNvbGhzdWInLCdcXFxcdTI3QzknOidzdXBoc29sJywnXFxcXHUyN0Y1JzoneGxhcnInLCdcXFxcdTI3RjYnOid4cmFycicsJ1xcXFx1MjdGNyc6J3hoYXJyJywnXFxcXHUyN0Y4JzoneGxBcnInLCdcXFxcdTI3RjknOid4ckFycicsJ1xcXFx1MjdGQSc6J3hoQXJyJywnXFxcXHUyN0ZDJzoneG1hcCcsJ1xcXFx1MjdGRic6J2R6aWdyYXJyJywnXFxcXHUyOTAyJzonbnZsQXJyJywnXFxcXHUyOTAzJzonbnZyQXJyJywnXFxcXHUyOTA0JzonbnZIYXJyJywnXFxcXHUyOTA1JzonTWFwJywnXFxcXHUyOTBDJzonbGJhcnInLCdcXFxcdTI5MEQnOidyYmFycicsJ1xcXFx1MjkwRSc6J2xCYXJyJywnXFxcXHUyOTBGJzonckJhcnInLCdcXFxcdTI5MTAnOidSQmFycicsJ1xcXFx1MjkxMSc6J0REb3RyYWhkJywnXFxcXHUyOTEyJzonVXBBcnJvd0JhcicsJ1xcXFx1MjkxMyc6J0Rvd25BcnJvd0JhcicsJ1xcXFx1MjkxNic6J1JhcnJ0bCcsJ1xcXFx1MjkxOSc6J2xhdGFpbCcsJ1xcXFx1MjkxQSc6J3JhdGFpbCcsJ1xcXFx1MjkxQic6J2xBdGFpbCcsJ1xcXFx1MjkxQyc6J3JBdGFpbCcsJ1xcXFx1MjkxRCc6J2xhcnJmcycsJ1xcXFx1MjkxRSc6J3JhcnJmcycsJ1xcXFx1MjkxRic6J2xhcnJiZnMnLCdcXFxcdTI5MjAnOidyYXJyYmZzJywnXFxcXHUyOTIzJzonbndhcmhrJywnXFxcXHUyOTI0JzonbmVhcmhrJywnXFxcXHUyOTI1Jzonc2VhcmhrJywnXFxcXHUyOTI2Jzonc3dhcmhrJywnXFxcXHUyOTI3JzonbnduZWFyJywnXFxcXHUyOTI4JzondG9lYScsJ1xcXFx1MjkyOSc6J3Rvc2EnLCdcXFxcdTI5MkEnOidzd253YXInLCdcXFxcdTI5MzMnOidyYXJyYycsJ1xcXFx1MjkzM1xcXFx1MDMzOCc6J25yYXJyYycsJ1xcXFx1MjkzNSc6J2N1ZGFycnInLCdcXFxcdTI5MzYnOidsZGNhJywnXFxcXHUyOTM3JzoncmRjYScsJ1xcXFx1MjkzOCc6J2N1ZGFycmwnLCdcXFxcdTI5MzknOidsYXJycGwnLCdcXFxcdTI5M0MnOidjdXJhcnJtJywnXFxcXHUyOTNEJzonY3VsYXJycCcsJ1xcXFx1Mjk0NSc6J3JhcnJwbCcsJ1xcXFx1Mjk0OCc6J2hhcnJjaXInLCdcXFxcdTI5NDknOidVYXJyb2NpcicsJ1xcXFx1Mjk0QSc6J2x1cmRzaGFyJywnXFxcXHUyOTRCJzonbGRydXNoYXInLCdcXFxcdTI5NEUnOidMZWZ0UmlnaHRWZWN0b3InLCdcXFxcdTI5NEYnOidSaWdodFVwRG93blZlY3RvcicsJ1xcXFx1Mjk1MCc6J0Rvd25MZWZ0UmlnaHRWZWN0b3InLCdcXFxcdTI5NTEnOidMZWZ0VXBEb3duVmVjdG9yJywnXFxcXHUyOTUyJzonTGVmdFZlY3RvckJhcicsJ1xcXFx1Mjk1Myc6J1JpZ2h0VmVjdG9yQmFyJywnXFxcXHUyOTU0JzonUmlnaHRVcFZlY3RvckJhcicsJ1xcXFx1Mjk1NSc6J1JpZ2h0RG93blZlY3RvckJhcicsJ1xcXFx1Mjk1Nic6J0Rvd25MZWZ0VmVjdG9yQmFyJywnXFxcXHUyOTU3JzonRG93blJpZ2h0VmVjdG9yQmFyJywnXFxcXHUyOTU4JzonTGVmdFVwVmVjdG9yQmFyJywnXFxcXHUyOTU5JzonTGVmdERvd25WZWN0b3JCYXInLCdcXFxcdTI5NUEnOidMZWZ0VGVlVmVjdG9yJywnXFxcXHUyOTVCJzonUmlnaHRUZWVWZWN0b3InLCdcXFxcdTI5NUMnOidSaWdodFVwVGVlVmVjdG9yJywnXFxcXHUyOTVEJzonUmlnaHREb3duVGVlVmVjdG9yJywnXFxcXHUyOTVFJzonRG93bkxlZnRUZWVWZWN0b3InLCdcXFxcdTI5NUYnOidEb3duUmlnaHRUZWVWZWN0b3InLCdcXFxcdTI5NjAnOidMZWZ0VXBUZWVWZWN0b3InLCdcXFxcdTI5NjEnOidMZWZ0RG93blRlZVZlY3RvcicsJ1xcXFx1Mjk2Mic6J2xIYXInLCdcXFxcdTI5NjMnOid1SGFyJywnXFxcXHUyOTY0JzonckhhcicsJ1xcXFx1Mjk2NSc6J2RIYXInLCdcXFxcdTI5NjYnOidsdXJ1aGFyJywnXFxcXHUyOTY3JzonbGRyZGhhcicsJ1xcXFx1Mjk2OCc6J3J1bHVoYXInLCdcXFxcdTI5NjknOidyZGxkaGFyJywnXFxcXHUyOTZBJzonbGhhcnVsJywnXFxcXHUyOTZCJzonbGxoYXJkJywnXFxcXHUyOTZDJzoncmhhcnVsJywnXFxcXHUyOTZEJzonbHJoYXJkJywnXFxcXHUyOTZFJzondWRoYXInLCdcXFxcdTI5NkYnOidkdWhhcicsJ1xcXFx1Mjk3MCc6J1JvdW5kSW1wbGllcycsJ1xcXFx1Mjk3MSc6J2VyYXJyJywnXFxcXHUyOTcyJzonc2ltcmFycicsJ1xcXFx1Mjk3Myc6J2xhcnJzaW0nLCdcXFxcdTI5NzQnOidyYXJyc2ltJywnXFxcXHUyOTc1JzoncmFycmFwJywnXFxcXHUyOTc2JzonbHRsYXJyJywnXFxcXHUyOTc4JzonZ3RyYXJyJywnXFxcXHUyOTc5Jzonc3VicmFycicsJ1xcXFx1Mjk3Qic6J3N1cGxhcnInLCdcXFxcdTI5N0MnOidsZmlzaHQnLCdcXFxcdTI5N0QnOidyZmlzaHQnLCdcXFxcdTI5N0UnOid1ZmlzaHQnLCdcXFxcdTI5N0YnOidkZmlzaHQnLCdcXFxcdTI5OUEnOid2emlnemFnJywnXFxcXHUyOTlDJzondmFuZ3J0JywnXFxcXHUyOTlEJzonYW5ncnR2YmQnLCdcXFxcdTI5QTQnOidhbmdlJywnXFxcXHUyOUE1JzoncmFuZ2UnLCdcXFxcdTI5QTYnOidkd2FuZ2xlJywnXFxcXHUyOUE3JzondXdhbmdsZScsJ1xcXFx1MjlBOCc6J2FuZ21zZGFhJywnXFxcXHUyOUE5JzonYW5nbXNkYWInLCdcXFxcdTI5QUEnOidhbmdtc2RhYycsJ1xcXFx1MjlBQic6J2FuZ21zZGFkJywnXFxcXHUyOUFDJzonYW5nbXNkYWUnLCdcXFxcdTI5QUQnOidhbmdtc2RhZicsJ1xcXFx1MjlBRSc6J2FuZ21zZGFnJywnXFxcXHUyOUFGJzonYW5nbXNkYWgnLCdcXFxcdTI5QjAnOidiZW1wdHl2JywnXFxcXHUyOUIxJzonZGVtcHR5dicsJ1xcXFx1MjlCMic6J2NlbXB0eXYnLCdcXFxcdTI5QjMnOidyYWVtcHR5dicsJ1xcXFx1MjlCNCc6J2xhZW1wdHl2JywnXFxcXHUyOUI1Jzonb2hiYXInLCdcXFxcdTI5QjYnOidvbWlkJywnXFxcXHUyOUI3Jzonb3BhcicsJ1xcXFx1MjlCOSc6J29wZXJwJywnXFxcXHUyOUJCJzonb2xjcm9zcycsJ1xcXFx1MjlCQyc6J29kc29sZCcsJ1xcXFx1MjlCRSc6J29sY2lyJywnXFxcXHUyOUJGJzonb2ZjaXInLCdcXFxcdTI5QzAnOidvbHQnLCdcXFxcdTI5QzEnOidvZ3QnLCdcXFxcdTI5QzInOidjaXJzY2lyJywnXFxcXHUyOUMzJzonY2lyRScsJ1xcXFx1MjlDNCc6J3NvbGInLCdcXFxcdTI5QzUnOidic29sYicsJ1xcXFx1MjlDOSc6J2JveGJveCcsJ1xcXFx1MjlDRCc6J3RyaXNiJywnXFxcXHUyOUNFJzoncnRyaWx0cmknLCdcXFxcdTI5Q0YnOidMZWZ0VHJpYW5nbGVCYXInLCdcXFxcdTI5Q0ZcXFxcdTAzMzgnOidOb3RMZWZ0VHJpYW5nbGVCYXInLCdcXFxcdTI5RDAnOidSaWdodFRyaWFuZ2xlQmFyJywnXFxcXHUyOUQwXFxcXHUwMzM4JzonTm90UmlnaHRUcmlhbmdsZUJhcicsJ1xcXFx1MjlEQyc6J2lpbmZpbicsJ1xcXFx1MjlERCc6J2luZmludGllJywnXFxcXHUyOURFJzonbnZpbmZpbicsJ1xcXFx1MjlFMyc6J2VwYXJzbCcsJ1xcXFx1MjlFNCc6J3NtZXBhcnNsJywnXFxcXHUyOUU1JzonZXF2cGFyc2wnLCdcXFxcdTI5RUInOidsb3pmJywnXFxcXHUyOUY0JzonUnVsZURlbGF5ZWQnLCdcXFxcdTI5RjYnOidkc29sJywnXFxcXHUyQTAwJzoneG9kb3QnLCdcXFxcdTJBMDEnOid4b3BsdXMnLCdcXFxcdTJBMDInOid4b3RpbWUnLCdcXFxcdTJBMDQnOid4dXBsdXMnLCdcXFxcdTJBMDYnOid4c3FjdXAnLCdcXFxcdTJBMEQnOidmcGFydGludCcsJ1xcXFx1MkExMCc6J2NpcmZuaW50JywnXFxcXHUyQTExJzonYXdpbnQnLCdcXFxcdTJBMTInOidycHBvbGludCcsJ1xcXFx1MkExMyc6J3NjcG9saW50JywnXFxcXHUyQTE0JzonbnBvbGludCcsJ1xcXFx1MkExNSc6J3BvaW50aW50JywnXFxcXHUyQTE2JzoncXVhdGludCcsJ1xcXFx1MkExNyc6J2ludGxhcmhrJywnXFxcXHUyQTIyJzoncGx1c2NpcicsJ1xcXFx1MkEyMyc6J3BsdXNhY2lyJywnXFxcXHUyQTI0Jzonc2ltcGx1cycsJ1xcXFx1MkEyNSc6J3BsdXNkdScsJ1xcXFx1MkEyNic6J3BsdXNzaW0nLCdcXFxcdTJBMjcnOidwbHVzdHdvJywnXFxcXHUyQTI5JzonbWNvbW1hJywnXFxcXHUyQTJBJzonbWludXNkdScsJ1xcXFx1MkEyRCc6J2xvcGx1cycsJ1xcXFx1MkEyRSc6J3JvcGx1cycsJ1xcXFx1MkEyRic6J0Nyb3NzJywnXFxcXHUyQTMwJzondGltZXNkJywnXFxcXHUyQTMxJzondGltZXNiYXInLCdcXFxcdTJBMzMnOidzbWFzaHAnLCdcXFxcdTJBMzQnOidsb3RpbWVzJywnXFxcXHUyQTM1Jzoncm90aW1lcycsJ1xcXFx1MkEzNic6J290aW1lc2FzJywnXFxcXHUyQTM3JzonT3RpbWVzJywnXFxcXHUyQTM4Jzonb2RpdicsJ1xcXFx1MkEzOSc6J3RyaXBsdXMnLCdcXFxcdTJBM0EnOid0cmltaW51cycsJ1xcXFx1MkEzQic6J3RyaXRpbWUnLCdcXFxcdTJBM0MnOidpcHJvZCcsJ1xcXFx1MkEzRic6J2FtYWxnJywnXFxcXHUyQTQwJzonY2FwZG90JywnXFxcXHUyQTQyJzonbmN1cCcsJ1xcXFx1MkE0Myc6J25jYXAnLCdcXFxcdTJBNDQnOidjYXBhbmQnLCdcXFxcdTJBNDUnOidjdXBvcicsJ1xcXFx1MkE0Nic6J2N1cGNhcCcsJ1xcXFx1MkE0Nyc6J2NhcGN1cCcsJ1xcXFx1MkE0OCc6J2N1cGJyY2FwJywnXFxcXHUyQTQ5JzonY2FwYnJjdXAnLCdcXFxcdTJBNEEnOidjdXBjdXAnLCdcXFxcdTJBNEInOidjYXBjYXAnLCdcXFxcdTJBNEMnOidjY3VwcycsJ1xcXFx1MkE0RCc6J2NjYXBzJywnXFxcXHUyQTUwJzonY2N1cHNzbScsJ1xcXFx1MkE1Myc6J0FuZCcsJ1xcXFx1MkE1NCc6J09yJywnXFxcXHUyQTU1JzonYW5kYW5kJywnXFxcXHUyQTU2Jzonb3JvcicsJ1xcXFx1MkE1Nyc6J29yc2xvcGUnLCdcXFxcdTJBNTgnOidhbmRzbG9wZScsJ1xcXFx1MkE1QSc6J2FuZHYnLCdcXFxcdTJBNUInOidvcnYnLCdcXFxcdTJBNUMnOidhbmRkJywnXFxcXHUyQTVEJzonb3JkJywnXFxcXHUyQTVGJzond2VkYmFyJywnXFxcXHUyQTY2Jzonc2RvdGUnLCdcXFxcdTJBNkEnOidzaW1kb3QnLCdcXFxcdTJBNkQnOidjb25nZG90JywnXFxcXHUyQTZEXFxcXHUwMzM4JzonbmNvbmdkb3QnLCdcXFxcdTJBNkUnOidlYXN0ZXInLCdcXFxcdTJBNkYnOidhcGFjaXInLCdcXFxcdTJBNzAnOidhcEUnLCdcXFxcdTJBNzBcXFxcdTAzMzgnOiduYXBFJywnXFxcXHUyQTcxJzonZXBsdXMnLCdcXFxcdTJBNzInOidwbHVzZScsJ1xcXFx1MkE3Myc6J0VzaW0nLCdcXFxcdTJBNzcnOidlRERvdCcsJ1xcXFx1MkE3OCc6J2VxdWl2REQnLCdcXFxcdTJBNzknOidsdGNpcicsJ1xcXFx1MkE3QSc6J2d0Y2lyJywnXFxcXHUyQTdCJzonbHRxdWVzdCcsJ1xcXFx1MkE3Qyc6J2d0cXVlc3QnLCdcXFxcdTJBN0QnOidsZXMnLCdcXFxcdTJBN0RcXFxcdTAzMzgnOidubGVzJywnXFxcXHUyQTdFJzonZ2VzJywnXFxcXHUyQTdFXFxcXHUwMzM4JzonbmdlcycsJ1xcXFx1MkE3Ric6J2xlc2RvdCcsJ1xcXFx1MkE4MCc6J2dlc2RvdCcsJ1xcXFx1MkE4MSc6J2xlc2RvdG8nLCdcXFxcdTJBODInOidnZXNkb3RvJywnXFxcXHUyQTgzJzonbGVzZG90b3InLCdcXFxcdTJBODQnOidnZXNkb3RvbCcsJ1xcXFx1MkE4NSc6J2xhcCcsJ1xcXFx1MkE4Nic6J2dhcCcsJ1xcXFx1MkE4Nyc6J2xuZScsJ1xcXFx1MkE4OCc6J2duZScsJ1xcXFx1MkE4OSc6J2xuYXAnLCdcXFxcdTJBOEEnOidnbmFwJywnXFxcXHUyQThCJzonbEVnJywnXFxcXHUyQThDJzonZ0VsJywnXFxcXHUyQThEJzonbHNpbWUnLCdcXFxcdTJBOEUnOidnc2ltZScsJ1xcXFx1MkE4Ric6J2xzaW1nJywnXFxcXHUyQTkwJzonZ3NpbWwnLCdcXFxcdTJBOTEnOidsZ0UnLCdcXFxcdTJBOTInOidnbEUnLCdcXFxcdTJBOTMnOidsZXNnZXMnLCdcXFxcdTJBOTQnOidnZXNsZXMnLCdcXFxcdTJBOTUnOidlbHMnLCdcXFxcdTJBOTYnOidlZ3MnLCdcXFxcdTJBOTcnOidlbHNkb3QnLCdcXFxcdTJBOTgnOidlZ3Nkb3QnLCdcXFxcdTJBOTknOidlbCcsJ1xcXFx1MkE5QSc6J2VnJywnXFxcXHUyQTlEJzonc2ltbCcsJ1xcXFx1MkE5RSc6J3NpbWcnLCdcXFxcdTJBOUYnOidzaW1sRScsJ1xcXFx1MkFBMCc6J3NpbWdFJywnXFxcXHUyQUExJzonTGVzc0xlc3MnLCdcXFxcdTJBQTFcXFxcdTAzMzgnOidOb3ROZXN0ZWRMZXNzTGVzcycsJ1xcXFx1MkFBMic6J0dyZWF0ZXJHcmVhdGVyJywnXFxcXHUyQUEyXFxcXHUwMzM4JzonTm90TmVzdGVkR3JlYXRlckdyZWF0ZXInLCdcXFxcdTJBQTQnOidnbGonLCdcXFxcdTJBQTUnOidnbGEnLCdcXFxcdTJBQTYnOidsdGNjJywnXFxcXHUyQUE3JzonZ3RjYycsJ1xcXFx1MkFBOCc6J2xlc2NjJywnXFxcXHUyQUE5JzonZ2VzY2MnLCdcXFxcdTJBQUEnOidzbXQnLCdcXFxcdTJBQUInOidsYXQnLCdcXFxcdTJBQUMnOidzbXRlJywnXFxcXHUyQUFDXFxcXHVGRTAwJzonc210ZXMnLCdcXFxcdTJBQUQnOidsYXRlJywnXFxcXHUyQUFEXFxcXHVGRTAwJzonbGF0ZXMnLCdcXFxcdTJBQUUnOididW1wRScsJ1xcXFx1MkFBRic6J3ByZScsJ1xcXFx1MkFBRlxcXFx1MDMzOCc6J25wcmUnLCdcXFxcdTJBQjAnOidzY2UnLCdcXFxcdTJBQjBcXFxcdTAzMzgnOiduc2NlJywnXFxcXHUyQUIzJzoncHJFJywnXFxcXHUyQUI0Jzonc2NFJywnXFxcXHUyQUI1JzoncHJuRScsJ1xcXFx1MkFCNic6J3NjbkUnLCdcXFxcdTJBQjcnOidwcmFwJywnXFxcXHUyQUI4Jzonc2NhcCcsJ1xcXFx1MkFCOSc6J3BybmFwJywnXFxcXHUyQUJBJzonc2NuYXAnLCdcXFxcdTJBQkInOidQcicsJ1xcXFx1MkFCQyc6J1NjJywnXFxcXHUyQUJEJzonc3ViZG90JywnXFxcXHUyQUJFJzonc3VwZG90JywnXFxcXHUyQUJGJzonc3VicGx1cycsJ1xcXFx1MkFDMCc6J3N1cHBsdXMnLCdcXFxcdTJBQzEnOidzdWJtdWx0JywnXFxcXHUyQUMyJzonc3VwbXVsdCcsJ1xcXFx1MkFDMyc6J3N1YmVkb3QnLCdcXFxcdTJBQzQnOidzdXBlZG90JywnXFxcXHUyQUM1Jzonc3ViRScsJ1xcXFx1MkFDNVxcXFx1MDMzOCc6J25zdWJFJywnXFxcXHUyQUM2Jzonc3VwRScsJ1xcXFx1MkFDNlxcXFx1MDMzOCc6J25zdXBFJywnXFxcXHUyQUM3Jzonc3Vic2ltJywnXFxcXHUyQUM4Jzonc3Vwc2ltJywnXFxcXHUyQUNCXFxcXHVGRTAwJzondnN1Ym5FJywnXFxcXHUyQUNCJzonc3VibkUnLCdcXFxcdTJBQ0NcXFxcdUZFMDAnOid2c3VwbkUnLCdcXFxcdTJBQ0MnOidzdXBuRScsJ1xcXFx1MkFDRic6J2NzdWInLCdcXFxcdTJBRDAnOidjc3VwJywnXFxcXHUyQUQxJzonY3N1YmUnLCdcXFxcdTJBRDInOidjc3VwZScsJ1xcXFx1MkFEMyc6J3N1YnN1cCcsJ1xcXFx1MkFENCc6J3N1cHN1YicsJ1xcXFx1MkFENSc6J3N1YnN1YicsJ1xcXFx1MkFENic6J3N1cHN1cCcsJ1xcXFx1MkFENyc6J3N1cGhzdWInLCdcXFxcdTJBRDgnOidzdXBkc3ViJywnXFxcXHUyQUQ5JzonZm9ya3YnLCdcXFxcdTJBREEnOid0b3Bmb3JrJywnXFxcXHUyQURCJzonbWxjcCcsJ1xcXFx1MkFFNCc6J0Rhc2h2JywnXFxcXHUyQUU2JzonVmRhc2hsJywnXFxcXHUyQUU3JzonQmFydicsJ1xcXFx1MkFFOCc6J3ZCYXInLCdcXFxcdTJBRTknOid2QmFydicsJ1xcXFx1MkFFQic6J1ZiYXInLCdcXFxcdTJBRUMnOidOb3QnLCdcXFxcdTJBRUQnOidiTm90JywnXFxcXHUyQUVFJzoncm5taWQnLCdcXFxcdTJBRUYnOidjaXJtaWQnLCdcXFxcdTJBRjAnOidtaWRjaXInLCdcXFxcdTJBRjEnOid0b3BjaXInLCdcXFxcdTJBRjInOiduaHBhcicsJ1xcXFx1MkFGMyc6J3BhcnNpbScsJ1xcXFx1MkFGRCc6J3BhcnNsJywnXFxcXHUyQUZEXFxcXHUyMEU1JzonbnBhcnNsJywnXFxcXHUyNjZEJzonZmxhdCcsJ1xcXFx1MjY2RSc6J25hdHVyJywnXFxcXHUyNjZGJzonc2hhcnAnLCdcXFxceEE0JzonY3VycmVuJywnXFxcXHhBMic6J2NlbnQnLCckJzonZG9sbGFyJywnXFxcXHhBMyc6J3BvdW5kJywnXFxcXHhBNSc6J3llbicsJ1xcXFx1MjBBQyc6J2V1cm8nLCdcXFxceEI5Jzonc3VwMScsJ1xcXFx4QkQnOidoYWxmJywnXFxcXHUyMTUzJzonZnJhYzEzJywnXFxcXHhCQyc6J2ZyYWMxNCcsJ1xcXFx1MjE1NSc6J2ZyYWMxNScsJ1xcXFx1MjE1OSc6J2ZyYWMxNicsJ1xcXFx1MjE1Qic6J2ZyYWMxOCcsJ1xcXFx4QjInOidzdXAyJywnXFxcXHUyMTU0JzonZnJhYzIzJywnXFxcXHUyMTU2JzonZnJhYzI1JywnXFxcXHhCMyc6J3N1cDMnLCdcXFxceEJFJzonZnJhYzM0JywnXFxcXHUyMTU3JzonZnJhYzM1JywnXFxcXHUyMTVDJzonZnJhYzM4JywnXFxcXHUyMTU4JzonZnJhYzQ1JywnXFxcXHUyMTVBJzonZnJhYzU2JywnXFxcXHUyMTVEJzonZnJhYzU4JywnXFxcXHUyMTVFJzonZnJhYzc4JywnXFxcXHVEODM1XFxcXHVEQ0I2JzonYXNjcicsJ1xcXFx1RDgzNVxcXFx1REQ1Mic6J2FvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMUUnOidhZnInLCdcXFxcdUQ4MzVcXFxcdUREMzgnOidBb3BmJywnXFxcXHVEODM1XFxcXHVERDA0JzonQWZyJywnXFxcXHVEODM1XFxcXHVEQzlDJzonQXNjcicsJ1xcXFx4QUEnOidvcmRmJywnXFxcXHhFMSc6J2FhY3V0ZScsJ1xcXFx4QzEnOidBYWN1dGUnLCdcXFxceEUwJzonYWdyYXZlJywnXFxcXHhDMCc6J0FncmF2ZScsJ1xcXFx1MDEwMyc6J2FicmV2ZScsJ1xcXFx1MDEwMic6J0FicmV2ZScsJ1xcXFx4RTInOidhY2lyYycsJ1xcXFx4QzInOidBY2lyYycsJ1xcXFx4RTUnOidhcmluZycsJ1xcXFx4QzUnOidhbmdzdCcsJ1xcXFx4RTQnOidhdW1sJywnXFxcXHhDNCc6J0F1bWwnLCdcXFxceEUzJzonYXRpbGRlJywnXFxcXHhDMyc6J0F0aWxkZScsJ1xcXFx1MDEwNSc6J2FvZ29uJywnXFxcXHUwMTA0JzonQW9nb24nLCdcXFxcdTAxMDEnOidhbWFjcicsJ1xcXFx1MDEwMCc6J0FtYWNyJywnXFxcXHhFNic6J2FlbGlnJywnXFxcXHhDNic6J0FFbGlnJywnXFxcXHVEODM1XFxcXHVEQ0I3JzonYnNjcicsJ1xcXFx1RDgzNVxcXFx1REQ1Myc6J2JvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMUYnOidiZnInLCdcXFxcdUQ4MzVcXFxcdUREMzknOidCb3BmJywnXFxcXHUyMTJDJzonQnNjcicsJ1xcXFx1RDgzNVxcXFx1REQwNSc6J0JmcicsJ1xcXFx1RDgzNVxcXFx1REQyMCc6J2NmcicsJ1xcXFx1RDgzNVxcXFx1RENCOCc6J2NzY3InLCdcXFxcdUQ4MzVcXFxcdURENTQnOidjb3BmJywnXFxcXHUyMTJEJzonQ2ZyJywnXFxcXHVEODM1XFxcXHVEQzlFJzonQ3NjcicsJ1xcXFx1MjEwMic6J0NvcGYnLCdcXFxcdTAxMDcnOidjYWN1dGUnLCdcXFxcdTAxMDYnOidDYWN1dGUnLCdcXFxcdTAxMDknOidjY2lyYycsJ1xcXFx1MDEwOCc6J0NjaXJjJywnXFxcXHUwMTBEJzonY2Nhcm9uJywnXFxcXHUwMTBDJzonQ2Nhcm9uJywnXFxcXHUwMTBCJzonY2RvdCcsJ1xcXFx1MDEwQSc6J0Nkb3QnLCdcXFxceEU3JzonY2NlZGlsJywnXFxcXHhDNyc6J0NjZWRpbCcsJ1xcXFx1MjEwNSc6J2luY2FyZScsJ1xcXFx1RDgzNVxcXFx1REQyMSc6J2RmcicsJ1xcXFx1MjE0Nic6J2RkJywnXFxcXHVEODM1XFxcXHVERDU1JzonZG9wZicsJ1xcXFx1RDgzNVxcXFx1RENCOSc6J2RzY3InLCdcXFxcdUQ4MzVcXFxcdURDOUYnOidEc2NyJywnXFxcXHVEODM1XFxcXHVERDA3JzonRGZyJywnXFxcXHUyMTQ1JzonREQnLCdcXFxcdUQ4MzVcXFxcdUREM0InOidEb3BmJywnXFxcXHUwMTBGJzonZGNhcm9uJywnXFxcXHUwMTBFJzonRGNhcm9uJywnXFxcXHUwMTExJzonZHN0cm9rJywnXFxcXHUwMTEwJzonRHN0cm9rJywnXFxcXHhGMCc6J2V0aCcsJ1xcXFx4RDAnOidFVEgnLCdcXFxcdTIxNDcnOidlZScsJ1xcXFx1MjEyRic6J2VzY3InLCdcXFxcdUQ4MzVcXFxcdUREMjInOidlZnInLCdcXFxcdUQ4MzVcXFxcdURENTYnOidlb3BmJywnXFxcXHUyMTMwJzonRXNjcicsJ1xcXFx1RDgzNVxcXFx1REQwOCc6J0VmcicsJ1xcXFx1RDgzNVxcXFx1REQzQyc6J0VvcGYnLCdcXFxceEU5JzonZWFjdXRlJywnXFxcXHhDOSc6J0VhY3V0ZScsJ1xcXFx4RTgnOidlZ3JhdmUnLCdcXFxceEM4JzonRWdyYXZlJywnXFxcXHhFQSc6J2VjaXJjJywnXFxcXHhDQSc6J0VjaXJjJywnXFxcXHUwMTFCJzonZWNhcm9uJywnXFxcXHUwMTFBJzonRWNhcm9uJywnXFxcXHhFQic6J2V1bWwnLCdcXFxceENCJzonRXVtbCcsJ1xcXFx1MDExNyc6J2Vkb3QnLCdcXFxcdTAxMTYnOidFZG90JywnXFxcXHUwMTE5JzonZW9nb24nLCdcXFxcdTAxMTgnOidFb2dvbicsJ1xcXFx1MDExMyc6J2VtYWNyJywnXFxcXHUwMTEyJzonRW1hY3InLCdcXFxcdUQ4MzVcXFxcdUREMjMnOidmZnInLCdcXFxcdUQ4MzVcXFxcdURENTcnOidmb3BmJywnXFxcXHVEODM1XFxcXHVEQ0JCJzonZnNjcicsJ1xcXFx1RDgzNVxcXFx1REQwOSc6J0ZmcicsJ1xcXFx1RDgzNVxcXFx1REQzRCc6J0ZvcGYnLCdcXFxcdTIxMzEnOidGc2NyJywnXFxcXHVGQjAwJzonZmZsaWcnLCdcXFxcdUZCMDMnOidmZmlsaWcnLCdcXFxcdUZCMDQnOidmZmxsaWcnLCdcXFxcdUZCMDEnOidmaWxpZycsJ2ZqJzonZmpsaWcnLCdcXFxcdUZCMDInOidmbGxpZycsJ1xcXFx1MDE5Mic6J2Zub2YnLCdcXFxcdTIxMEEnOidnc2NyJywnXFxcXHVEODM1XFxcXHVERDU4JzonZ29wZicsJ1xcXFx1RDgzNVxcXFx1REQyNCc6J2dmcicsJ1xcXFx1RDgzNVxcXFx1RENBMic6J0dzY3InLCdcXFxcdUQ4MzVcXFxcdUREM0UnOidHb3BmJywnXFxcXHVEODM1XFxcXHVERDBBJzonR2ZyJywnXFxcXHUwMUY1JzonZ2FjdXRlJywnXFxcXHUwMTFGJzonZ2JyZXZlJywnXFxcXHUwMTFFJzonR2JyZXZlJywnXFxcXHUwMTFEJzonZ2NpcmMnLCdcXFxcdTAxMUMnOidHY2lyYycsJ1xcXFx1MDEyMSc6J2dkb3QnLCdcXFxcdTAxMjAnOidHZG90JywnXFxcXHUwMTIyJzonR2NlZGlsJywnXFxcXHVEODM1XFxcXHVERDI1JzonaGZyJywnXFxcXHUyMTBFJzoncGxhbmNraCcsJ1xcXFx1RDgzNVxcXFx1RENCRCc6J2hzY3InLCdcXFxcdUQ4MzVcXFxcdURENTknOidob3BmJywnXFxcXHUyMTBCJzonSHNjcicsJ1xcXFx1MjEwQyc6J0hmcicsJ1xcXFx1MjEwRCc6J0hvcGYnLCdcXFxcdTAxMjUnOidoY2lyYycsJ1xcXFx1MDEyNCc6J0hjaXJjJywnXFxcXHUyMTBGJzonaGJhcicsJ1xcXFx1MDEyNyc6J2hzdHJvaycsJ1xcXFx1MDEyNic6J0hzdHJvaycsJ1xcXFx1RDgzNVxcXFx1REQ1QSc6J2lvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMjYnOidpZnInLCdcXFxcdUQ4MzVcXFxcdURDQkUnOidpc2NyJywnXFxcXHUyMTQ4JzonaWknLCdcXFxcdUQ4MzVcXFxcdURENDAnOidJb3BmJywnXFxcXHUyMTEwJzonSXNjcicsJ1xcXFx1MjExMSc6J0ltJywnXFxcXHhFRCc6J2lhY3V0ZScsJ1xcXFx4Q0QnOidJYWN1dGUnLCdcXFxceEVDJzonaWdyYXZlJywnXFxcXHhDQyc6J0lncmF2ZScsJ1xcXFx4RUUnOidpY2lyYycsJ1xcXFx4Q0UnOidJY2lyYycsJ1xcXFx4RUYnOidpdW1sJywnXFxcXHhDRic6J0l1bWwnLCdcXFxcdTAxMjknOidpdGlsZGUnLCdcXFxcdTAxMjgnOidJdGlsZGUnLCdcXFxcdTAxMzAnOidJZG90JywnXFxcXHUwMTJGJzonaW9nb24nLCdcXFxcdTAxMkUnOidJb2dvbicsJ1xcXFx1MDEyQic6J2ltYWNyJywnXFxcXHUwMTJBJzonSW1hY3InLCdcXFxcdTAxMzMnOidpamxpZycsJ1xcXFx1MDEzMic6J0lKbGlnJywnXFxcXHUwMTMxJzonaW1hdGgnLCdcXFxcdUQ4MzVcXFxcdURDQkYnOidqc2NyJywnXFxcXHVEODM1XFxcXHVERDVCJzonam9wZicsJ1xcXFx1RDgzNVxcXFx1REQyNyc6J2pmcicsJ1xcXFx1RDgzNVxcXFx1RENBNSc6J0pzY3InLCdcXFxcdUQ4MzVcXFxcdUREMEQnOidKZnInLCdcXFxcdUQ4MzVcXFxcdURENDEnOidKb3BmJywnXFxcXHUwMTM1JzonamNpcmMnLCdcXFxcdTAxMzQnOidKY2lyYycsJ1xcXFx1MDIzNyc6J2ptYXRoJywnXFxcXHVEODM1XFxcXHVERDVDJzona29wZicsJ1xcXFx1RDgzNVxcXFx1RENDMCc6J2tzY3InLCdcXFxcdUQ4MzVcXFxcdUREMjgnOidrZnInLCdcXFxcdUQ4MzVcXFxcdURDQTYnOidLc2NyJywnXFxcXHVEODM1XFxcXHVERDQyJzonS29wZicsJ1xcXFx1RDgzNVxcXFx1REQwRSc6J0tmcicsJ1xcXFx1MDEzNyc6J2tjZWRpbCcsJ1xcXFx1MDEzNic6J0tjZWRpbCcsJ1xcXFx1RDgzNVxcXFx1REQyOSc6J2xmcicsJ1xcXFx1RDgzNVxcXFx1RENDMSc6J2xzY3InLCdcXFxcdTIxMTMnOidlbGwnLCdcXFxcdUQ4MzVcXFxcdURENUQnOidsb3BmJywnXFxcXHUyMTEyJzonTHNjcicsJ1xcXFx1RDgzNVxcXFx1REQwRic6J0xmcicsJ1xcXFx1RDgzNVxcXFx1REQ0Myc6J0xvcGYnLCdcXFxcdTAxM0EnOidsYWN1dGUnLCdcXFxcdTAxMzknOidMYWN1dGUnLCdcXFxcdTAxM0UnOidsY2Fyb24nLCdcXFxcdTAxM0QnOidMY2Fyb24nLCdcXFxcdTAxM0MnOidsY2VkaWwnLCdcXFxcdTAxM0InOidMY2VkaWwnLCdcXFxcdTAxNDInOidsc3Ryb2snLCdcXFxcdTAxNDEnOidMc3Ryb2snLCdcXFxcdTAxNDAnOidsbWlkb3QnLCdcXFxcdTAxM0YnOidMbWlkb3QnLCdcXFxcdUQ4MzVcXFxcdUREMkEnOidtZnInLCdcXFxcdUQ4MzVcXFxcdURENUUnOidtb3BmJywnXFxcXHVEODM1XFxcXHVEQ0MyJzonbXNjcicsJ1xcXFx1RDgzNVxcXFx1REQxMCc6J01mcicsJ1xcXFx1RDgzNVxcXFx1REQ0NCc6J01vcGYnLCdcXFxcdTIxMzMnOidNc2NyJywnXFxcXHVEODM1XFxcXHVERDJCJzonbmZyJywnXFxcXHVEODM1XFxcXHVERDVGJzonbm9wZicsJ1xcXFx1RDgzNVxcXFx1RENDMyc6J25zY3InLCdcXFxcdTIxMTUnOidOb3BmJywnXFxcXHVEODM1XFxcXHVEQ0E5JzonTnNjcicsJ1xcXFx1RDgzNVxcXFx1REQxMSc6J05mcicsJ1xcXFx1MDE0NCc6J25hY3V0ZScsJ1xcXFx1MDE0Myc6J05hY3V0ZScsJ1xcXFx1MDE0OCc6J25jYXJvbicsJ1xcXFx1MDE0Nyc6J05jYXJvbicsJ1xcXFx4RjEnOidudGlsZGUnLCdcXFxceEQxJzonTnRpbGRlJywnXFxcXHUwMTQ2JzonbmNlZGlsJywnXFxcXHUwMTQ1JzonTmNlZGlsJywnXFxcXHUyMTE2JzonbnVtZXJvJywnXFxcXHUwMTRCJzonZW5nJywnXFxcXHUwMTRBJzonRU5HJywnXFxcXHVEODM1XFxcXHVERDYwJzonb29wZicsJ1xcXFx1RDgzNVxcXFx1REQyQyc6J29mcicsJ1xcXFx1MjEzNCc6J29zY3InLCdcXFxcdUQ4MzVcXFxcdURDQUEnOidPc2NyJywnXFxcXHVEODM1XFxcXHVERDEyJzonT2ZyJywnXFxcXHVEODM1XFxcXHVERDQ2JzonT29wZicsJ1xcXFx4QkEnOidvcmRtJywnXFxcXHhGMyc6J29hY3V0ZScsJ1xcXFx4RDMnOidPYWN1dGUnLCdcXFxceEYyJzonb2dyYXZlJywnXFxcXHhEMic6J09ncmF2ZScsJ1xcXFx4RjQnOidvY2lyYycsJ1xcXFx4RDQnOidPY2lyYycsJ1xcXFx4RjYnOidvdW1sJywnXFxcXHhENic6J091bWwnLCdcXFxcdTAxNTEnOidvZGJsYWMnLCdcXFxcdTAxNTAnOidPZGJsYWMnLCdcXFxceEY1Jzonb3RpbGRlJywnXFxcXHhENSc6J090aWxkZScsJ1xcXFx4RjgnOidvc2xhc2gnLCdcXFxceEQ4JzonT3NsYXNoJywnXFxcXHUwMTREJzonb21hY3InLCdcXFxcdTAxNEMnOidPbWFjcicsJ1xcXFx1MDE1Myc6J29lbGlnJywnXFxcXHUwMTUyJzonT0VsaWcnLCdcXFxcdUQ4MzVcXFxcdUREMkQnOidwZnInLCdcXFxcdUQ4MzVcXFxcdURDQzUnOidwc2NyJywnXFxcXHVEODM1XFxcXHVERDYxJzoncG9wZicsJ1xcXFx1MjExOSc6J1BvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMTMnOidQZnInLCdcXFxcdUQ4MzVcXFxcdURDQUInOidQc2NyJywnXFxcXHVEODM1XFxcXHVERDYyJzoncW9wZicsJ1xcXFx1RDgzNVxcXFx1REQyRSc6J3FmcicsJ1xcXFx1RDgzNVxcXFx1RENDNic6J3FzY3InLCdcXFxcdUQ4MzVcXFxcdURDQUMnOidRc2NyJywnXFxcXHVEODM1XFxcXHVERDE0JzonUWZyJywnXFxcXHUyMTFBJzonUW9wZicsJ1xcXFx1MDEzOCc6J2tncmVlbicsJ1xcXFx1RDgzNVxcXFx1REQyRic6J3JmcicsJ1xcXFx1RDgzNVxcXFx1REQ2Myc6J3JvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQzcnOidyc2NyJywnXFxcXHUyMTFCJzonUnNjcicsJ1xcXFx1MjExQyc6J1JlJywnXFxcXHUyMTFEJzonUm9wZicsJ1xcXFx1MDE1NSc6J3JhY3V0ZScsJ1xcXFx1MDE1NCc6J1JhY3V0ZScsJ1xcXFx1MDE1OSc6J3JjYXJvbicsJ1xcXFx1MDE1OCc6J1JjYXJvbicsJ1xcXFx1MDE1Nyc6J3JjZWRpbCcsJ1xcXFx1MDE1Nic6J1JjZWRpbCcsJ1xcXFx1RDgzNVxcXFx1REQ2NCc6J3NvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQzgnOidzc2NyJywnXFxcXHVEODM1XFxcXHVERDMwJzonc2ZyJywnXFxcXHVEODM1XFxcXHVERDRBJzonU29wZicsJ1xcXFx1RDgzNVxcXFx1REQxNic6J1NmcicsJ1xcXFx1RDgzNVxcXFx1RENBRSc6J1NzY3InLCdcXFxcdTI0QzgnOidvUycsJ1xcXFx1MDE1Qic6J3NhY3V0ZScsJ1xcXFx1MDE1QSc6J1NhY3V0ZScsJ1xcXFx1MDE1RCc6J3NjaXJjJywnXFxcXHUwMTVDJzonU2NpcmMnLCdcXFxcdTAxNjEnOidzY2Fyb24nLCdcXFxcdTAxNjAnOidTY2Fyb24nLCdcXFxcdTAxNUYnOidzY2VkaWwnLCdcXFxcdTAxNUUnOidTY2VkaWwnLCdcXFxceERGJzonc3psaWcnLCdcXFxcdUQ4MzVcXFxcdUREMzEnOid0ZnInLCdcXFxcdUQ4MzVcXFxcdURDQzknOid0c2NyJywnXFxcXHVEODM1XFxcXHVERDY1JzondG9wZicsJ1xcXFx1RDgzNVxcXFx1RENBRic6J1RzY3InLCdcXFxcdUQ4MzVcXFxcdUREMTcnOidUZnInLCdcXFxcdUQ4MzVcXFxcdURENEInOidUb3BmJywnXFxcXHUwMTY1JzondGNhcm9uJywnXFxcXHUwMTY0JzonVGNhcm9uJywnXFxcXHUwMTYzJzondGNlZGlsJywnXFxcXHUwMTYyJzonVGNlZGlsJywnXFxcXHUyMTIyJzondHJhZGUnLCdcXFxcdTAxNjcnOid0c3Ryb2snLCdcXFxcdTAxNjYnOidUc3Ryb2snLCdcXFxcdUQ4MzVcXFxcdURDQ0EnOid1c2NyJywnXFxcXHVEODM1XFxcXHVERDY2JzondW9wZicsJ1xcXFx1RDgzNVxcXFx1REQzMic6J3VmcicsJ1xcXFx1RDgzNVxcXFx1REQ0Qyc6J1VvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMTgnOidVZnInLCdcXFxcdUQ4MzVcXFxcdURDQjAnOidVc2NyJywnXFxcXHhGQSc6J3VhY3V0ZScsJ1xcXFx4REEnOidVYWN1dGUnLCdcXFxceEY5JzondWdyYXZlJywnXFxcXHhEOSc6J1VncmF2ZScsJ1xcXFx1MDE2RCc6J3VicmV2ZScsJ1xcXFx1MDE2Qyc6J1VicmV2ZScsJ1xcXFx4RkInOid1Y2lyYycsJ1xcXFx4REInOidVY2lyYycsJ1xcXFx1MDE2Ric6J3VyaW5nJywnXFxcXHUwMTZFJzonVXJpbmcnLCdcXFxceEZDJzondXVtbCcsJ1xcXFx4REMnOidVdW1sJywnXFxcXHUwMTcxJzondWRibGFjJywnXFxcXHUwMTcwJzonVWRibGFjJywnXFxcXHUwMTY5JzondXRpbGRlJywnXFxcXHUwMTY4JzonVXRpbGRlJywnXFxcXHUwMTczJzondW9nb24nLCdcXFxcdTAxNzInOidVb2dvbicsJ1xcXFx1MDE2Qic6J3VtYWNyJywnXFxcXHUwMTZBJzonVW1hY3InLCdcXFxcdUQ4MzVcXFxcdUREMzMnOid2ZnInLCdcXFxcdUQ4MzVcXFxcdURENjcnOid2b3BmJywnXFxcXHVEODM1XFxcXHVEQ0NCJzondnNjcicsJ1xcXFx1RDgzNVxcXFx1REQxOSc6J1ZmcicsJ1xcXFx1RDgzNVxcXFx1REQ0RCc6J1ZvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQjEnOidWc2NyJywnXFxcXHVEODM1XFxcXHVERDY4Jzond29wZicsJ1xcXFx1RDgzNVxcXFx1RENDQyc6J3dzY3InLCdcXFxcdUQ4MzVcXFxcdUREMzQnOid3ZnInLCdcXFxcdUQ4MzVcXFxcdURDQjInOidXc2NyJywnXFxcXHVEODM1XFxcXHVERDRFJzonV29wZicsJ1xcXFx1RDgzNVxcXFx1REQxQSc6J1dmcicsJ1xcXFx1MDE3NSc6J3djaXJjJywnXFxcXHUwMTc0JzonV2NpcmMnLCdcXFxcdUQ4MzVcXFxcdUREMzUnOid4ZnInLCdcXFxcdUQ4MzVcXFxcdURDQ0QnOid4c2NyJywnXFxcXHVEODM1XFxcXHVERDY5JzoneG9wZicsJ1xcXFx1RDgzNVxcXFx1REQ0Ric6J1hvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMUInOidYZnInLCdcXFxcdUQ4MzVcXFxcdURDQjMnOidYc2NyJywnXFxcXHVEODM1XFxcXHVERDM2JzoneWZyJywnXFxcXHVEODM1XFxcXHVEQ0NFJzoneXNjcicsJ1xcXFx1RDgzNVxcXFx1REQ2QSc6J3lvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQjQnOidZc2NyJywnXFxcXHVEODM1XFxcXHVERDFDJzonWWZyJywnXFxcXHVEODM1XFxcXHVERDUwJzonWW9wZicsJ1xcXFx4RkQnOid5YWN1dGUnLCdcXFxceEREJzonWWFjdXRlJywnXFxcXHUwMTc3JzoneWNpcmMnLCdcXFxcdTAxNzYnOidZY2lyYycsJ1xcXFx4RkYnOid5dW1sJywnXFxcXHUwMTc4JzonWXVtbCcsJ1xcXFx1RDgzNVxcXFx1RENDRic6J3pzY3InLCdcXFxcdUQ4MzVcXFxcdUREMzcnOid6ZnInLCdcXFxcdUQ4MzVcXFxcdURENkInOid6b3BmJywnXFxcXHUyMTI4JzonWmZyJywnXFxcXHUyMTI0JzonWm9wZicsJ1xcXFx1RDgzNVxcXFx1RENCNSc6J1pzY3InLCdcXFxcdTAxN0EnOid6YWN1dGUnLCdcXFxcdTAxNzknOidaYWN1dGUnLCdcXFxcdTAxN0UnOid6Y2Fyb24nLCdcXFxcdTAxN0QnOidaY2Fyb24nLCdcXFxcdTAxN0MnOid6ZG90JywnXFxcXHUwMTdCJzonWmRvdCcsJ1xcXFx1MDFCNSc6J2ltcGVkJywnXFxcXHhGRSc6J3Rob3JuJywnXFxcXHhERSc6J1RIT1JOJywnXFxcXHUwMTQ5JzonbmFwb3MnLCdcXFxcdTAzQjEnOidhbHBoYScsJ1xcXFx1MDM5MSc6J0FscGhhJywnXFxcXHUwM0IyJzonYmV0YScsJ1xcXFx1MDM5Mic6J0JldGEnLCdcXFxcdTAzQjMnOidnYW1tYScsJ1xcXFx1MDM5Myc6J0dhbW1hJywnXFxcXHUwM0I0JzonZGVsdGEnLCdcXFxcdTAzOTQnOidEZWx0YScsJ1xcXFx1MDNCNSc6J2Vwc2knLCdcXFxcdTAzRjUnOidlcHNpdicsJ1xcXFx1MDM5NSc6J0Vwc2lsb24nLCdcXFxcdTAzREQnOidnYW1tYWQnLCdcXFxcdTAzREMnOidHYW1tYWQnLCdcXFxcdTAzQjYnOid6ZXRhJywnXFxcXHUwMzk2JzonWmV0YScsJ1xcXFx1MDNCNyc6J2V0YScsJ1xcXFx1MDM5Nyc6J0V0YScsJ1xcXFx1MDNCOCc6J3RoZXRhJywnXFxcXHUwM0QxJzondGhldGF2JywnXFxcXHUwMzk4JzonVGhldGEnLCdcXFxcdTAzQjknOidpb3RhJywnXFxcXHUwMzk5JzonSW90YScsJ1xcXFx1MDNCQSc6J2thcHBhJywnXFxcXHUwM0YwJzona2FwcGF2JywnXFxcXHUwMzlBJzonS2FwcGEnLCdcXFxcdTAzQkInOidsYW1iZGEnLCdcXFxcdTAzOUInOidMYW1iZGEnLCdcXFxcdTAzQkMnOidtdScsJ1xcXFx4QjUnOidtaWNybycsJ1xcXFx1MDM5Qyc6J011JywnXFxcXHUwM0JEJzonbnUnLCdcXFxcdTAzOUQnOidOdScsJ1xcXFx1MDNCRSc6J3hpJywnXFxcXHUwMzlFJzonWGknLCdcXFxcdTAzQkYnOidvbWljcm9uJywnXFxcXHUwMzlGJzonT21pY3JvbicsJ1xcXFx1MDNDMCc6J3BpJywnXFxcXHUwM0Q2JzoncGl2JywnXFxcXHUwM0EwJzonUGknLCdcXFxcdTAzQzEnOidyaG8nLCdcXFxcdTAzRjEnOidyaG92JywnXFxcXHUwM0ExJzonUmhvJywnXFxcXHUwM0MzJzonc2lnbWEnLCdcXFxcdTAzQTMnOidTaWdtYScsJ1xcXFx1MDNDMic6J3NpZ21hZicsJ1xcXFx1MDNDNCc6J3RhdScsJ1xcXFx1MDNBNCc6J1RhdScsJ1xcXFx1MDNDNSc6J3Vwc2knLCdcXFxcdTAzQTUnOidVcHNpbG9uJywnXFxcXHUwM0QyJzonVXBzaScsJ1xcXFx1MDNDNic6J3BoaScsJ1xcXFx1MDNENSc6J3BoaXYnLCdcXFxcdTAzQTYnOidQaGknLCdcXFxcdTAzQzcnOidjaGknLCdcXFxcdTAzQTcnOidDaGknLCdcXFxcdTAzQzgnOidwc2knLCdcXFxcdTAzQTgnOidQc2knLCdcXFxcdTAzQzknOidvbWVnYScsJ1xcXFx1MDNBOSc6J29obScsJ1xcXFx1MDQzMCc6J2FjeScsJ1xcXFx1MDQxMCc6J0FjeScsJ1xcXFx1MDQzMSc6J2JjeScsJ1xcXFx1MDQxMSc6J0JjeScsJ1xcXFx1MDQzMic6J3ZjeScsJ1xcXFx1MDQxMic6J1ZjeScsJ1xcXFx1MDQzMyc6J2djeScsJ1xcXFx1MDQxMyc6J0djeScsJ1xcXFx1MDQ1Myc6J2dqY3knLCdcXFxcdTA0MDMnOidHSmN5JywnXFxcXHUwNDM0JzonZGN5JywnXFxcXHUwNDE0JzonRGN5JywnXFxcXHUwNDUyJzonZGpjeScsJ1xcXFx1MDQwMic6J0RKY3knLCdcXFxcdTA0MzUnOidpZWN5JywnXFxcXHUwNDE1JzonSUVjeScsJ1xcXFx1MDQ1MSc6J2lvY3knLCdcXFxcdTA0MDEnOidJT2N5JywnXFxcXHUwNDU0JzonanVrY3knLCdcXFxcdTA0MDQnOidKdWtjeScsJ1xcXFx1MDQzNic6J3poY3knLCdcXFxcdTA0MTYnOidaSGN5JywnXFxcXHUwNDM3JzonemN5JywnXFxcXHUwNDE3JzonWmN5JywnXFxcXHUwNDU1JzonZHNjeScsJ1xcXFx1MDQwNSc6J0RTY3knLCdcXFxcdTA0MzgnOidpY3knLCdcXFxcdTA0MTgnOidJY3knLCdcXFxcdTA0NTYnOidpdWtjeScsJ1xcXFx1MDQwNic6J0l1a2N5JywnXFxcXHUwNDU3JzoneWljeScsJ1xcXFx1MDQwNyc6J1lJY3knLCdcXFxcdTA0MzknOidqY3knLCdcXFxcdTA0MTknOidKY3knLCdcXFxcdTA0NTgnOidqc2VyY3knLCdcXFxcdTA0MDgnOidKc2VyY3knLCdcXFxcdTA0M0EnOidrY3knLCdcXFxcdTA0MUEnOidLY3knLCdcXFxcdTA0NUMnOidramN5JywnXFxcXHUwNDBDJzonS0pjeScsJ1xcXFx1MDQzQic6J2xjeScsJ1xcXFx1MDQxQic6J0xjeScsJ1xcXFx1MDQ1OSc6J2xqY3knLCdcXFxcdTA0MDknOidMSmN5JywnXFxcXHUwNDNDJzonbWN5JywnXFxcXHUwNDFDJzonTWN5JywnXFxcXHUwNDNEJzonbmN5JywnXFxcXHUwNDFEJzonTmN5JywnXFxcXHUwNDVBJzonbmpjeScsJ1xcXFx1MDQwQSc6J05KY3knLCdcXFxcdTA0M0UnOidvY3knLCdcXFxcdTA0MUUnOidPY3knLCdcXFxcdTA0M0YnOidwY3knLCdcXFxcdTA0MUYnOidQY3knLCdcXFxcdTA0NDAnOidyY3knLCdcXFxcdTA0MjAnOidSY3knLCdcXFxcdTA0NDEnOidzY3knLCdcXFxcdTA0MjEnOidTY3knLCdcXFxcdTA0NDInOid0Y3knLCdcXFxcdTA0MjInOidUY3knLCdcXFxcdTA0NUInOid0c2hjeScsJ1xcXFx1MDQwQic6J1RTSGN5JywnXFxcXHUwNDQzJzondWN5JywnXFxcXHUwNDIzJzonVWN5JywnXFxcXHUwNDVFJzondWJyY3knLCdcXFxcdTA0MEUnOidVYnJjeScsJ1xcXFx1MDQ0NCc6J2ZjeScsJ1xcXFx1MDQyNCc6J0ZjeScsJ1xcXFx1MDQ0NSc6J2toY3knLCdcXFxcdTA0MjUnOidLSGN5JywnXFxcXHUwNDQ2JzondHNjeScsJ1xcXFx1MDQyNic6J1RTY3knLCdcXFxcdTA0NDcnOidjaGN5JywnXFxcXHUwNDI3JzonQ0hjeScsJ1xcXFx1MDQ1Ric6J2R6Y3knLCdcXFxcdTA0MEYnOidEWmN5JywnXFxcXHUwNDQ4Jzonc2hjeScsJ1xcXFx1MDQyOCc6J1NIY3knLCdcXFxcdTA0NDknOidzaGNoY3knLCdcXFxcdTA0MjknOidTSENIY3knLCdcXFxcdTA0NEEnOidoYXJkY3knLCdcXFxcdTA0MkEnOidIQVJEY3knLCdcXFxcdTA0NEInOid5Y3knLCdcXFxcdTA0MkInOidZY3knLCdcXFxcdTA0NEMnOidzb2Z0Y3knLCdcXFxcdTA0MkMnOidTT0ZUY3knLCdcXFxcdTA0NEQnOidlY3knLCdcXFxcdTA0MkQnOidFY3knLCdcXFxcdTA0NEUnOid5dWN5JywnXFxcXHUwNDJFJzonWVVjeScsJ1xcXFx1MDQ0Ric6J3lhY3knLCdcXFxcdTA0MkYnOidZQWN5JywnXFxcXHUyMTM1JzonYWxlcGgnLCdcXFxcdTIxMzYnOidiZXRoJywnXFxcXHUyMTM3JzonZ2ltZWwnLCdcXFxcdTIxMzgnOidkYWxldGgnfTtcXG5cXG5cXHR2YXIgcmVnZXhFc2NhcGUgPSAvW1xcXCImJzw+YF0vZztcXG5cXHR2YXIgZXNjYXBlTWFwID0ge1xcblxcdFxcdCdcXFwiJzogJyZxdW90OycsXFxuXFx0XFx0JyYnOiAnJmFtcDsnLFxcblxcdFxcdCdcXFxcJyc6ICcmI3gyNzsnLFxcblxcdFxcdCc8JzogJyZsdDsnLFxcblxcdFxcdC8vIFNlZSBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHM6IGluIEhUTUwsIHRoZVxcblxcdFxcdC8vIGZvbGxvd2luZyBpcyBub3Qgc3RyaWN0bHkgbmVjZXNzYXJ5IHVubGVzcyBpdOKAmXMgcGFydCBvZiBhIHRhZyBvciBhblxcblxcdFxcdC8vIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS4gV2XigJlyZSBvbmx5IGVzY2FwaW5nIGl0IHRvIHN1cHBvcnQgdGhvc2VcXG5cXHRcXHQvLyBzaXR1YXRpb25zLCBhbmQgZm9yIFhNTCBzdXBwb3J0LlxcblxcdFxcdCc+JzogJyZndDsnLFxcblxcdFxcdC8vIEluIEludGVybmV0IEV4cGxvcmVyIOKJpCA4LCB0aGUgYmFja3RpY2sgY2hhcmFjdGVyIGNhbiBiZSB1c2VkXFxuXFx0XFx0Ly8gdG8gYnJlYWsgb3V0IG9mICh1bilxdW90ZWQgYXR0cmlidXRlIHZhbHVlcyBvciBIVE1MIGNvbW1lbnRzLlxcblxcdFxcdC8vIFNlZSBodHRwOi8vaHRtbDVzZWMub3JnLyMxMDIsIGh0dHA6Ly9odG1sNXNlYy5vcmcvIzEwOCwgYW5kXFxuXFx0XFx0Ly8gaHR0cDovL2h0bWw1c2VjLm9yZy8jMTMzLlxcblxcdFxcdCdgJzogJyYjeDYwOydcXG5cXHR9O1xcblxcblxcdHZhciByZWdleEludmFsaWRFbnRpdHkgPSAvJiMoPzpbeFhdW15hLWZBLUYwLTldfFteMC05eFhdKS87XFxuXFx0dmFyIHJlZ2V4SW52YWxpZFJhd0NvZGVQb2ludCA9IC9bXFxcXDAtXFxcXHgwOFxcXFx4MEJcXFxceDBFLVxcXFx4MUZcXFxceDdGLVxcXFx4OUZcXFxcdUZERDAtXFxcXHVGREVGXFxcXHVGRkZFXFxcXHVGRkZGXXxbXFxcXHVEODNGXFxcXHVEODdGXFxcXHVEOEJGXFxcXHVEOEZGXFxcXHVEOTNGXFxcXHVEOTdGXFxcXHVEOUJGXFxcXHVEOUZGXFxcXHVEQTNGXFxcXHVEQTdGXFxcXHVEQUJGXFxcXHVEQUZGXFxcXHVEQjNGXFxcXHVEQjdGXFxcXHVEQkJGXFxcXHVEQkZGXVtcXFxcdURGRkVcXFxcdURGRkZdfFtcXFxcdUQ4MDAtXFxcXHVEQkZGXSg/IVtcXFxcdURDMDAtXFxcXHVERkZGXSl8KD86W15cXFxcdUQ4MDAtXFxcXHVEQkZGXXxeKVtcXFxcdURDMDAtXFxcXHVERkZGXS87XFxuXFx0dmFyIHJlZ2V4RGVjb2RlID0gLyYjKFswLTldKykoOz8pfCYjW3hYXShbYS1mQS1GMC05XSspKDs/KXwmKFswLTlhLXpBLVpdKyk7fCYoQWFjdXRlfEFncmF2ZXxBdGlsZGV8Q2NlZGlsfEVhY3V0ZXxFZ3JhdmV8SWFjdXRlfElncmF2ZXxOdGlsZGV8T2FjdXRlfE9ncmF2ZXxPc2xhc2h8T3RpbGRlfFVhY3V0ZXxVZ3JhdmV8WWFjdXRlfGFhY3V0ZXxhZ3JhdmV8YXRpbGRlfGJydmJhcnxjY2VkaWx8Y3VycmVufGRpdmlkZXxlYWN1dGV8ZWdyYXZlfGZyYWMxMnxmcmFjMTR8ZnJhYzM0fGlhY3V0ZXxpZ3JhdmV8aXF1ZXN0fG1pZGRvdHxudGlsZGV8b2FjdXRlfG9ncmF2ZXxvc2xhc2h8b3RpbGRlfHBsdXNtbnx1YWN1dGV8dWdyYXZlfHlhY3V0ZXxBRWxpZ3xBY2lyY3xBcmluZ3xFY2lyY3xJY2lyY3xPY2lyY3xUSE9STnxVY2lyY3xhY2lyY3xhY3V0ZXxhZWxpZ3xhcmluZ3xjZWRpbHxlY2lyY3xpY2lyY3xpZXhjbHxsYXF1b3xtaWNyb3xvY2lyY3xwb3VuZHxyYXF1b3xzemxpZ3x0aG9ybnx0aW1lc3x1Y2lyY3xBdW1sfENPUFl8RXVtbHxJdW1sfE91bWx8UVVPVHxVdW1sfGF1bWx8Y2VudHxjb3B5fGV1bWx8aXVtbHxtYWNyfG5ic3B8b3JkZnxvcmRtfG91bWx8cGFyYXxxdW90fHNlY3R8c3VwMXxzdXAyfHN1cDN8dXVtbHx5dW1sfEFNUHxFVEh8UkVHfGFtcHxkZWd8ZXRofG5vdHxyZWd8c2h5fHVtbHx5ZW58R1R8TFR8Z3R8bHQpKFs9YS16QS1aMC05XSk/L2c7XFxuXFx0dmFyIGRlY29kZU1hcCA9IHsnYWFjdXRlJzonXFxcXHhFMScsJ0FhY3V0ZSc6J1xcXFx4QzEnLCdhYnJldmUnOidcXFxcdTAxMDMnLCdBYnJldmUnOidcXFxcdTAxMDInLCdhYyc6J1xcXFx1MjIzRScsJ2FjZCc6J1xcXFx1MjIzRicsJ2FjRSc6J1xcXFx1MjIzRVxcXFx1MDMzMycsJ2FjaXJjJzonXFxcXHhFMicsJ0FjaXJjJzonXFxcXHhDMicsJ2FjdXRlJzonXFxcXHhCNCcsJ2FjeSc6J1xcXFx1MDQzMCcsJ0FjeSc6J1xcXFx1MDQxMCcsJ2FlbGlnJzonXFxcXHhFNicsJ0FFbGlnJzonXFxcXHhDNicsJ2FmJzonXFxcXHUyMDYxJywnYWZyJzonXFxcXHVEODM1XFxcXHVERDFFJywnQWZyJzonXFxcXHVEODM1XFxcXHVERDA0JywnYWdyYXZlJzonXFxcXHhFMCcsJ0FncmF2ZSc6J1xcXFx4QzAnLCdhbGVmc3ltJzonXFxcXHUyMTM1JywnYWxlcGgnOidcXFxcdTIxMzUnLCdhbHBoYSc6J1xcXFx1MDNCMScsJ0FscGhhJzonXFxcXHUwMzkxJywnYW1hY3InOidcXFxcdTAxMDEnLCdBbWFjcic6J1xcXFx1MDEwMCcsJ2FtYWxnJzonXFxcXHUyQTNGJywnYW1wJzonJicsJ0FNUCc6JyYnLCdhbmQnOidcXFxcdTIyMjcnLCdBbmQnOidcXFxcdTJBNTMnLCdhbmRhbmQnOidcXFxcdTJBNTUnLCdhbmRkJzonXFxcXHUyQTVDJywnYW5kc2xvcGUnOidcXFxcdTJBNTgnLCdhbmR2JzonXFxcXHUyQTVBJywnYW5nJzonXFxcXHUyMjIwJywnYW5nZSc6J1xcXFx1MjlBNCcsJ2FuZ2xlJzonXFxcXHUyMjIwJywnYW5nbXNkJzonXFxcXHUyMjIxJywnYW5nbXNkYWEnOidcXFxcdTI5QTgnLCdhbmdtc2RhYic6J1xcXFx1MjlBOScsJ2FuZ21zZGFjJzonXFxcXHUyOUFBJywnYW5nbXNkYWQnOidcXFxcdTI5QUInLCdhbmdtc2RhZSc6J1xcXFx1MjlBQycsJ2FuZ21zZGFmJzonXFxcXHUyOUFEJywnYW5nbXNkYWcnOidcXFxcdTI5QUUnLCdhbmdtc2RhaCc6J1xcXFx1MjlBRicsJ2FuZ3J0JzonXFxcXHUyMjFGJywnYW5ncnR2Yic6J1xcXFx1MjJCRScsJ2FuZ3J0dmJkJzonXFxcXHUyOTlEJywnYW5nc3BoJzonXFxcXHUyMjIyJywnYW5nc3QnOidcXFxceEM1JywnYW5nemFycic6J1xcXFx1MjM3QycsJ2FvZ29uJzonXFxcXHUwMTA1JywnQW9nb24nOidcXFxcdTAxMDQnLCdhb3BmJzonXFxcXHVEODM1XFxcXHVERDUyJywnQW9wZic6J1xcXFx1RDgzNVxcXFx1REQzOCcsJ2FwJzonXFxcXHUyMjQ4JywnYXBhY2lyJzonXFxcXHUyQTZGJywnYXBlJzonXFxcXHUyMjRBJywnYXBFJzonXFxcXHUyQTcwJywnYXBpZCc6J1xcXFx1MjI0QicsJ2Fwb3MnOidcXFxcJycsJ0FwcGx5RnVuY3Rpb24nOidcXFxcdTIwNjEnLCdhcHByb3gnOidcXFxcdTIyNDgnLCdhcHByb3hlcSc6J1xcXFx1MjI0QScsJ2FyaW5nJzonXFxcXHhFNScsJ0FyaW5nJzonXFxcXHhDNScsJ2FzY3InOidcXFxcdUQ4MzVcXFxcdURDQjYnLCdBc2NyJzonXFxcXHVEODM1XFxcXHVEQzlDJywnQXNzaWduJzonXFxcXHUyMjU0JywnYXN0JzonKicsJ2FzeW1wJzonXFxcXHUyMjQ4JywnYXN5bXBlcSc6J1xcXFx1MjI0RCcsJ2F0aWxkZSc6J1xcXFx4RTMnLCdBdGlsZGUnOidcXFxceEMzJywnYXVtbCc6J1xcXFx4RTQnLCdBdW1sJzonXFxcXHhDNCcsJ2F3Y29uaW50JzonXFxcXHUyMjMzJywnYXdpbnQnOidcXFxcdTJBMTEnLCdiYWNrY29uZyc6J1xcXFx1MjI0QycsJ2JhY2tlcHNpbG9uJzonXFxcXHUwM0Y2JywnYmFja3ByaW1lJzonXFxcXHUyMDM1JywnYmFja3NpbSc6J1xcXFx1MjIzRCcsJ2JhY2tzaW1lcSc6J1xcXFx1MjJDRCcsJ0JhY2tzbGFzaCc6J1xcXFx1MjIxNicsJ0JhcnYnOidcXFxcdTJBRTcnLCdiYXJ2ZWUnOidcXFxcdTIyQkQnLCdiYXJ3ZWQnOidcXFxcdTIzMDUnLCdCYXJ3ZWQnOidcXFxcdTIzMDYnLCdiYXJ3ZWRnZSc6J1xcXFx1MjMwNScsJ2JicmsnOidcXFxcdTIzQjUnLCdiYnJrdGJyayc6J1xcXFx1MjNCNicsJ2Jjb25nJzonXFxcXHUyMjRDJywnYmN5JzonXFxcXHUwNDMxJywnQmN5JzonXFxcXHUwNDExJywnYmRxdW8nOidcXFxcdTIwMUUnLCdiZWNhdXMnOidcXFxcdTIyMzUnLCdiZWNhdXNlJzonXFxcXHUyMjM1JywnQmVjYXVzZSc6J1xcXFx1MjIzNScsJ2JlbXB0eXYnOidcXFxcdTI5QjAnLCdiZXBzaSc6J1xcXFx1MDNGNicsJ2Jlcm5vdSc6J1xcXFx1MjEyQycsJ0Jlcm5vdWxsaXMnOidcXFxcdTIxMkMnLCdiZXRhJzonXFxcXHUwM0IyJywnQmV0YSc6J1xcXFx1MDM5MicsJ2JldGgnOidcXFxcdTIxMzYnLCdiZXR3ZWVuJzonXFxcXHUyMjZDJywnYmZyJzonXFxcXHVEODM1XFxcXHVERDFGJywnQmZyJzonXFxcXHVEODM1XFxcXHVERDA1JywnYmlnY2FwJzonXFxcXHUyMkMyJywnYmlnY2lyYyc6J1xcXFx1MjVFRicsJ2JpZ2N1cCc6J1xcXFx1MjJDMycsJ2JpZ29kb3QnOidcXFxcdTJBMDAnLCdiaWdvcGx1cyc6J1xcXFx1MkEwMScsJ2JpZ290aW1lcyc6J1xcXFx1MkEwMicsJ2JpZ3NxY3VwJzonXFxcXHUyQTA2JywnYmlnc3Rhcic6J1xcXFx1MjYwNScsJ2JpZ3RyaWFuZ2xlZG93bic6J1xcXFx1MjVCRCcsJ2JpZ3RyaWFuZ2xldXAnOidcXFxcdTI1QjMnLCdiaWd1cGx1cyc6J1xcXFx1MkEwNCcsJ2JpZ3ZlZSc6J1xcXFx1MjJDMScsJ2JpZ3dlZGdlJzonXFxcXHUyMkMwJywnYmthcm93JzonXFxcXHUyOTBEJywnYmxhY2tsb3plbmdlJzonXFxcXHUyOUVCJywnYmxhY2tzcXVhcmUnOidcXFxcdTI1QUEnLCdibGFja3RyaWFuZ2xlJzonXFxcXHUyNUI0JywnYmxhY2t0cmlhbmdsZWRvd24nOidcXFxcdTI1QkUnLCdibGFja3RyaWFuZ2xlbGVmdCc6J1xcXFx1MjVDMicsJ2JsYWNrdHJpYW5nbGVyaWdodCc6J1xcXFx1MjVCOCcsJ2JsYW5rJzonXFxcXHUyNDIzJywnYmxrMTInOidcXFxcdTI1OTInLCdibGsxNCc6J1xcXFx1MjU5MScsJ2JsazM0JzonXFxcXHUyNTkzJywnYmxvY2snOidcXFxcdTI1ODgnLCdibmUnOic9XFxcXHUyMEU1JywnYm5lcXVpdic6J1xcXFx1MjI2MVxcXFx1MjBFNScsJ2Jub3QnOidcXFxcdTIzMTAnLCdiTm90JzonXFxcXHUyQUVEJywnYm9wZic6J1xcXFx1RDgzNVxcXFx1REQ1MycsJ0JvcGYnOidcXFxcdUQ4MzVcXFxcdUREMzknLCdib3QnOidcXFxcdTIyQTUnLCdib3R0b20nOidcXFxcdTIyQTUnLCdib3d0aWUnOidcXFxcdTIyQzgnLCdib3hib3gnOidcXFxcdTI5QzknLCdib3hkbCc6J1xcXFx1MjUxMCcsJ2JveGRMJzonXFxcXHUyNTU1JywnYm94RGwnOidcXFxcdTI1NTYnLCdib3hETCc6J1xcXFx1MjU1NycsJ2JveGRyJzonXFxcXHUyNTBDJywnYm94ZFInOidcXFxcdTI1NTInLCdib3hEcic6J1xcXFx1MjU1MycsJ2JveERSJzonXFxcXHUyNTU0JywnYm94aCc6J1xcXFx1MjUwMCcsJ2JveEgnOidcXFxcdTI1NTAnLCdib3hoZCc6J1xcXFx1MjUyQycsJ2JveGhEJzonXFxcXHUyNTY1JywnYm94SGQnOidcXFxcdTI1NjQnLCdib3hIRCc6J1xcXFx1MjU2NicsJ2JveGh1JzonXFxcXHUyNTM0JywnYm94aFUnOidcXFxcdTI1NjgnLCdib3hIdSc6J1xcXFx1MjU2NycsJ2JveEhVJzonXFxcXHUyNTY5JywnYm94bWludXMnOidcXFxcdTIyOUYnLCdib3hwbHVzJzonXFxcXHUyMjlFJywnYm94dGltZXMnOidcXFxcdTIyQTAnLCdib3h1bCc6J1xcXFx1MjUxOCcsJ2JveHVMJzonXFxcXHUyNTVCJywnYm94VWwnOidcXFxcdTI1NUMnLCdib3hVTCc6J1xcXFx1MjU1RCcsJ2JveHVyJzonXFxcXHUyNTE0JywnYm94dVInOidcXFxcdTI1NTgnLCdib3hVcic6J1xcXFx1MjU1OScsJ2JveFVSJzonXFxcXHUyNTVBJywnYm94dic6J1xcXFx1MjUwMicsJ2JveFYnOidcXFxcdTI1NTEnLCdib3h2aCc6J1xcXFx1MjUzQycsJ2JveHZIJzonXFxcXHUyNTZBJywnYm94VmgnOidcXFxcdTI1NkInLCdib3hWSCc6J1xcXFx1MjU2QycsJ2JveHZsJzonXFxcXHUyNTI0JywnYm94dkwnOidcXFxcdTI1NjEnLCdib3hWbCc6J1xcXFx1MjU2MicsJ2JveFZMJzonXFxcXHUyNTYzJywnYm94dnInOidcXFxcdTI1MUMnLCdib3h2Uic6J1xcXFx1MjU1RScsJ2JveFZyJzonXFxcXHUyNTVGJywnYm94VlInOidcXFxcdTI1NjAnLCdicHJpbWUnOidcXFxcdTIwMzUnLCdicmV2ZSc6J1xcXFx1MDJEOCcsJ0JyZXZlJzonXFxcXHUwMkQ4JywnYnJ2YmFyJzonXFxcXHhBNicsJ2JzY3InOidcXFxcdUQ4MzVcXFxcdURDQjcnLCdCc2NyJzonXFxcXHUyMTJDJywnYnNlbWknOidcXFxcdTIwNEYnLCdic2ltJzonXFxcXHUyMjNEJywnYnNpbWUnOidcXFxcdTIyQ0QnLCdic29sJzonXFxcXFxcXFwnLCdic29sYic6J1xcXFx1MjlDNScsJ2Jzb2xoc3ViJzonXFxcXHUyN0M4JywnYnVsbCc6J1xcXFx1MjAyMicsJ2J1bGxldCc6J1xcXFx1MjAyMicsJ2J1bXAnOidcXFxcdTIyNEUnLCdidW1wZSc6J1xcXFx1MjI0RicsJ2J1bXBFJzonXFxcXHUyQUFFJywnYnVtcGVxJzonXFxcXHUyMjRGJywnQnVtcGVxJzonXFxcXHUyMjRFJywnY2FjdXRlJzonXFxcXHUwMTA3JywnQ2FjdXRlJzonXFxcXHUwMTA2JywnY2FwJzonXFxcXHUyMjI5JywnQ2FwJzonXFxcXHUyMkQyJywnY2FwYW5kJzonXFxcXHUyQTQ0JywnY2FwYnJjdXAnOidcXFxcdTJBNDknLCdjYXBjYXAnOidcXFxcdTJBNEInLCdjYXBjdXAnOidcXFxcdTJBNDcnLCdjYXBkb3QnOidcXFxcdTJBNDAnLCdDYXBpdGFsRGlmZmVyZW50aWFsRCc6J1xcXFx1MjE0NScsJ2NhcHMnOidcXFxcdTIyMjlcXFxcdUZFMDAnLCdjYXJldCc6J1xcXFx1MjA0MScsJ2Nhcm9uJzonXFxcXHUwMkM3JywnQ2F5bGV5cyc6J1xcXFx1MjEyRCcsJ2NjYXBzJzonXFxcXHUyQTREJywnY2Nhcm9uJzonXFxcXHUwMTBEJywnQ2Nhcm9uJzonXFxcXHUwMTBDJywnY2NlZGlsJzonXFxcXHhFNycsJ0NjZWRpbCc6J1xcXFx4QzcnLCdjY2lyYyc6J1xcXFx1MDEwOScsJ0NjaXJjJzonXFxcXHUwMTA4JywnQ2NvbmludCc6J1xcXFx1MjIzMCcsJ2NjdXBzJzonXFxcXHUyQTRDJywnY2N1cHNzbSc6J1xcXFx1MkE1MCcsJ2Nkb3QnOidcXFxcdTAxMEInLCdDZG90JzonXFxcXHUwMTBBJywnY2VkaWwnOidcXFxceEI4JywnQ2VkaWxsYSc6J1xcXFx4QjgnLCdjZW1wdHl2JzonXFxcXHUyOUIyJywnY2VudCc6J1xcXFx4QTInLCdjZW50ZXJkb3QnOidcXFxceEI3JywnQ2VudGVyRG90JzonXFxcXHhCNycsJ2Nmcic6J1xcXFx1RDgzNVxcXFx1REQyMCcsJ0Nmcic6J1xcXFx1MjEyRCcsJ2NoY3knOidcXFxcdTA0NDcnLCdDSGN5JzonXFxcXHUwNDI3JywnY2hlY2snOidcXFxcdTI3MTMnLCdjaGVja21hcmsnOidcXFxcdTI3MTMnLCdjaGknOidcXFxcdTAzQzcnLCdDaGknOidcXFxcdTAzQTcnLCdjaXInOidcXFxcdTI1Q0InLCdjaXJjJzonXFxcXHUwMkM2JywnY2lyY2VxJzonXFxcXHUyMjU3JywnY2lyY2xlYXJyb3dsZWZ0JzonXFxcXHUyMUJBJywnY2lyY2xlYXJyb3dyaWdodCc6J1xcXFx1MjFCQicsJ2NpcmNsZWRhc3QnOidcXFxcdTIyOUInLCdjaXJjbGVkY2lyYyc6J1xcXFx1MjI5QScsJ2NpcmNsZWRkYXNoJzonXFxcXHUyMjlEJywnQ2lyY2xlRG90JzonXFxcXHUyMjk5JywnY2lyY2xlZFInOidcXFxceEFFJywnY2lyY2xlZFMnOidcXFxcdTI0QzgnLCdDaXJjbGVNaW51cyc6J1xcXFx1MjI5NicsJ0NpcmNsZVBsdXMnOidcXFxcdTIyOTUnLCdDaXJjbGVUaW1lcyc6J1xcXFx1MjI5NycsJ2NpcmUnOidcXFxcdTIyNTcnLCdjaXJFJzonXFxcXHUyOUMzJywnY2lyZm5pbnQnOidcXFxcdTJBMTAnLCdjaXJtaWQnOidcXFxcdTJBRUYnLCdjaXJzY2lyJzonXFxcXHUyOUMyJywnQ2xvY2t3aXNlQ29udG91ckludGVncmFsJzonXFxcXHUyMjMyJywnQ2xvc2VDdXJseURvdWJsZVF1b3RlJzonXFxcXHUyMDFEJywnQ2xvc2VDdXJseVF1b3RlJzonXFxcXHUyMDE5JywnY2x1YnMnOidcXFxcdTI2NjMnLCdjbHVic3VpdCc6J1xcXFx1MjY2MycsJ2NvbG9uJzonOicsJ0NvbG9uJzonXFxcXHUyMjM3JywnY29sb25lJzonXFxcXHUyMjU0JywnQ29sb25lJzonXFxcXHUyQTc0JywnY29sb25lcSc6J1xcXFx1MjI1NCcsJ2NvbW1hJzonLCcsJ2NvbW1hdCc6J0AnLCdjb21wJzonXFxcXHUyMjAxJywnY29tcGZuJzonXFxcXHUyMjE4JywnY29tcGxlbWVudCc6J1xcXFx1MjIwMScsJ2NvbXBsZXhlcyc6J1xcXFx1MjEwMicsJ2NvbmcnOidcXFxcdTIyNDUnLCdjb25nZG90JzonXFxcXHUyQTZEJywnQ29uZ3J1ZW50JzonXFxcXHUyMjYxJywnY29uaW50JzonXFxcXHUyMjJFJywnQ29uaW50JzonXFxcXHUyMjJGJywnQ29udG91ckludGVncmFsJzonXFxcXHUyMjJFJywnY29wZic6J1xcXFx1RDgzNVxcXFx1REQ1NCcsJ0NvcGYnOidcXFxcdTIxMDInLCdjb3Byb2QnOidcXFxcdTIyMTAnLCdDb3Byb2R1Y3QnOidcXFxcdTIyMTAnLCdjb3B5JzonXFxcXHhBOScsJ0NPUFknOidcXFxceEE5JywnY29weXNyJzonXFxcXHUyMTE3JywnQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCc6J1xcXFx1MjIzMycsJ2NyYXJyJzonXFxcXHUyMUI1JywnY3Jvc3MnOidcXFxcdTI3MTcnLCdDcm9zcyc6J1xcXFx1MkEyRicsJ2NzY3InOidcXFxcdUQ4MzVcXFxcdURDQjgnLCdDc2NyJzonXFxcXHVEODM1XFxcXHVEQzlFJywnY3N1Yic6J1xcXFx1MkFDRicsJ2NzdWJlJzonXFxcXHUyQUQxJywnY3N1cCc6J1xcXFx1MkFEMCcsJ2NzdXBlJzonXFxcXHUyQUQyJywnY3Rkb3QnOidcXFxcdTIyRUYnLCdjdWRhcnJsJzonXFxcXHUyOTM4JywnY3VkYXJycic6J1xcXFx1MjkzNScsJ2N1ZXByJzonXFxcXHUyMkRFJywnY3Vlc2MnOidcXFxcdTIyREYnLCdjdWxhcnInOidcXFxcdTIxQjYnLCdjdWxhcnJwJzonXFxcXHUyOTNEJywnY3VwJzonXFxcXHUyMjJBJywnQ3VwJzonXFxcXHUyMkQzJywnY3VwYnJjYXAnOidcXFxcdTJBNDgnLCdjdXBjYXAnOidcXFxcdTJBNDYnLCdDdXBDYXAnOidcXFxcdTIyNEQnLCdjdXBjdXAnOidcXFxcdTJBNEEnLCdjdXBkb3QnOidcXFxcdTIyOEQnLCdjdXBvcic6J1xcXFx1MkE0NScsJ2N1cHMnOidcXFxcdTIyMkFcXFxcdUZFMDAnLCdjdXJhcnInOidcXFxcdTIxQjcnLCdjdXJhcnJtJzonXFxcXHUyOTNDJywnY3VybHllcXByZWMnOidcXFxcdTIyREUnLCdjdXJseWVxc3VjYyc6J1xcXFx1MjJERicsJ2N1cmx5dmVlJzonXFxcXHUyMkNFJywnY3VybHl3ZWRnZSc6J1xcXFx1MjJDRicsJ2N1cnJlbic6J1xcXFx4QTQnLCdjdXJ2ZWFycm93bGVmdCc6J1xcXFx1MjFCNicsJ2N1cnZlYXJyb3dyaWdodCc6J1xcXFx1MjFCNycsJ2N1dmVlJzonXFxcXHUyMkNFJywnY3V3ZWQnOidcXFxcdTIyQ0YnLCdjd2NvbmludCc6J1xcXFx1MjIzMicsJ2N3aW50JzonXFxcXHUyMjMxJywnY3lsY3R5JzonXFxcXHUyMzJEJywnZGFnZ2VyJzonXFxcXHUyMDIwJywnRGFnZ2VyJzonXFxcXHUyMDIxJywnZGFsZXRoJzonXFxcXHUyMTM4JywnZGFycic6J1xcXFx1MjE5MycsJ2RBcnInOidcXFxcdTIxRDMnLCdEYXJyJzonXFxcXHUyMUExJywnZGFzaCc6J1xcXFx1MjAxMCcsJ2Rhc2h2JzonXFxcXHUyMkEzJywnRGFzaHYnOidcXFxcdTJBRTQnLCdkYmthcm93JzonXFxcXHUyOTBGJywnZGJsYWMnOidcXFxcdTAyREQnLCdkY2Fyb24nOidcXFxcdTAxMEYnLCdEY2Fyb24nOidcXFxcdTAxMEUnLCdkY3knOidcXFxcdTA0MzQnLCdEY3knOidcXFxcdTA0MTQnLCdkZCc6J1xcXFx1MjE0NicsJ0REJzonXFxcXHUyMTQ1JywnZGRhZ2dlcic6J1xcXFx1MjAyMScsJ2RkYXJyJzonXFxcXHUyMUNBJywnRERvdHJhaGQnOidcXFxcdTI5MTEnLCdkZG90c2VxJzonXFxcXHUyQTc3JywnZGVnJzonXFxcXHhCMCcsJ0RlbCc6J1xcXFx1MjIwNycsJ2RlbHRhJzonXFxcXHUwM0I0JywnRGVsdGEnOidcXFxcdTAzOTQnLCdkZW1wdHl2JzonXFxcXHUyOUIxJywnZGZpc2h0JzonXFxcXHUyOTdGJywnZGZyJzonXFxcXHVEODM1XFxcXHVERDIxJywnRGZyJzonXFxcXHVEODM1XFxcXHVERDA3JywnZEhhcic6J1xcXFx1Mjk2NScsJ2RoYXJsJzonXFxcXHUyMUMzJywnZGhhcnInOidcXFxcdTIxQzInLCdEaWFjcml0aWNhbEFjdXRlJzonXFxcXHhCNCcsJ0RpYWNyaXRpY2FsRG90JzonXFxcXHUwMkQ5JywnRGlhY3JpdGljYWxEb3VibGVBY3V0ZSc6J1xcXFx1MDJERCcsJ0RpYWNyaXRpY2FsR3JhdmUnOidgJywnRGlhY3JpdGljYWxUaWxkZSc6J1xcXFx1MDJEQycsJ2RpYW0nOidcXFxcdTIyQzQnLCdkaWFtb25kJzonXFxcXHUyMkM0JywnRGlhbW9uZCc6J1xcXFx1MjJDNCcsJ2RpYW1vbmRzdWl0JzonXFxcXHUyNjY2JywnZGlhbXMnOidcXFxcdTI2NjYnLCdkaWUnOidcXFxceEE4JywnRGlmZmVyZW50aWFsRCc6J1xcXFx1MjE0NicsJ2RpZ2FtbWEnOidcXFxcdTAzREQnLCdkaXNpbic6J1xcXFx1MjJGMicsJ2Rpdic6J1xcXFx4RjcnLCdkaXZpZGUnOidcXFxceEY3JywnZGl2aWRlb250aW1lcyc6J1xcXFx1MjJDNycsJ2Rpdm9ueCc6J1xcXFx1MjJDNycsJ2RqY3knOidcXFxcdTA0NTInLCdESmN5JzonXFxcXHUwNDAyJywnZGxjb3JuJzonXFxcXHUyMzFFJywnZGxjcm9wJzonXFxcXHUyMzBEJywnZG9sbGFyJzonJCcsJ2RvcGYnOidcXFxcdUQ4MzVcXFxcdURENTUnLCdEb3BmJzonXFxcXHVEODM1XFxcXHVERDNCJywnZG90JzonXFxcXHUwMkQ5JywnRG90JzonXFxcXHhBOCcsJ0RvdERvdCc6J1xcXFx1MjBEQycsJ2RvdGVxJzonXFxcXHUyMjUwJywnZG90ZXFkb3QnOidcXFxcdTIyNTEnLCdEb3RFcXVhbCc6J1xcXFx1MjI1MCcsJ2RvdG1pbnVzJzonXFxcXHUyMjM4JywnZG90cGx1cyc6J1xcXFx1MjIxNCcsJ2RvdHNxdWFyZSc6J1xcXFx1MjJBMScsJ2RvdWJsZWJhcndlZGdlJzonXFxcXHUyMzA2JywnRG91YmxlQ29udG91ckludGVncmFsJzonXFxcXHUyMjJGJywnRG91YmxlRG90JzonXFxcXHhBOCcsJ0RvdWJsZURvd25BcnJvdyc6J1xcXFx1MjFEMycsJ0RvdWJsZUxlZnRBcnJvdyc6J1xcXFx1MjFEMCcsJ0RvdWJsZUxlZnRSaWdodEFycm93JzonXFxcXHUyMUQ0JywnRG91YmxlTGVmdFRlZSc6J1xcXFx1MkFFNCcsJ0RvdWJsZUxvbmdMZWZ0QXJyb3cnOidcXFxcdTI3RjgnLCdEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3cnOidcXFxcdTI3RkEnLCdEb3VibGVMb25nUmlnaHRBcnJvdyc6J1xcXFx1MjdGOScsJ0RvdWJsZVJpZ2h0QXJyb3cnOidcXFxcdTIxRDInLCdEb3VibGVSaWdodFRlZSc6J1xcXFx1MjJBOCcsJ0RvdWJsZVVwQXJyb3cnOidcXFxcdTIxRDEnLCdEb3VibGVVcERvd25BcnJvdyc6J1xcXFx1MjFENScsJ0RvdWJsZVZlcnRpY2FsQmFyJzonXFxcXHUyMjI1JywnZG93bmFycm93JzonXFxcXHUyMTkzJywnRG93bmFycm93JzonXFxcXHUyMUQzJywnRG93bkFycm93JzonXFxcXHUyMTkzJywnRG93bkFycm93QmFyJzonXFxcXHUyOTEzJywnRG93bkFycm93VXBBcnJvdyc6J1xcXFx1MjFGNScsJ0Rvd25CcmV2ZSc6J1xcXFx1MDMxMScsJ2Rvd25kb3duYXJyb3dzJzonXFxcXHUyMUNBJywnZG93bmhhcnBvb25sZWZ0JzonXFxcXHUyMUMzJywnZG93bmhhcnBvb25yaWdodCc6J1xcXFx1MjFDMicsJ0Rvd25MZWZ0UmlnaHRWZWN0b3InOidcXFxcdTI5NTAnLCdEb3duTGVmdFRlZVZlY3Rvcic6J1xcXFx1Mjk1RScsJ0Rvd25MZWZ0VmVjdG9yJzonXFxcXHUyMUJEJywnRG93bkxlZnRWZWN0b3JCYXInOidcXFxcdTI5NTYnLCdEb3duUmlnaHRUZWVWZWN0b3InOidcXFxcdTI5NUYnLCdEb3duUmlnaHRWZWN0b3InOidcXFxcdTIxQzEnLCdEb3duUmlnaHRWZWN0b3JCYXInOidcXFxcdTI5NTcnLCdEb3duVGVlJzonXFxcXHUyMkE0JywnRG93blRlZUFycm93JzonXFxcXHUyMUE3JywnZHJia2Fyb3cnOidcXFxcdTI5MTAnLCdkcmNvcm4nOidcXFxcdTIzMUYnLCdkcmNyb3AnOidcXFxcdTIzMEMnLCdkc2NyJzonXFxcXHVEODM1XFxcXHVEQ0I5JywnRHNjcic6J1xcXFx1RDgzNVxcXFx1REM5RicsJ2RzY3knOidcXFxcdTA0NTUnLCdEU2N5JzonXFxcXHUwNDA1JywnZHNvbCc6J1xcXFx1MjlGNicsJ2RzdHJvayc6J1xcXFx1MDExMScsJ0RzdHJvayc6J1xcXFx1MDExMCcsJ2R0ZG90JzonXFxcXHUyMkYxJywnZHRyaSc6J1xcXFx1MjVCRicsJ2R0cmlmJzonXFxcXHUyNUJFJywnZHVhcnInOidcXFxcdTIxRjUnLCdkdWhhcic6J1xcXFx1Mjk2RicsJ2R3YW5nbGUnOidcXFxcdTI5QTYnLCdkemN5JzonXFxcXHUwNDVGJywnRFpjeSc6J1xcXFx1MDQwRicsJ2R6aWdyYXJyJzonXFxcXHUyN0ZGJywnZWFjdXRlJzonXFxcXHhFOScsJ0VhY3V0ZSc6J1xcXFx4QzknLCdlYXN0ZXInOidcXFxcdTJBNkUnLCdlY2Fyb24nOidcXFxcdTAxMUInLCdFY2Fyb24nOidcXFxcdTAxMUEnLCdlY2lyJzonXFxcXHUyMjU2JywnZWNpcmMnOidcXFxceEVBJywnRWNpcmMnOidcXFxceENBJywnZWNvbG9uJzonXFxcXHUyMjU1JywnZWN5JzonXFxcXHUwNDREJywnRWN5JzonXFxcXHUwNDJEJywnZUREb3QnOidcXFxcdTJBNzcnLCdlZG90JzonXFxcXHUwMTE3JywnZURvdCc6J1xcXFx1MjI1MScsJ0Vkb3QnOidcXFxcdTAxMTYnLCdlZSc6J1xcXFx1MjE0NycsJ2VmRG90JzonXFxcXHUyMjUyJywnZWZyJzonXFxcXHVEODM1XFxcXHVERDIyJywnRWZyJzonXFxcXHVEODM1XFxcXHVERDA4JywnZWcnOidcXFxcdTJBOUEnLCdlZ3JhdmUnOidcXFxceEU4JywnRWdyYXZlJzonXFxcXHhDOCcsJ2Vncyc6J1xcXFx1MkE5NicsJ2Vnc2RvdCc6J1xcXFx1MkE5OCcsJ2VsJzonXFxcXHUyQTk5JywnRWxlbWVudCc6J1xcXFx1MjIwOCcsJ2VsaW50ZXJzJzonXFxcXHUyM0U3JywnZWxsJzonXFxcXHUyMTEzJywnZWxzJzonXFxcXHUyQTk1JywnZWxzZG90JzonXFxcXHUyQTk3JywnZW1hY3InOidcXFxcdTAxMTMnLCdFbWFjcic6J1xcXFx1MDExMicsJ2VtcHR5JzonXFxcXHUyMjA1JywnZW1wdHlzZXQnOidcXFxcdTIyMDUnLCdFbXB0eVNtYWxsU3F1YXJlJzonXFxcXHUyNUZCJywnZW1wdHl2JzonXFxcXHUyMjA1JywnRW1wdHlWZXJ5U21hbGxTcXVhcmUnOidcXFxcdTI1QUInLCdlbXNwJzonXFxcXHUyMDAzJywnZW1zcDEzJzonXFxcXHUyMDA0JywnZW1zcDE0JzonXFxcXHUyMDA1JywnZW5nJzonXFxcXHUwMTRCJywnRU5HJzonXFxcXHUwMTRBJywnZW5zcCc6J1xcXFx1MjAwMicsJ2VvZ29uJzonXFxcXHUwMTE5JywnRW9nb24nOidcXFxcdTAxMTgnLCdlb3BmJzonXFxcXHVEODM1XFxcXHVERDU2JywnRW9wZic6J1xcXFx1RDgzNVxcXFx1REQzQycsJ2VwYXInOidcXFxcdTIyRDUnLCdlcGFyc2wnOidcXFxcdTI5RTMnLCdlcGx1cyc6J1xcXFx1MkE3MScsJ2Vwc2knOidcXFxcdTAzQjUnLCdlcHNpbG9uJzonXFxcXHUwM0I1JywnRXBzaWxvbic6J1xcXFx1MDM5NScsJ2Vwc2l2JzonXFxcXHUwM0Y1JywnZXFjaXJjJzonXFxcXHUyMjU2JywnZXFjb2xvbic6J1xcXFx1MjI1NScsJ2Vxc2ltJzonXFxcXHUyMjQyJywnZXFzbGFudGd0cic6J1xcXFx1MkE5NicsJ2Vxc2xhbnRsZXNzJzonXFxcXHUyQTk1JywnRXF1YWwnOidcXFxcdTJBNzUnLCdlcXVhbHMnOic9JywnRXF1YWxUaWxkZSc6J1xcXFx1MjI0MicsJ2VxdWVzdCc6J1xcXFx1MjI1RicsJ0VxdWlsaWJyaXVtJzonXFxcXHUyMUNDJywnZXF1aXYnOidcXFxcdTIyNjEnLCdlcXVpdkREJzonXFxcXHUyQTc4JywnZXF2cGFyc2wnOidcXFxcdTI5RTUnLCdlcmFycic6J1xcXFx1Mjk3MScsJ2VyRG90JzonXFxcXHUyMjUzJywnZXNjcic6J1xcXFx1MjEyRicsJ0VzY3InOidcXFxcdTIxMzAnLCdlc2RvdCc6J1xcXFx1MjI1MCcsJ2VzaW0nOidcXFxcdTIyNDInLCdFc2ltJzonXFxcXHUyQTczJywnZXRhJzonXFxcXHUwM0I3JywnRXRhJzonXFxcXHUwMzk3JywnZXRoJzonXFxcXHhGMCcsJ0VUSCc6J1xcXFx4RDAnLCdldW1sJzonXFxcXHhFQicsJ0V1bWwnOidcXFxceENCJywnZXVybyc6J1xcXFx1MjBBQycsJ2V4Y2wnOichJywnZXhpc3QnOidcXFxcdTIyMDMnLCdFeGlzdHMnOidcXFxcdTIyMDMnLCdleHBlY3RhdGlvbic6J1xcXFx1MjEzMCcsJ2V4cG9uZW50aWFsZSc6J1xcXFx1MjE0NycsJ0V4cG9uZW50aWFsRSc6J1xcXFx1MjE0NycsJ2ZhbGxpbmdkb3RzZXEnOidcXFxcdTIyNTInLCdmY3knOidcXFxcdTA0NDQnLCdGY3knOidcXFxcdTA0MjQnLCdmZW1hbGUnOidcXFxcdTI2NDAnLCdmZmlsaWcnOidcXFxcdUZCMDMnLCdmZmxpZyc6J1xcXFx1RkIwMCcsJ2ZmbGxpZyc6J1xcXFx1RkIwNCcsJ2Zmcic6J1xcXFx1RDgzNVxcXFx1REQyMycsJ0Zmcic6J1xcXFx1RDgzNVxcXFx1REQwOScsJ2ZpbGlnJzonXFxcXHVGQjAxJywnRmlsbGVkU21hbGxTcXVhcmUnOidcXFxcdTI1RkMnLCdGaWxsZWRWZXJ5U21hbGxTcXVhcmUnOidcXFxcdTI1QUEnLCdmamxpZyc6J2ZqJywnZmxhdCc6J1xcXFx1MjY2RCcsJ2ZsbGlnJzonXFxcXHVGQjAyJywnZmx0bnMnOidcXFxcdTI1QjEnLCdmbm9mJzonXFxcXHUwMTkyJywnZm9wZic6J1xcXFx1RDgzNVxcXFx1REQ1NycsJ0ZvcGYnOidcXFxcdUQ4MzVcXFxcdUREM0QnLCdmb3JhbGwnOidcXFxcdTIyMDAnLCdGb3JBbGwnOidcXFxcdTIyMDAnLCdmb3JrJzonXFxcXHUyMkQ0JywnZm9ya3YnOidcXFxcdTJBRDknLCdGb3VyaWVydHJmJzonXFxcXHUyMTMxJywnZnBhcnRpbnQnOidcXFxcdTJBMEQnLCdmcmFjMTInOidcXFxceEJEJywnZnJhYzEzJzonXFxcXHUyMTUzJywnZnJhYzE0JzonXFxcXHhCQycsJ2ZyYWMxNSc6J1xcXFx1MjE1NScsJ2ZyYWMxNic6J1xcXFx1MjE1OScsJ2ZyYWMxOCc6J1xcXFx1MjE1QicsJ2ZyYWMyMyc6J1xcXFx1MjE1NCcsJ2ZyYWMyNSc6J1xcXFx1MjE1NicsJ2ZyYWMzNCc6J1xcXFx4QkUnLCdmcmFjMzUnOidcXFxcdTIxNTcnLCdmcmFjMzgnOidcXFxcdTIxNUMnLCdmcmFjNDUnOidcXFxcdTIxNTgnLCdmcmFjNTYnOidcXFxcdTIxNUEnLCdmcmFjNTgnOidcXFxcdTIxNUQnLCdmcmFjNzgnOidcXFxcdTIxNUUnLCdmcmFzbCc6J1xcXFx1MjA0NCcsJ2Zyb3duJzonXFxcXHUyMzIyJywnZnNjcic6J1xcXFx1RDgzNVxcXFx1RENCQicsJ0ZzY3InOidcXFxcdTIxMzEnLCdnYWN1dGUnOidcXFxcdTAxRjUnLCdnYW1tYSc6J1xcXFx1MDNCMycsJ0dhbW1hJzonXFxcXHUwMzkzJywnZ2FtbWFkJzonXFxcXHUwM0REJywnR2FtbWFkJzonXFxcXHUwM0RDJywnZ2FwJzonXFxcXHUyQTg2JywnZ2JyZXZlJzonXFxcXHUwMTFGJywnR2JyZXZlJzonXFxcXHUwMTFFJywnR2NlZGlsJzonXFxcXHUwMTIyJywnZ2NpcmMnOidcXFxcdTAxMUQnLCdHY2lyYyc6J1xcXFx1MDExQycsJ2djeSc6J1xcXFx1MDQzMycsJ0djeSc6J1xcXFx1MDQxMycsJ2dkb3QnOidcXFxcdTAxMjEnLCdHZG90JzonXFxcXHUwMTIwJywnZ2UnOidcXFxcdTIyNjUnLCdnRSc6J1xcXFx1MjI2NycsJ2dlbCc6J1xcXFx1MjJEQicsJ2dFbCc6J1xcXFx1MkE4QycsJ2dlcSc6J1xcXFx1MjI2NScsJ2dlcXEnOidcXFxcdTIyNjcnLCdnZXFzbGFudCc6J1xcXFx1MkE3RScsJ2dlcyc6J1xcXFx1MkE3RScsJ2dlc2NjJzonXFxcXHUyQUE5JywnZ2VzZG90JzonXFxcXHUyQTgwJywnZ2VzZG90byc6J1xcXFx1MkE4MicsJ2dlc2RvdG9sJzonXFxcXHUyQTg0JywnZ2VzbCc6J1xcXFx1MjJEQlxcXFx1RkUwMCcsJ2dlc2xlcyc6J1xcXFx1MkE5NCcsJ2dmcic6J1xcXFx1RDgzNVxcXFx1REQyNCcsJ0dmcic6J1xcXFx1RDgzNVxcXFx1REQwQScsJ2dnJzonXFxcXHUyMjZCJywnR2cnOidcXFxcdTIyRDknLCdnZ2cnOidcXFxcdTIyRDknLCdnaW1lbCc6J1xcXFx1MjEzNycsJ2dqY3knOidcXFxcdTA0NTMnLCdHSmN5JzonXFxcXHUwNDAzJywnZ2wnOidcXFxcdTIyNzcnLCdnbGEnOidcXFxcdTJBQTUnLCdnbEUnOidcXFxcdTJBOTInLCdnbGonOidcXFxcdTJBQTQnLCdnbmFwJzonXFxcXHUyQThBJywnZ25hcHByb3gnOidcXFxcdTJBOEEnLCdnbmUnOidcXFxcdTJBODgnLCdnbkUnOidcXFxcdTIyNjknLCdnbmVxJzonXFxcXHUyQTg4JywnZ25lcXEnOidcXFxcdTIyNjknLCdnbnNpbSc6J1xcXFx1MjJFNycsJ2dvcGYnOidcXFxcdUQ4MzVcXFxcdURENTgnLCdHb3BmJzonXFxcXHVEODM1XFxcXHVERDNFJywnZ3JhdmUnOidgJywnR3JlYXRlckVxdWFsJzonXFxcXHUyMjY1JywnR3JlYXRlckVxdWFsTGVzcyc6J1xcXFx1MjJEQicsJ0dyZWF0ZXJGdWxsRXF1YWwnOidcXFxcdTIyNjcnLCdHcmVhdGVyR3JlYXRlcic6J1xcXFx1MkFBMicsJ0dyZWF0ZXJMZXNzJzonXFxcXHUyMjc3JywnR3JlYXRlclNsYW50RXF1YWwnOidcXFxcdTJBN0UnLCdHcmVhdGVyVGlsZGUnOidcXFxcdTIyNzMnLCdnc2NyJzonXFxcXHUyMTBBJywnR3Njcic6J1xcXFx1RDgzNVxcXFx1RENBMicsJ2dzaW0nOidcXFxcdTIyNzMnLCdnc2ltZSc6J1xcXFx1MkE4RScsJ2dzaW1sJzonXFxcXHUyQTkwJywnZ3QnOic+JywnR3QnOidcXFxcdTIyNkInLCdHVCc6Jz4nLCdndGNjJzonXFxcXHUyQUE3JywnZ3RjaXInOidcXFxcdTJBN0EnLCdndGRvdCc6J1xcXFx1MjJENycsJ2d0bFBhcic6J1xcXFx1Mjk5NScsJ2d0cXVlc3QnOidcXFxcdTJBN0MnLCdndHJhcHByb3gnOidcXFxcdTJBODYnLCdndHJhcnInOidcXFxcdTI5NzgnLCdndHJkb3QnOidcXFxcdTIyRDcnLCdndHJlcWxlc3MnOidcXFxcdTIyREInLCdndHJlcXFsZXNzJzonXFxcXHUyQThDJywnZ3RybGVzcyc6J1xcXFx1MjI3NycsJ2d0cnNpbSc6J1xcXFx1MjI3MycsJ2d2ZXJ0bmVxcSc6J1xcXFx1MjI2OVxcXFx1RkUwMCcsJ2d2bkUnOidcXFxcdTIyNjlcXFxcdUZFMDAnLCdIYWNlayc6J1xcXFx1MDJDNycsJ2hhaXJzcCc6J1xcXFx1MjAwQScsJ2hhbGYnOidcXFxceEJEJywnaGFtaWx0JzonXFxcXHUyMTBCJywnaGFyZGN5JzonXFxcXHUwNDRBJywnSEFSRGN5JzonXFxcXHUwNDJBJywnaGFycic6J1xcXFx1MjE5NCcsJ2hBcnInOidcXFxcdTIxRDQnLCdoYXJyY2lyJzonXFxcXHUyOTQ4JywnaGFycncnOidcXFxcdTIxQUQnLCdIYXQnOideJywnaGJhcic6J1xcXFx1MjEwRicsJ2hjaXJjJzonXFxcXHUwMTI1JywnSGNpcmMnOidcXFxcdTAxMjQnLCdoZWFydHMnOidcXFxcdTI2NjUnLCdoZWFydHN1aXQnOidcXFxcdTI2NjUnLCdoZWxsaXAnOidcXFxcdTIwMjYnLCdoZXJjb24nOidcXFxcdTIyQjknLCdoZnInOidcXFxcdUQ4MzVcXFxcdUREMjUnLCdIZnInOidcXFxcdTIxMEMnLCdIaWxiZXJ0U3BhY2UnOidcXFxcdTIxMEInLCdoa3NlYXJvdyc6J1xcXFx1MjkyNScsJ2hrc3dhcm93JzonXFxcXHUyOTI2JywnaG9hcnInOidcXFxcdTIxRkYnLCdob210aHQnOidcXFxcdTIyM0InLCdob29rbGVmdGFycm93JzonXFxcXHUyMUE5JywnaG9va3JpZ2h0YXJyb3cnOidcXFxcdTIxQUEnLCdob3BmJzonXFxcXHVEODM1XFxcXHVERDU5JywnSG9wZic6J1xcXFx1MjEwRCcsJ2hvcmJhcic6J1xcXFx1MjAxNScsJ0hvcml6b250YWxMaW5lJzonXFxcXHUyNTAwJywnaHNjcic6J1xcXFx1RDgzNVxcXFx1RENCRCcsJ0hzY3InOidcXFxcdTIxMEInLCdoc2xhc2gnOidcXFxcdTIxMEYnLCdoc3Ryb2snOidcXFxcdTAxMjcnLCdIc3Ryb2snOidcXFxcdTAxMjYnLCdIdW1wRG93bkh1bXAnOidcXFxcdTIyNEUnLCdIdW1wRXF1YWwnOidcXFxcdTIyNEYnLCdoeWJ1bGwnOidcXFxcdTIwNDMnLCdoeXBoZW4nOidcXFxcdTIwMTAnLCdpYWN1dGUnOidcXFxceEVEJywnSWFjdXRlJzonXFxcXHhDRCcsJ2ljJzonXFxcXHUyMDYzJywnaWNpcmMnOidcXFxceEVFJywnSWNpcmMnOidcXFxceENFJywnaWN5JzonXFxcXHUwNDM4JywnSWN5JzonXFxcXHUwNDE4JywnSWRvdCc6J1xcXFx1MDEzMCcsJ2llY3knOidcXFxcdTA0MzUnLCdJRWN5JzonXFxcXHUwNDE1JywnaWV4Y2wnOidcXFxceEExJywnaWZmJzonXFxcXHUyMUQ0JywnaWZyJzonXFxcXHVEODM1XFxcXHVERDI2JywnSWZyJzonXFxcXHUyMTExJywnaWdyYXZlJzonXFxcXHhFQycsJ0lncmF2ZSc6J1xcXFx4Q0MnLCdpaSc6J1xcXFx1MjE0OCcsJ2lpaWludCc6J1xcXFx1MkEwQycsJ2lpaW50JzonXFxcXHUyMjJEJywnaWluZmluJzonXFxcXHUyOURDJywnaWlvdGEnOidcXFxcdTIxMjknLCdpamxpZyc6J1xcXFx1MDEzMycsJ0lKbGlnJzonXFxcXHUwMTMyJywnSW0nOidcXFxcdTIxMTEnLCdpbWFjcic6J1xcXFx1MDEyQicsJ0ltYWNyJzonXFxcXHUwMTJBJywnaW1hZ2UnOidcXFxcdTIxMTEnLCdJbWFnaW5hcnlJJzonXFxcXHUyMTQ4JywnaW1hZ2xpbmUnOidcXFxcdTIxMTAnLCdpbWFncGFydCc6J1xcXFx1MjExMScsJ2ltYXRoJzonXFxcXHUwMTMxJywnaW1vZic6J1xcXFx1MjJCNycsJ2ltcGVkJzonXFxcXHUwMUI1JywnSW1wbGllcyc6J1xcXFx1MjFEMicsJ2luJzonXFxcXHUyMjA4JywnaW5jYXJlJzonXFxcXHUyMTA1JywnaW5maW4nOidcXFxcdTIyMUUnLCdpbmZpbnRpZSc6J1xcXFx1MjlERCcsJ2lub2RvdCc6J1xcXFx1MDEzMScsJ2ludCc6J1xcXFx1MjIyQicsJ0ludCc6J1xcXFx1MjIyQycsJ2ludGNhbCc6J1xcXFx1MjJCQScsJ2ludGVnZXJzJzonXFxcXHUyMTI0JywnSW50ZWdyYWwnOidcXFxcdTIyMkInLCdpbnRlcmNhbCc6J1xcXFx1MjJCQScsJ0ludGVyc2VjdGlvbic6J1xcXFx1MjJDMicsJ2ludGxhcmhrJzonXFxcXHUyQTE3JywnaW50cHJvZCc6J1xcXFx1MkEzQycsJ0ludmlzaWJsZUNvbW1hJzonXFxcXHUyMDYzJywnSW52aXNpYmxlVGltZXMnOidcXFxcdTIwNjInLCdpb2N5JzonXFxcXHUwNDUxJywnSU9jeSc6J1xcXFx1MDQwMScsJ2lvZ29uJzonXFxcXHUwMTJGJywnSW9nb24nOidcXFxcdTAxMkUnLCdpb3BmJzonXFxcXHVEODM1XFxcXHVERDVBJywnSW9wZic6J1xcXFx1RDgzNVxcXFx1REQ0MCcsJ2lvdGEnOidcXFxcdTAzQjknLCdJb3RhJzonXFxcXHUwMzk5JywnaXByb2QnOidcXFxcdTJBM0MnLCdpcXVlc3QnOidcXFxceEJGJywnaXNjcic6J1xcXFx1RDgzNVxcXFx1RENCRScsJ0lzY3InOidcXFxcdTIxMTAnLCdpc2luJzonXFxcXHUyMjA4JywnaXNpbmRvdCc6J1xcXFx1MjJGNScsJ2lzaW5FJzonXFxcXHUyMkY5JywnaXNpbnMnOidcXFxcdTIyRjQnLCdpc2luc3YnOidcXFxcdTIyRjMnLCdpc2ludic6J1xcXFx1MjIwOCcsJ2l0JzonXFxcXHUyMDYyJywnaXRpbGRlJzonXFxcXHUwMTI5JywnSXRpbGRlJzonXFxcXHUwMTI4JywnaXVrY3knOidcXFxcdTA0NTYnLCdJdWtjeSc6J1xcXFx1MDQwNicsJ2l1bWwnOidcXFxceEVGJywnSXVtbCc6J1xcXFx4Q0YnLCdqY2lyYyc6J1xcXFx1MDEzNScsJ0pjaXJjJzonXFxcXHUwMTM0JywnamN5JzonXFxcXHUwNDM5JywnSmN5JzonXFxcXHUwNDE5JywnamZyJzonXFxcXHVEODM1XFxcXHVERDI3JywnSmZyJzonXFxcXHVEODM1XFxcXHVERDBEJywnam1hdGgnOidcXFxcdTAyMzcnLCdqb3BmJzonXFxcXHVEODM1XFxcXHVERDVCJywnSm9wZic6J1xcXFx1RDgzNVxcXFx1REQ0MScsJ2pzY3InOidcXFxcdUQ4MzVcXFxcdURDQkYnLCdKc2NyJzonXFxcXHVEODM1XFxcXHVEQ0E1JywnanNlcmN5JzonXFxcXHUwNDU4JywnSnNlcmN5JzonXFxcXHUwNDA4JywnanVrY3knOidcXFxcdTA0NTQnLCdKdWtjeSc6J1xcXFx1MDQwNCcsJ2thcHBhJzonXFxcXHUwM0JBJywnS2FwcGEnOidcXFxcdTAzOUEnLCdrYXBwYXYnOidcXFxcdTAzRjAnLCdrY2VkaWwnOidcXFxcdTAxMzcnLCdLY2VkaWwnOidcXFxcdTAxMzYnLCdrY3knOidcXFxcdTA0M0EnLCdLY3knOidcXFxcdTA0MUEnLCdrZnInOidcXFxcdUQ4MzVcXFxcdUREMjgnLCdLZnInOidcXFxcdUQ4MzVcXFxcdUREMEUnLCdrZ3JlZW4nOidcXFxcdTAxMzgnLCdraGN5JzonXFxcXHUwNDQ1JywnS0hjeSc6J1xcXFx1MDQyNScsJ2tqY3knOidcXFxcdTA0NUMnLCdLSmN5JzonXFxcXHUwNDBDJywna29wZic6J1xcXFx1RDgzNVxcXFx1REQ1QycsJ0tvcGYnOidcXFxcdUQ4MzVcXFxcdURENDInLCdrc2NyJzonXFxcXHVEODM1XFxcXHVEQ0MwJywnS3Njcic6J1xcXFx1RDgzNVxcXFx1RENBNicsJ2xBYXJyJzonXFxcXHUyMURBJywnbGFjdXRlJzonXFxcXHUwMTNBJywnTGFjdXRlJzonXFxcXHUwMTM5JywnbGFlbXB0eXYnOidcXFxcdTI5QjQnLCdsYWdyYW4nOidcXFxcdTIxMTInLCdsYW1iZGEnOidcXFxcdTAzQkInLCdMYW1iZGEnOidcXFxcdTAzOUInLCdsYW5nJzonXFxcXHUyN0U4JywnTGFuZyc6J1xcXFx1MjdFQScsJ2xhbmdkJzonXFxcXHUyOTkxJywnbGFuZ2xlJzonXFxcXHUyN0U4JywnbGFwJzonXFxcXHUyQTg1JywnTGFwbGFjZXRyZic6J1xcXFx1MjExMicsJ2xhcXVvJzonXFxcXHhBQicsJ2xhcnInOidcXFxcdTIxOTAnLCdsQXJyJzonXFxcXHUyMUQwJywnTGFycic6J1xcXFx1MjE5RScsJ2xhcnJiJzonXFxcXHUyMUU0JywnbGFycmJmcyc6J1xcXFx1MjkxRicsJ2xhcnJmcyc6J1xcXFx1MjkxRCcsJ2xhcnJoayc6J1xcXFx1MjFBOScsJ2xhcnJscCc6J1xcXFx1MjFBQicsJ2xhcnJwbCc6J1xcXFx1MjkzOScsJ2xhcnJzaW0nOidcXFxcdTI5NzMnLCdsYXJydGwnOidcXFxcdTIxQTInLCdsYXQnOidcXFxcdTJBQUInLCdsYXRhaWwnOidcXFxcdTI5MTknLCdsQXRhaWwnOidcXFxcdTI5MUInLCdsYXRlJzonXFxcXHUyQUFEJywnbGF0ZXMnOidcXFxcdTJBQURcXFxcdUZFMDAnLCdsYmFycic6J1xcXFx1MjkwQycsJ2xCYXJyJzonXFxcXHUyOTBFJywnbGJicmsnOidcXFxcdTI3NzInLCdsYnJhY2UnOid7JywnbGJyYWNrJzonWycsJ2xicmtlJzonXFxcXHUyOThCJywnbGJya3NsZCc6J1xcXFx1Mjk4RicsJ2xicmtzbHUnOidcXFxcdTI5OEQnLCdsY2Fyb24nOidcXFxcdTAxM0UnLCdMY2Fyb24nOidcXFxcdTAxM0QnLCdsY2VkaWwnOidcXFxcdTAxM0MnLCdMY2VkaWwnOidcXFxcdTAxM0InLCdsY2VpbCc6J1xcXFx1MjMwOCcsJ2xjdWInOid7JywnbGN5JzonXFxcXHUwNDNCJywnTGN5JzonXFxcXHUwNDFCJywnbGRjYSc6J1xcXFx1MjkzNicsJ2xkcXVvJzonXFxcXHUyMDFDJywnbGRxdW9yJzonXFxcXHUyMDFFJywnbGRyZGhhcic6J1xcXFx1Mjk2NycsJ2xkcnVzaGFyJzonXFxcXHUyOTRCJywnbGRzaCc6J1xcXFx1MjFCMicsJ2xlJzonXFxcXHUyMjY0JywnbEUnOidcXFxcdTIyNjYnLCdMZWZ0QW5nbGVCcmFja2V0JzonXFxcXHUyN0U4JywnbGVmdGFycm93JzonXFxcXHUyMTkwJywnTGVmdGFycm93JzonXFxcXHUyMUQwJywnTGVmdEFycm93JzonXFxcXHUyMTkwJywnTGVmdEFycm93QmFyJzonXFxcXHUyMUU0JywnTGVmdEFycm93UmlnaHRBcnJvdyc6J1xcXFx1MjFDNicsJ2xlZnRhcnJvd3RhaWwnOidcXFxcdTIxQTInLCdMZWZ0Q2VpbGluZyc6J1xcXFx1MjMwOCcsJ0xlZnREb3VibGVCcmFja2V0JzonXFxcXHUyN0U2JywnTGVmdERvd25UZWVWZWN0b3InOidcXFxcdTI5NjEnLCdMZWZ0RG93blZlY3Rvcic6J1xcXFx1MjFDMycsJ0xlZnREb3duVmVjdG9yQmFyJzonXFxcXHUyOTU5JywnTGVmdEZsb29yJzonXFxcXHUyMzBBJywnbGVmdGhhcnBvb25kb3duJzonXFxcXHUyMUJEJywnbGVmdGhhcnBvb251cCc6J1xcXFx1MjFCQycsJ2xlZnRsZWZ0YXJyb3dzJzonXFxcXHUyMUM3JywnbGVmdHJpZ2h0YXJyb3cnOidcXFxcdTIxOTQnLCdMZWZ0cmlnaHRhcnJvdyc6J1xcXFx1MjFENCcsJ0xlZnRSaWdodEFycm93JzonXFxcXHUyMTk0JywnbGVmdHJpZ2h0YXJyb3dzJzonXFxcXHUyMUM2JywnbGVmdHJpZ2h0aGFycG9vbnMnOidcXFxcdTIxQ0InLCdsZWZ0cmlnaHRzcXVpZ2Fycm93JzonXFxcXHUyMUFEJywnTGVmdFJpZ2h0VmVjdG9yJzonXFxcXHUyOTRFJywnTGVmdFRlZSc6J1xcXFx1MjJBMycsJ0xlZnRUZWVBcnJvdyc6J1xcXFx1MjFBNCcsJ0xlZnRUZWVWZWN0b3InOidcXFxcdTI5NUEnLCdsZWZ0dGhyZWV0aW1lcyc6J1xcXFx1MjJDQicsJ0xlZnRUcmlhbmdsZSc6J1xcXFx1MjJCMicsJ0xlZnRUcmlhbmdsZUJhcic6J1xcXFx1MjlDRicsJ0xlZnRUcmlhbmdsZUVxdWFsJzonXFxcXHUyMkI0JywnTGVmdFVwRG93blZlY3Rvcic6J1xcXFx1Mjk1MScsJ0xlZnRVcFRlZVZlY3Rvcic6J1xcXFx1Mjk2MCcsJ0xlZnRVcFZlY3Rvcic6J1xcXFx1MjFCRicsJ0xlZnRVcFZlY3RvckJhcic6J1xcXFx1Mjk1OCcsJ0xlZnRWZWN0b3InOidcXFxcdTIxQkMnLCdMZWZ0VmVjdG9yQmFyJzonXFxcXHUyOTUyJywnbGVnJzonXFxcXHUyMkRBJywnbEVnJzonXFxcXHUyQThCJywnbGVxJzonXFxcXHUyMjY0JywnbGVxcSc6J1xcXFx1MjI2NicsJ2xlcXNsYW50JzonXFxcXHUyQTdEJywnbGVzJzonXFxcXHUyQTdEJywnbGVzY2MnOidcXFxcdTJBQTgnLCdsZXNkb3QnOidcXFxcdTJBN0YnLCdsZXNkb3RvJzonXFxcXHUyQTgxJywnbGVzZG90b3InOidcXFxcdTJBODMnLCdsZXNnJzonXFxcXHUyMkRBXFxcXHVGRTAwJywnbGVzZ2VzJzonXFxcXHUyQTkzJywnbGVzc2FwcHJveCc6J1xcXFx1MkE4NScsJ2xlc3Nkb3QnOidcXFxcdTIyRDYnLCdsZXNzZXFndHInOidcXFxcdTIyREEnLCdsZXNzZXFxZ3RyJzonXFxcXHUyQThCJywnTGVzc0VxdWFsR3JlYXRlcic6J1xcXFx1MjJEQScsJ0xlc3NGdWxsRXF1YWwnOidcXFxcdTIyNjYnLCdMZXNzR3JlYXRlcic6J1xcXFx1MjI3NicsJ2xlc3NndHInOidcXFxcdTIyNzYnLCdMZXNzTGVzcyc6J1xcXFx1MkFBMScsJ2xlc3NzaW0nOidcXFxcdTIyNzInLCdMZXNzU2xhbnRFcXVhbCc6J1xcXFx1MkE3RCcsJ0xlc3NUaWxkZSc6J1xcXFx1MjI3MicsJ2xmaXNodCc6J1xcXFx1Mjk3QycsJ2xmbG9vcic6J1xcXFx1MjMwQScsJ2xmcic6J1xcXFx1RDgzNVxcXFx1REQyOScsJ0xmcic6J1xcXFx1RDgzNVxcXFx1REQwRicsJ2xnJzonXFxcXHUyMjc2JywnbGdFJzonXFxcXHUyQTkxJywnbEhhcic6J1xcXFx1Mjk2MicsJ2xoYXJkJzonXFxcXHUyMUJEJywnbGhhcnUnOidcXFxcdTIxQkMnLCdsaGFydWwnOidcXFxcdTI5NkEnLCdsaGJsayc6J1xcXFx1MjU4NCcsJ2xqY3knOidcXFxcdTA0NTknLCdMSmN5JzonXFxcXHUwNDA5JywnbGwnOidcXFxcdTIyNkEnLCdMbCc6J1xcXFx1MjJEOCcsJ2xsYXJyJzonXFxcXHUyMUM3JywnbGxjb3JuZXInOidcXFxcdTIzMUUnLCdMbGVmdGFycm93JzonXFxcXHUyMURBJywnbGxoYXJkJzonXFxcXHUyOTZCJywnbGx0cmknOidcXFxcdTI1RkEnLCdsbWlkb3QnOidcXFxcdTAxNDAnLCdMbWlkb3QnOidcXFxcdTAxM0YnLCdsbW91c3QnOidcXFxcdTIzQjAnLCdsbW91c3RhY2hlJzonXFxcXHUyM0IwJywnbG5hcCc6J1xcXFx1MkE4OScsJ2xuYXBwcm94JzonXFxcXHUyQTg5JywnbG5lJzonXFxcXHUyQTg3JywnbG5FJzonXFxcXHUyMjY4JywnbG5lcSc6J1xcXFx1MkE4NycsJ2xuZXFxJzonXFxcXHUyMjY4JywnbG5zaW0nOidcXFxcdTIyRTYnLCdsb2FuZyc6J1xcXFx1MjdFQycsJ2xvYXJyJzonXFxcXHUyMUZEJywnbG9icmsnOidcXFxcdTI3RTYnLCdsb25nbGVmdGFycm93JzonXFxcXHUyN0Y1JywnTG9uZ2xlZnRhcnJvdyc6J1xcXFx1MjdGOCcsJ0xvbmdMZWZ0QXJyb3cnOidcXFxcdTI3RjUnLCdsb25nbGVmdHJpZ2h0YXJyb3cnOidcXFxcdTI3RjcnLCdMb25nbGVmdHJpZ2h0YXJyb3cnOidcXFxcdTI3RkEnLCdMb25nTGVmdFJpZ2h0QXJyb3cnOidcXFxcdTI3RjcnLCdsb25nbWFwc3RvJzonXFxcXHUyN0ZDJywnbG9uZ3JpZ2h0YXJyb3cnOidcXFxcdTI3RjYnLCdMb25ncmlnaHRhcnJvdyc6J1xcXFx1MjdGOScsJ0xvbmdSaWdodEFycm93JzonXFxcXHUyN0Y2JywnbG9vcGFycm93bGVmdCc6J1xcXFx1MjFBQicsJ2xvb3BhcnJvd3JpZ2h0JzonXFxcXHUyMUFDJywnbG9wYXInOidcXFxcdTI5ODUnLCdsb3BmJzonXFxcXHVEODM1XFxcXHVERDVEJywnTG9wZic6J1xcXFx1RDgzNVxcXFx1REQ0MycsJ2xvcGx1cyc6J1xcXFx1MkEyRCcsJ2xvdGltZXMnOidcXFxcdTJBMzQnLCdsb3dhc3QnOidcXFxcdTIyMTcnLCdsb3diYXInOidfJywnTG93ZXJMZWZ0QXJyb3cnOidcXFxcdTIxOTknLCdMb3dlclJpZ2h0QXJyb3cnOidcXFxcdTIxOTgnLCdsb3onOidcXFxcdTI1Q0EnLCdsb3plbmdlJzonXFxcXHUyNUNBJywnbG96Zic6J1xcXFx1MjlFQicsJ2xwYXInOicoJywnbHBhcmx0JzonXFxcXHUyOTkzJywnbHJhcnInOidcXFxcdTIxQzYnLCdscmNvcm5lcic6J1xcXFx1MjMxRicsJ2xyaGFyJzonXFxcXHUyMUNCJywnbHJoYXJkJzonXFxcXHUyOTZEJywnbHJtJzonXFxcXHUyMDBFJywnbHJ0cmknOidcXFxcdTIyQkYnLCdsc2FxdW8nOidcXFxcdTIwMzknLCdsc2NyJzonXFxcXHVEODM1XFxcXHVEQ0MxJywnTHNjcic6J1xcXFx1MjExMicsJ2xzaCc6J1xcXFx1MjFCMCcsJ0xzaCc6J1xcXFx1MjFCMCcsJ2xzaW0nOidcXFxcdTIyNzInLCdsc2ltZSc6J1xcXFx1MkE4RCcsJ2xzaW1nJzonXFxcXHUyQThGJywnbHNxYic6J1snLCdsc3F1byc6J1xcXFx1MjAxOCcsJ2xzcXVvcic6J1xcXFx1MjAxQScsJ2xzdHJvayc6J1xcXFx1MDE0MicsJ0xzdHJvayc6J1xcXFx1MDE0MScsJ2x0JzonPCcsJ0x0JzonXFxcXHUyMjZBJywnTFQnOic8JywnbHRjYyc6J1xcXFx1MkFBNicsJ2x0Y2lyJzonXFxcXHUyQTc5JywnbHRkb3QnOidcXFxcdTIyRDYnLCdsdGhyZWUnOidcXFxcdTIyQ0InLCdsdGltZXMnOidcXFxcdTIyQzknLCdsdGxhcnInOidcXFxcdTI5NzYnLCdsdHF1ZXN0JzonXFxcXHUyQTdCJywnbHRyaSc6J1xcXFx1MjVDMycsJ2x0cmllJzonXFxcXHUyMkI0JywnbHRyaWYnOidcXFxcdTI1QzInLCdsdHJQYXInOidcXFxcdTI5OTYnLCdsdXJkc2hhcic6J1xcXFx1Mjk0QScsJ2x1cnVoYXInOidcXFxcdTI5NjYnLCdsdmVydG5lcXEnOidcXFxcdTIyNjhcXFxcdUZFMDAnLCdsdm5FJzonXFxcXHUyMjY4XFxcXHVGRTAwJywnbWFjcic6J1xcXFx4QUYnLCdtYWxlJzonXFxcXHUyNjQyJywnbWFsdCc6J1xcXFx1MjcyMCcsJ21hbHRlc2UnOidcXFxcdTI3MjAnLCdtYXAnOidcXFxcdTIxQTYnLCdNYXAnOidcXFxcdTI5MDUnLCdtYXBzdG8nOidcXFxcdTIxQTYnLCdtYXBzdG9kb3duJzonXFxcXHUyMUE3JywnbWFwc3RvbGVmdCc6J1xcXFx1MjFBNCcsJ21hcHN0b3VwJzonXFxcXHUyMUE1JywnbWFya2VyJzonXFxcXHUyNUFFJywnbWNvbW1hJzonXFxcXHUyQTI5JywnbWN5JzonXFxcXHUwNDNDJywnTWN5JzonXFxcXHUwNDFDJywnbWRhc2gnOidcXFxcdTIwMTQnLCdtRERvdCc6J1xcXFx1MjIzQScsJ21lYXN1cmVkYW5nbGUnOidcXFxcdTIyMjEnLCdNZWRpdW1TcGFjZSc6J1xcXFx1MjA1RicsJ01lbGxpbnRyZic6J1xcXFx1MjEzMycsJ21mcic6J1xcXFx1RDgzNVxcXFx1REQyQScsJ01mcic6J1xcXFx1RDgzNVxcXFx1REQxMCcsJ21obyc6J1xcXFx1MjEyNycsJ21pY3JvJzonXFxcXHhCNScsJ21pZCc6J1xcXFx1MjIyMycsJ21pZGFzdCc6JyonLCdtaWRjaXInOidcXFxcdTJBRjAnLCdtaWRkb3QnOidcXFxceEI3JywnbWludXMnOidcXFxcdTIyMTInLCdtaW51c2InOidcXFxcdTIyOUYnLCdtaW51c2QnOidcXFxcdTIyMzgnLCdtaW51c2R1JzonXFxcXHUyQTJBJywnTWludXNQbHVzJzonXFxcXHUyMjEzJywnbWxjcCc6J1xcXFx1MkFEQicsJ21sZHInOidcXFxcdTIwMjYnLCdtbnBsdXMnOidcXFxcdTIyMTMnLCdtb2RlbHMnOidcXFxcdTIyQTcnLCdtb3BmJzonXFxcXHVEODM1XFxcXHVERDVFJywnTW9wZic6J1xcXFx1RDgzNVxcXFx1REQ0NCcsJ21wJzonXFxcXHUyMjEzJywnbXNjcic6J1xcXFx1RDgzNVxcXFx1RENDMicsJ01zY3InOidcXFxcdTIxMzMnLCdtc3Rwb3MnOidcXFxcdTIyM0UnLCdtdSc6J1xcXFx1MDNCQycsJ011JzonXFxcXHUwMzlDJywnbXVsdGltYXAnOidcXFxcdTIyQjgnLCdtdW1hcCc6J1xcXFx1MjJCOCcsJ25hYmxhJzonXFxcXHUyMjA3JywnbmFjdXRlJzonXFxcXHUwMTQ0JywnTmFjdXRlJzonXFxcXHUwMTQzJywnbmFuZyc6J1xcXFx1MjIyMFxcXFx1MjBEMicsJ25hcCc6J1xcXFx1MjI0OScsJ25hcEUnOidcXFxcdTJBNzBcXFxcdTAzMzgnLCduYXBpZCc6J1xcXFx1MjI0QlxcXFx1MDMzOCcsJ25hcG9zJzonXFxcXHUwMTQ5JywnbmFwcHJveCc6J1xcXFx1MjI0OScsJ25hdHVyJzonXFxcXHUyNjZFJywnbmF0dXJhbCc6J1xcXFx1MjY2RScsJ25hdHVyYWxzJzonXFxcXHUyMTE1JywnbmJzcCc6J1xcXFx4QTAnLCduYnVtcCc6J1xcXFx1MjI0RVxcXFx1MDMzOCcsJ25idW1wZSc6J1xcXFx1MjI0RlxcXFx1MDMzOCcsJ25jYXAnOidcXFxcdTJBNDMnLCduY2Fyb24nOidcXFxcdTAxNDgnLCdOY2Fyb24nOidcXFxcdTAxNDcnLCduY2VkaWwnOidcXFxcdTAxNDYnLCdOY2VkaWwnOidcXFxcdTAxNDUnLCduY29uZyc6J1xcXFx1MjI0NycsJ25jb25nZG90JzonXFxcXHUyQTZEXFxcXHUwMzM4JywnbmN1cCc6J1xcXFx1MkE0MicsJ25jeSc6J1xcXFx1MDQzRCcsJ05jeSc6J1xcXFx1MDQxRCcsJ25kYXNoJzonXFxcXHUyMDEzJywnbmUnOidcXFxcdTIyNjAnLCduZWFyaGsnOidcXFxcdTI5MjQnLCduZWFycic6J1xcXFx1MjE5NycsJ25lQXJyJzonXFxcXHUyMUQ3JywnbmVhcnJvdyc6J1xcXFx1MjE5NycsJ25lZG90JzonXFxcXHUyMjUwXFxcXHUwMzM4JywnTmVnYXRpdmVNZWRpdW1TcGFjZSc6J1xcXFx1MjAwQicsJ05lZ2F0aXZlVGhpY2tTcGFjZSc6J1xcXFx1MjAwQicsJ05lZ2F0aXZlVGhpblNwYWNlJzonXFxcXHUyMDBCJywnTmVnYXRpdmVWZXJ5VGhpblNwYWNlJzonXFxcXHUyMDBCJywnbmVxdWl2JzonXFxcXHUyMjYyJywnbmVzZWFyJzonXFxcXHUyOTI4JywnbmVzaW0nOidcXFxcdTIyNDJcXFxcdTAzMzgnLCdOZXN0ZWRHcmVhdGVyR3JlYXRlcic6J1xcXFx1MjI2QicsJ05lc3RlZExlc3NMZXNzJzonXFxcXHUyMjZBJywnTmV3TGluZSc6J1xcXFxuJywnbmV4aXN0JzonXFxcXHUyMjA0JywnbmV4aXN0cyc6J1xcXFx1MjIwNCcsJ25mcic6J1xcXFx1RDgzNVxcXFx1REQyQicsJ05mcic6J1xcXFx1RDgzNVxcXFx1REQxMScsJ25nZSc6J1xcXFx1MjI3MScsJ25nRSc6J1xcXFx1MjI2N1xcXFx1MDMzOCcsJ25nZXEnOidcXFxcdTIyNzEnLCduZ2VxcSc6J1xcXFx1MjI2N1xcXFx1MDMzOCcsJ25nZXFzbGFudCc6J1xcXFx1MkE3RVxcXFx1MDMzOCcsJ25nZXMnOidcXFxcdTJBN0VcXFxcdTAzMzgnLCduR2cnOidcXFxcdTIyRDlcXFxcdTAzMzgnLCduZ3NpbSc6J1xcXFx1MjI3NScsJ25ndCc6J1xcXFx1MjI2RicsJ25HdCc6J1xcXFx1MjI2QlxcXFx1MjBEMicsJ25ndHInOidcXFxcdTIyNkYnLCduR3R2JzonXFxcXHUyMjZCXFxcXHUwMzM4JywnbmhhcnInOidcXFxcdTIxQUUnLCduaEFycic6J1xcXFx1MjFDRScsJ25ocGFyJzonXFxcXHUyQUYyJywnbmknOidcXFxcdTIyMEInLCduaXMnOidcXFxcdTIyRkMnLCduaXNkJzonXFxcXHUyMkZBJywnbml2JzonXFxcXHUyMjBCJywnbmpjeSc6J1xcXFx1MDQ1QScsJ05KY3knOidcXFxcdTA0MEEnLCdubGFycic6J1xcXFx1MjE5QScsJ25sQXJyJzonXFxcXHUyMUNEJywnbmxkcic6J1xcXFx1MjAyNScsJ25sZSc6J1xcXFx1MjI3MCcsJ25sRSc6J1xcXFx1MjI2NlxcXFx1MDMzOCcsJ25sZWZ0YXJyb3cnOidcXFxcdTIxOUEnLCduTGVmdGFycm93JzonXFxcXHUyMUNEJywnbmxlZnRyaWdodGFycm93JzonXFxcXHUyMUFFJywnbkxlZnRyaWdodGFycm93JzonXFxcXHUyMUNFJywnbmxlcSc6J1xcXFx1MjI3MCcsJ25sZXFxJzonXFxcXHUyMjY2XFxcXHUwMzM4JywnbmxlcXNsYW50JzonXFxcXHUyQTdEXFxcXHUwMzM4Jywnbmxlcyc6J1xcXFx1MkE3RFxcXFx1MDMzOCcsJ25sZXNzJzonXFxcXHUyMjZFJywnbkxsJzonXFxcXHUyMkQ4XFxcXHUwMzM4JywnbmxzaW0nOidcXFxcdTIyNzQnLCdubHQnOidcXFxcdTIyNkUnLCduTHQnOidcXFxcdTIyNkFcXFxcdTIwRDInLCdubHRyaSc6J1xcXFx1MjJFQScsJ25sdHJpZSc6J1xcXFx1MjJFQycsJ25MdHYnOidcXFxcdTIyNkFcXFxcdTAzMzgnLCdubWlkJzonXFxcXHUyMjI0JywnTm9CcmVhayc6J1xcXFx1MjA2MCcsJ05vbkJyZWFraW5nU3BhY2UnOidcXFxceEEwJywnbm9wZic6J1xcXFx1RDgzNVxcXFx1REQ1RicsJ05vcGYnOidcXFxcdTIxMTUnLCdub3QnOidcXFxceEFDJywnTm90JzonXFxcXHUyQUVDJywnTm90Q29uZ3J1ZW50JzonXFxcXHUyMjYyJywnTm90Q3VwQ2FwJzonXFxcXHUyMjZEJywnTm90RG91YmxlVmVydGljYWxCYXInOidcXFxcdTIyMjYnLCdOb3RFbGVtZW50JzonXFxcXHUyMjA5JywnTm90RXF1YWwnOidcXFxcdTIyNjAnLCdOb3RFcXVhbFRpbGRlJzonXFxcXHUyMjQyXFxcXHUwMzM4JywnTm90RXhpc3RzJzonXFxcXHUyMjA0JywnTm90R3JlYXRlcic6J1xcXFx1MjI2RicsJ05vdEdyZWF0ZXJFcXVhbCc6J1xcXFx1MjI3MScsJ05vdEdyZWF0ZXJGdWxsRXF1YWwnOidcXFxcdTIyNjdcXFxcdTAzMzgnLCdOb3RHcmVhdGVyR3JlYXRlcic6J1xcXFx1MjI2QlxcXFx1MDMzOCcsJ05vdEdyZWF0ZXJMZXNzJzonXFxcXHUyMjc5JywnTm90R3JlYXRlclNsYW50RXF1YWwnOidcXFxcdTJBN0VcXFxcdTAzMzgnLCdOb3RHcmVhdGVyVGlsZGUnOidcXFxcdTIyNzUnLCdOb3RIdW1wRG93bkh1bXAnOidcXFxcdTIyNEVcXFxcdTAzMzgnLCdOb3RIdW1wRXF1YWwnOidcXFxcdTIyNEZcXFxcdTAzMzgnLCdub3Rpbic6J1xcXFx1MjIwOScsJ25vdGluZG90JzonXFxcXHUyMkY1XFxcXHUwMzM4Jywnbm90aW5FJzonXFxcXHUyMkY5XFxcXHUwMzM4Jywnbm90aW52YSc6J1xcXFx1MjIwOScsJ25vdGludmInOidcXFxcdTIyRjcnLCdub3RpbnZjJzonXFxcXHUyMkY2JywnTm90TGVmdFRyaWFuZ2xlJzonXFxcXHUyMkVBJywnTm90TGVmdFRyaWFuZ2xlQmFyJzonXFxcXHUyOUNGXFxcXHUwMzM4JywnTm90TGVmdFRyaWFuZ2xlRXF1YWwnOidcXFxcdTIyRUMnLCdOb3RMZXNzJzonXFxcXHUyMjZFJywnTm90TGVzc0VxdWFsJzonXFxcXHUyMjcwJywnTm90TGVzc0dyZWF0ZXInOidcXFxcdTIyNzgnLCdOb3RMZXNzTGVzcyc6J1xcXFx1MjI2QVxcXFx1MDMzOCcsJ05vdExlc3NTbGFudEVxdWFsJzonXFxcXHUyQTdEXFxcXHUwMzM4JywnTm90TGVzc1RpbGRlJzonXFxcXHUyMjc0JywnTm90TmVzdGVkR3JlYXRlckdyZWF0ZXInOidcXFxcdTJBQTJcXFxcdTAzMzgnLCdOb3ROZXN0ZWRMZXNzTGVzcyc6J1xcXFx1MkFBMVxcXFx1MDMzOCcsJ25vdG5pJzonXFxcXHUyMjBDJywnbm90bml2YSc6J1xcXFx1MjIwQycsJ25vdG5pdmInOidcXFxcdTIyRkUnLCdub3RuaXZjJzonXFxcXHUyMkZEJywnTm90UHJlY2VkZXMnOidcXFxcdTIyODAnLCdOb3RQcmVjZWRlc0VxdWFsJzonXFxcXHUyQUFGXFxcXHUwMzM4JywnTm90UHJlY2VkZXNTbGFudEVxdWFsJzonXFxcXHUyMkUwJywnTm90UmV2ZXJzZUVsZW1lbnQnOidcXFxcdTIyMEMnLCdOb3RSaWdodFRyaWFuZ2xlJzonXFxcXHUyMkVCJywnTm90UmlnaHRUcmlhbmdsZUJhcic6J1xcXFx1MjlEMFxcXFx1MDMzOCcsJ05vdFJpZ2h0VHJpYW5nbGVFcXVhbCc6J1xcXFx1MjJFRCcsJ05vdFNxdWFyZVN1YnNldCc6J1xcXFx1MjI4RlxcXFx1MDMzOCcsJ05vdFNxdWFyZVN1YnNldEVxdWFsJzonXFxcXHUyMkUyJywnTm90U3F1YXJlU3VwZXJzZXQnOidcXFxcdTIyOTBcXFxcdTAzMzgnLCdOb3RTcXVhcmVTdXBlcnNldEVxdWFsJzonXFxcXHUyMkUzJywnTm90U3Vic2V0JzonXFxcXHUyMjgyXFxcXHUyMEQyJywnTm90U3Vic2V0RXF1YWwnOidcXFxcdTIyODgnLCdOb3RTdWNjZWVkcyc6J1xcXFx1MjI4MScsJ05vdFN1Y2NlZWRzRXF1YWwnOidcXFxcdTJBQjBcXFxcdTAzMzgnLCdOb3RTdWNjZWVkc1NsYW50RXF1YWwnOidcXFxcdTIyRTEnLCdOb3RTdWNjZWVkc1RpbGRlJzonXFxcXHUyMjdGXFxcXHUwMzM4JywnTm90U3VwZXJzZXQnOidcXFxcdTIyODNcXFxcdTIwRDInLCdOb3RTdXBlcnNldEVxdWFsJzonXFxcXHUyMjg5JywnTm90VGlsZGUnOidcXFxcdTIyNDEnLCdOb3RUaWxkZUVxdWFsJzonXFxcXHUyMjQ0JywnTm90VGlsZGVGdWxsRXF1YWwnOidcXFxcdTIyNDcnLCdOb3RUaWxkZVRpbGRlJzonXFxcXHUyMjQ5JywnTm90VmVydGljYWxCYXInOidcXFxcdTIyMjQnLCducGFyJzonXFxcXHUyMjI2JywnbnBhcmFsbGVsJzonXFxcXHUyMjI2JywnbnBhcnNsJzonXFxcXHUyQUZEXFxcXHUyMEU1JywnbnBhcnQnOidcXFxcdTIyMDJcXFxcdTAzMzgnLCducG9saW50JzonXFxcXHUyQTE0JywnbnByJzonXFxcXHUyMjgwJywnbnByY3VlJzonXFxcXHUyMkUwJywnbnByZSc6J1xcXFx1MkFBRlxcXFx1MDMzOCcsJ25wcmVjJzonXFxcXHUyMjgwJywnbnByZWNlcSc6J1xcXFx1MkFBRlxcXFx1MDMzOCcsJ25yYXJyJzonXFxcXHUyMTlCJywnbnJBcnInOidcXFxcdTIxQ0YnLCducmFycmMnOidcXFxcdTI5MzNcXFxcdTAzMzgnLCducmFycncnOidcXFxcdTIxOURcXFxcdTAzMzgnLCducmlnaHRhcnJvdyc6J1xcXFx1MjE5QicsJ25SaWdodGFycm93JzonXFxcXHUyMUNGJywnbnJ0cmknOidcXFxcdTIyRUInLCducnRyaWUnOidcXFxcdTIyRUQnLCduc2MnOidcXFxcdTIyODEnLCduc2NjdWUnOidcXFxcdTIyRTEnLCduc2NlJzonXFxcXHUyQUIwXFxcXHUwMzM4JywnbnNjcic6J1xcXFx1RDgzNVxcXFx1RENDMycsJ05zY3InOidcXFxcdUQ4MzVcXFxcdURDQTknLCduc2hvcnRtaWQnOidcXFxcdTIyMjQnLCduc2hvcnRwYXJhbGxlbCc6J1xcXFx1MjIyNicsJ25zaW0nOidcXFxcdTIyNDEnLCduc2ltZSc6J1xcXFx1MjI0NCcsJ25zaW1lcSc6J1xcXFx1MjI0NCcsJ25zbWlkJzonXFxcXHUyMjI0JywnbnNwYXInOidcXFxcdTIyMjYnLCduc3FzdWJlJzonXFxcXHUyMkUyJywnbnNxc3VwZSc6J1xcXFx1MjJFMycsJ25zdWInOidcXFxcdTIyODQnLCduc3ViZSc6J1xcXFx1MjI4OCcsJ25zdWJFJzonXFxcXHUyQUM1XFxcXHUwMzM4JywnbnN1YnNldCc6J1xcXFx1MjI4MlxcXFx1MjBEMicsJ25zdWJzZXRlcSc6J1xcXFx1MjI4OCcsJ25zdWJzZXRlcXEnOidcXFxcdTJBQzVcXFxcdTAzMzgnLCduc3VjYyc6J1xcXFx1MjI4MScsJ25zdWNjZXEnOidcXFxcdTJBQjBcXFxcdTAzMzgnLCduc3VwJzonXFxcXHUyMjg1JywnbnN1cGUnOidcXFxcdTIyODknLCduc3VwRSc6J1xcXFx1MkFDNlxcXFx1MDMzOCcsJ25zdXBzZXQnOidcXFxcdTIyODNcXFxcdTIwRDInLCduc3Vwc2V0ZXEnOidcXFxcdTIyODknLCduc3Vwc2V0ZXFxJzonXFxcXHUyQUM2XFxcXHUwMzM4JywnbnRnbCc6J1xcXFx1MjI3OScsJ250aWxkZSc6J1xcXFx4RjEnLCdOdGlsZGUnOidcXFxceEQxJywnbnRsZyc6J1xcXFx1MjI3OCcsJ250cmlhbmdsZWxlZnQnOidcXFxcdTIyRUEnLCdudHJpYW5nbGVsZWZ0ZXEnOidcXFxcdTIyRUMnLCdudHJpYW5nbGVyaWdodCc6J1xcXFx1MjJFQicsJ250cmlhbmdsZXJpZ2h0ZXEnOidcXFxcdTIyRUQnLCdudSc6J1xcXFx1MDNCRCcsJ051JzonXFxcXHUwMzlEJywnbnVtJzonIycsJ251bWVybyc6J1xcXFx1MjExNicsJ251bXNwJzonXFxcXHUyMDA3JywnbnZhcCc6J1xcXFx1MjI0RFxcXFx1MjBEMicsJ252ZGFzaCc6J1xcXFx1MjJBQycsJ252RGFzaCc6J1xcXFx1MjJBRCcsJ25WZGFzaCc6J1xcXFx1MjJBRScsJ25WRGFzaCc6J1xcXFx1MjJBRicsJ252Z2UnOidcXFxcdTIyNjVcXFxcdTIwRDInLCdudmd0JzonPlxcXFx1MjBEMicsJ252SGFycic6J1xcXFx1MjkwNCcsJ252aW5maW4nOidcXFxcdTI5REUnLCdudmxBcnInOidcXFxcdTI5MDInLCdudmxlJzonXFxcXHUyMjY0XFxcXHUyMEQyJywnbnZsdCc6JzxcXFxcdTIwRDInLCdudmx0cmllJzonXFxcXHUyMkI0XFxcXHUyMEQyJywnbnZyQXJyJzonXFxcXHUyOTAzJywnbnZydHJpZSc6J1xcXFx1MjJCNVxcXFx1MjBEMicsJ252c2ltJzonXFxcXHUyMjNDXFxcXHUyMEQyJywnbndhcmhrJzonXFxcXHUyOTIzJywnbndhcnInOidcXFxcdTIxOTYnLCdud0Fycic6J1xcXFx1MjFENicsJ253YXJyb3cnOidcXFxcdTIxOTYnLCdud25lYXInOidcXFxcdTI5MjcnLCdvYWN1dGUnOidcXFxceEYzJywnT2FjdXRlJzonXFxcXHhEMycsJ29hc3QnOidcXFxcdTIyOUInLCdvY2lyJzonXFxcXHUyMjlBJywnb2NpcmMnOidcXFxceEY0JywnT2NpcmMnOidcXFxceEQ0Jywnb2N5JzonXFxcXHUwNDNFJywnT2N5JzonXFxcXHUwNDFFJywnb2Rhc2gnOidcXFxcdTIyOUQnLCdvZGJsYWMnOidcXFxcdTAxNTEnLCdPZGJsYWMnOidcXFxcdTAxNTAnLCdvZGl2JzonXFxcXHUyQTM4Jywnb2RvdCc6J1xcXFx1MjI5OScsJ29kc29sZCc6J1xcXFx1MjlCQycsJ29lbGlnJzonXFxcXHUwMTUzJywnT0VsaWcnOidcXFxcdTAxNTInLCdvZmNpcic6J1xcXFx1MjlCRicsJ29mcic6J1xcXFx1RDgzNVxcXFx1REQyQycsJ09mcic6J1xcXFx1RDgzNVxcXFx1REQxMicsJ29nb24nOidcXFxcdTAyREInLCdvZ3JhdmUnOidcXFxceEYyJywnT2dyYXZlJzonXFxcXHhEMicsJ29ndCc6J1xcXFx1MjlDMScsJ29oYmFyJzonXFxcXHUyOUI1Jywnb2htJzonXFxcXHUwM0E5Jywnb2ludCc6J1xcXFx1MjIyRScsJ29sYXJyJzonXFxcXHUyMUJBJywnb2xjaXInOidcXFxcdTI5QkUnLCdvbGNyb3NzJzonXFxcXHUyOUJCJywnb2xpbmUnOidcXFxcdTIwM0UnLCdvbHQnOidcXFxcdTI5QzAnLCdvbWFjcic6J1xcXFx1MDE0RCcsJ09tYWNyJzonXFxcXHUwMTRDJywnb21lZ2EnOidcXFxcdTAzQzknLCdPbWVnYSc6J1xcXFx1MDNBOScsJ29taWNyb24nOidcXFxcdTAzQkYnLCdPbWljcm9uJzonXFxcXHUwMzlGJywnb21pZCc6J1xcXFx1MjlCNicsJ29taW51cyc6J1xcXFx1MjI5NicsJ29vcGYnOidcXFxcdUQ4MzVcXFxcdURENjAnLCdPb3BmJzonXFxcXHVEODM1XFxcXHVERDQ2Jywnb3Bhcic6J1xcXFx1MjlCNycsJ09wZW5DdXJseURvdWJsZVF1b3RlJzonXFxcXHUyMDFDJywnT3BlbkN1cmx5UXVvdGUnOidcXFxcdTIwMTgnLCdvcGVycCc6J1xcXFx1MjlCOScsJ29wbHVzJzonXFxcXHUyMjk1Jywnb3InOidcXFxcdTIyMjgnLCdPcic6J1xcXFx1MkE1NCcsJ29yYXJyJzonXFxcXHUyMUJCJywnb3JkJzonXFxcXHUyQTVEJywnb3JkZXInOidcXFxcdTIxMzQnLCdvcmRlcm9mJzonXFxcXHUyMTM0Jywnb3JkZic6J1xcXFx4QUEnLCdvcmRtJzonXFxcXHhCQScsJ29yaWdvZic6J1xcXFx1MjJCNicsJ29yb3InOidcXFxcdTJBNTYnLCdvcnNsb3BlJzonXFxcXHUyQTU3Jywnb3J2JzonXFxcXHUyQTVCJywnb1MnOidcXFxcdTI0QzgnLCdvc2NyJzonXFxcXHUyMTM0JywnT3Njcic6J1xcXFx1RDgzNVxcXFx1RENBQScsJ29zbGFzaCc6J1xcXFx4RjgnLCdPc2xhc2gnOidcXFxceEQ4Jywnb3NvbCc6J1xcXFx1MjI5OCcsJ290aWxkZSc6J1xcXFx4RjUnLCdPdGlsZGUnOidcXFxceEQ1Jywnb3RpbWVzJzonXFxcXHUyMjk3JywnT3RpbWVzJzonXFxcXHUyQTM3Jywnb3RpbWVzYXMnOidcXFxcdTJBMzYnLCdvdW1sJzonXFxcXHhGNicsJ091bWwnOidcXFxceEQ2Jywnb3ZiYXInOidcXFxcdTIzM0QnLCdPdmVyQmFyJzonXFxcXHUyMDNFJywnT3ZlckJyYWNlJzonXFxcXHUyM0RFJywnT3ZlckJyYWNrZXQnOidcXFxcdTIzQjQnLCdPdmVyUGFyZW50aGVzaXMnOidcXFxcdTIzREMnLCdwYXInOidcXFxcdTIyMjUnLCdwYXJhJzonXFxcXHhCNicsJ3BhcmFsbGVsJzonXFxcXHUyMjI1JywncGFyc2ltJzonXFxcXHUyQUYzJywncGFyc2wnOidcXFxcdTJBRkQnLCdwYXJ0JzonXFxcXHUyMjAyJywnUGFydGlhbEQnOidcXFxcdTIyMDInLCdwY3knOidcXFxcdTA0M0YnLCdQY3knOidcXFxcdTA0MUYnLCdwZXJjbnQnOiclJywncGVyaW9kJzonLicsJ3Blcm1pbCc6J1xcXFx1MjAzMCcsJ3BlcnAnOidcXFxcdTIyQTUnLCdwZXJ0ZW5rJzonXFxcXHUyMDMxJywncGZyJzonXFxcXHVEODM1XFxcXHVERDJEJywnUGZyJzonXFxcXHVEODM1XFxcXHVERDEzJywncGhpJzonXFxcXHUwM0M2JywnUGhpJzonXFxcXHUwM0E2JywncGhpdic6J1xcXFx1MDNENScsJ3BobW1hdCc6J1xcXFx1MjEzMycsJ3Bob25lJzonXFxcXHUyNjBFJywncGknOidcXFxcdTAzQzAnLCdQaSc6J1xcXFx1MDNBMCcsJ3BpdGNoZm9yayc6J1xcXFx1MjJENCcsJ3Bpdic6J1xcXFx1MDNENicsJ3BsYW5jayc6J1xcXFx1MjEwRicsJ3BsYW5ja2gnOidcXFxcdTIxMEUnLCdwbGFua3YnOidcXFxcdTIxMEYnLCdwbHVzJzonKycsJ3BsdXNhY2lyJzonXFxcXHUyQTIzJywncGx1c2InOidcXFxcdTIyOUUnLCdwbHVzY2lyJzonXFxcXHUyQTIyJywncGx1c2RvJzonXFxcXHUyMjE0JywncGx1c2R1JzonXFxcXHUyQTI1JywncGx1c2UnOidcXFxcdTJBNzInLCdQbHVzTWludXMnOidcXFxceEIxJywncGx1c21uJzonXFxcXHhCMScsJ3BsdXNzaW0nOidcXFxcdTJBMjYnLCdwbHVzdHdvJzonXFxcXHUyQTI3JywncG0nOidcXFxceEIxJywnUG9pbmNhcmVwbGFuZSc6J1xcXFx1MjEwQycsJ3BvaW50aW50JzonXFxcXHUyQTE1JywncG9wZic6J1xcXFx1RDgzNVxcXFx1REQ2MScsJ1BvcGYnOidcXFxcdTIxMTknLCdwb3VuZCc6J1xcXFx4QTMnLCdwcic6J1xcXFx1MjI3QScsJ1ByJzonXFxcXHUyQUJCJywncHJhcCc6J1xcXFx1MkFCNycsJ3ByY3VlJzonXFxcXHUyMjdDJywncHJlJzonXFxcXHUyQUFGJywncHJFJzonXFxcXHUyQUIzJywncHJlYyc6J1xcXFx1MjI3QScsJ3ByZWNhcHByb3gnOidcXFxcdTJBQjcnLCdwcmVjY3VybHllcSc6J1xcXFx1MjI3QycsJ1ByZWNlZGVzJzonXFxcXHUyMjdBJywnUHJlY2VkZXNFcXVhbCc6J1xcXFx1MkFBRicsJ1ByZWNlZGVzU2xhbnRFcXVhbCc6J1xcXFx1MjI3QycsJ1ByZWNlZGVzVGlsZGUnOidcXFxcdTIyN0UnLCdwcmVjZXEnOidcXFxcdTJBQUYnLCdwcmVjbmFwcHJveCc6J1xcXFx1MkFCOScsJ3ByZWNuZXFxJzonXFxcXHUyQUI1JywncHJlY25zaW0nOidcXFxcdTIyRTgnLCdwcmVjc2ltJzonXFxcXHUyMjdFJywncHJpbWUnOidcXFxcdTIwMzInLCdQcmltZSc6J1xcXFx1MjAzMycsJ3ByaW1lcyc6J1xcXFx1MjExOScsJ3BybmFwJzonXFxcXHUyQUI5JywncHJuRSc6J1xcXFx1MkFCNScsJ3BybnNpbSc6J1xcXFx1MjJFOCcsJ3Byb2QnOidcXFxcdTIyMEYnLCdQcm9kdWN0JzonXFxcXHUyMjBGJywncHJvZmFsYXInOidcXFxcdTIzMkUnLCdwcm9mbGluZSc6J1xcXFx1MjMxMicsJ3Byb2ZzdXJmJzonXFxcXHUyMzEzJywncHJvcCc6J1xcXFx1MjIxRCcsJ1Byb3BvcnRpb24nOidcXFxcdTIyMzcnLCdQcm9wb3J0aW9uYWwnOidcXFxcdTIyMUQnLCdwcm9wdG8nOidcXFxcdTIyMUQnLCdwcnNpbSc6J1xcXFx1MjI3RScsJ3BydXJlbCc6J1xcXFx1MjJCMCcsJ3BzY3InOidcXFxcdUQ4MzVcXFxcdURDQzUnLCdQc2NyJzonXFxcXHVEODM1XFxcXHVEQ0FCJywncHNpJzonXFxcXHUwM0M4JywnUHNpJzonXFxcXHUwM0E4JywncHVuY3NwJzonXFxcXHUyMDA4JywncWZyJzonXFxcXHVEODM1XFxcXHVERDJFJywnUWZyJzonXFxcXHVEODM1XFxcXHVERDE0JywncWludCc6J1xcXFx1MkEwQycsJ3FvcGYnOidcXFxcdUQ4MzVcXFxcdURENjInLCdRb3BmJzonXFxcXHUyMTFBJywncXByaW1lJzonXFxcXHUyMDU3JywncXNjcic6J1xcXFx1RDgzNVxcXFx1RENDNicsJ1FzY3InOidcXFxcdUQ4MzVcXFxcdURDQUMnLCdxdWF0ZXJuaW9ucyc6J1xcXFx1MjEwRCcsJ3F1YXRpbnQnOidcXFxcdTJBMTYnLCdxdWVzdCc6Jz8nLCdxdWVzdGVxJzonXFxcXHUyMjVGJywncXVvdCc6J1xcXCInLCdRVU9UJzonXFxcIicsJ3JBYXJyJzonXFxcXHUyMURCJywncmFjZSc6J1xcXFx1MjIzRFxcXFx1MDMzMScsJ3JhY3V0ZSc6J1xcXFx1MDE1NScsJ1JhY3V0ZSc6J1xcXFx1MDE1NCcsJ3JhZGljJzonXFxcXHUyMjFBJywncmFlbXB0eXYnOidcXFxcdTI5QjMnLCdyYW5nJzonXFxcXHUyN0U5JywnUmFuZyc6J1xcXFx1MjdFQicsJ3JhbmdkJzonXFxcXHUyOTkyJywncmFuZ2UnOidcXFxcdTI5QTUnLCdyYW5nbGUnOidcXFxcdTI3RTknLCdyYXF1byc6J1xcXFx4QkInLCdyYXJyJzonXFxcXHUyMTkyJywnckFycic6J1xcXFx1MjFEMicsJ1JhcnInOidcXFxcdTIxQTAnLCdyYXJyYXAnOidcXFxcdTI5NzUnLCdyYXJyYic6J1xcXFx1MjFFNScsJ3JhcnJiZnMnOidcXFxcdTI5MjAnLCdyYXJyYyc6J1xcXFx1MjkzMycsJ3JhcnJmcyc6J1xcXFx1MjkxRScsJ3JhcnJoayc6J1xcXFx1MjFBQScsJ3JhcnJscCc6J1xcXFx1MjFBQycsJ3JhcnJwbCc6J1xcXFx1Mjk0NScsJ3JhcnJzaW0nOidcXFxcdTI5NzQnLCdyYXJydGwnOidcXFxcdTIxQTMnLCdSYXJydGwnOidcXFxcdTI5MTYnLCdyYXJydyc6J1xcXFx1MjE5RCcsJ3JhdGFpbCc6J1xcXFx1MjkxQScsJ3JBdGFpbCc6J1xcXFx1MjkxQycsJ3JhdGlvJzonXFxcXHUyMjM2JywncmF0aW9uYWxzJzonXFxcXHUyMTFBJywncmJhcnInOidcXFxcdTI5MEQnLCdyQmFycic6J1xcXFx1MjkwRicsJ1JCYXJyJzonXFxcXHUyOTEwJywncmJicmsnOidcXFxcdTI3NzMnLCdyYnJhY2UnOid9JywncmJyYWNrJzonXScsJ3JicmtlJzonXFxcXHUyOThDJywncmJya3NsZCc6J1xcXFx1Mjk4RScsJ3JicmtzbHUnOidcXFxcdTI5OTAnLCdyY2Fyb24nOidcXFxcdTAxNTknLCdSY2Fyb24nOidcXFxcdTAxNTgnLCdyY2VkaWwnOidcXFxcdTAxNTcnLCdSY2VkaWwnOidcXFxcdTAxNTYnLCdyY2VpbCc6J1xcXFx1MjMwOScsJ3JjdWInOid9JywncmN5JzonXFxcXHUwNDQwJywnUmN5JzonXFxcXHUwNDIwJywncmRjYSc6J1xcXFx1MjkzNycsJ3JkbGRoYXInOidcXFxcdTI5NjknLCdyZHF1byc6J1xcXFx1MjAxRCcsJ3JkcXVvcic6J1xcXFx1MjAxRCcsJ3Jkc2gnOidcXFxcdTIxQjMnLCdSZSc6J1xcXFx1MjExQycsJ3JlYWwnOidcXFxcdTIxMUMnLCdyZWFsaW5lJzonXFxcXHUyMTFCJywncmVhbHBhcnQnOidcXFxcdTIxMUMnLCdyZWFscyc6J1xcXFx1MjExRCcsJ3JlY3QnOidcXFxcdTI1QUQnLCdyZWcnOidcXFxceEFFJywnUkVHJzonXFxcXHhBRScsJ1JldmVyc2VFbGVtZW50JzonXFxcXHUyMjBCJywnUmV2ZXJzZUVxdWlsaWJyaXVtJzonXFxcXHUyMUNCJywnUmV2ZXJzZVVwRXF1aWxpYnJpdW0nOidcXFxcdTI5NkYnLCdyZmlzaHQnOidcXFxcdTI5N0QnLCdyZmxvb3InOidcXFxcdTIzMEInLCdyZnInOidcXFxcdUQ4MzVcXFxcdUREMkYnLCdSZnInOidcXFxcdTIxMUMnLCdySGFyJzonXFxcXHUyOTY0JywncmhhcmQnOidcXFxcdTIxQzEnLCdyaGFydSc6J1xcXFx1MjFDMCcsJ3JoYXJ1bCc6J1xcXFx1Mjk2QycsJ3Jobyc6J1xcXFx1MDNDMScsJ1Jobyc6J1xcXFx1MDNBMScsJ3Job3YnOidcXFxcdTAzRjEnLCdSaWdodEFuZ2xlQnJhY2tldCc6J1xcXFx1MjdFOScsJ3JpZ2h0YXJyb3cnOidcXFxcdTIxOTInLCdSaWdodGFycm93JzonXFxcXHUyMUQyJywnUmlnaHRBcnJvdyc6J1xcXFx1MjE5MicsJ1JpZ2h0QXJyb3dCYXInOidcXFxcdTIxRTUnLCdSaWdodEFycm93TGVmdEFycm93JzonXFxcXHUyMUM0JywncmlnaHRhcnJvd3RhaWwnOidcXFxcdTIxQTMnLCdSaWdodENlaWxpbmcnOidcXFxcdTIzMDknLCdSaWdodERvdWJsZUJyYWNrZXQnOidcXFxcdTI3RTcnLCdSaWdodERvd25UZWVWZWN0b3InOidcXFxcdTI5NUQnLCdSaWdodERvd25WZWN0b3InOidcXFxcdTIxQzInLCdSaWdodERvd25WZWN0b3JCYXInOidcXFxcdTI5NTUnLCdSaWdodEZsb29yJzonXFxcXHUyMzBCJywncmlnaHRoYXJwb29uZG93bic6J1xcXFx1MjFDMScsJ3JpZ2h0aGFycG9vbnVwJzonXFxcXHUyMUMwJywncmlnaHRsZWZ0YXJyb3dzJzonXFxcXHUyMUM0JywncmlnaHRsZWZ0aGFycG9vbnMnOidcXFxcdTIxQ0MnLCdyaWdodHJpZ2h0YXJyb3dzJzonXFxcXHUyMUM5JywncmlnaHRzcXVpZ2Fycm93JzonXFxcXHUyMTlEJywnUmlnaHRUZWUnOidcXFxcdTIyQTInLCdSaWdodFRlZUFycm93JzonXFxcXHUyMUE2JywnUmlnaHRUZWVWZWN0b3InOidcXFxcdTI5NUInLCdyaWdodHRocmVldGltZXMnOidcXFxcdTIyQ0MnLCdSaWdodFRyaWFuZ2xlJzonXFxcXHUyMkIzJywnUmlnaHRUcmlhbmdsZUJhcic6J1xcXFx1MjlEMCcsJ1JpZ2h0VHJpYW5nbGVFcXVhbCc6J1xcXFx1MjJCNScsJ1JpZ2h0VXBEb3duVmVjdG9yJzonXFxcXHUyOTRGJywnUmlnaHRVcFRlZVZlY3Rvcic6J1xcXFx1Mjk1QycsJ1JpZ2h0VXBWZWN0b3InOidcXFxcdTIxQkUnLCdSaWdodFVwVmVjdG9yQmFyJzonXFxcXHUyOTU0JywnUmlnaHRWZWN0b3InOidcXFxcdTIxQzAnLCdSaWdodFZlY3RvckJhcic6J1xcXFx1Mjk1MycsJ3JpbmcnOidcXFxcdTAyREEnLCdyaXNpbmdkb3RzZXEnOidcXFxcdTIyNTMnLCdybGFycic6J1xcXFx1MjFDNCcsJ3JsaGFyJzonXFxcXHUyMUNDJywncmxtJzonXFxcXHUyMDBGJywncm1vdXN0JzonXFxcXHUyM0IxJywncm1vdXN0YWNoZSc6J1xcXFx1MjNCMScsJ3JubWlkJzonXFxcXHUyQUVFJywncm9hbmcnOidcXFxcdTI3RUQnLCdyb2Fycic6J1xcXFx1MjFGRScsJ3JvYnJrJzonXFxcXHUyN0U3Jywncm9wYXInOidcXFxcdTI5ODYnLCdyb3BmJzonXFxcXHVEODM1XFxcXHVERDYzJywnUm9wZic6J1xcXFx1MjExRCcsJ3JvcGx1cyc6J1xcXFx1MkEyRScsJ3JvdGltZXMnOidcXFxcdTJBMzUnLCdSb3VuZEltcGxpZXMnOidcXFxcdTI5NzAnLCdycGFyJzonKScsJ3JwYXJndCc6J1xcXFx1Mjk5NCcsJ3JwcG9saW50JzonXFxcXHUyQTEyJywncnJhcnInOidcXFxcdTIxQzknLCdScmlnaHRhcnJvdyc6J1xcXFx1MjFEQicsJ3JzYXF1byc6J1xcXFx1MjAzQScsJ3JzY3InOidcXFxcdUQ4MzVcXFxcdURDQzcnLCdSc2NyJzonXFxcXHUyMTFCJywncnNoJzonXFxcXHUyMUIxJywnUnNoJzonXFxcXHUyMUIxJywncnNxYic6J10nLCdyc3F1byc6J1xcXFx1MjAxOScsJ3JzcXVvcic6J1xcXFx1MjAxOScsJ3J0aHJlZSc6J1xcXFx1MjJDQycsJ3J0aW1lcyc6J1xcXFx1MjJDQScsJ3J0cmknOidcXFxcdTI1QjknLCdydHJpZSc6J1xcXFx1MjJCNScsJ3J0cmlmJzonXFxcXHUyNUI4JywncnRyaWx0cmknOidcXFxcdTI5Q0UnLCdSdWxlRGVsYXllZCc6J1xcXFx1MjlGNCcsJ3J1bHVoYXInOidcXFxcdTI5NjgnLCdyeCc6J1xcXFx1MjExRScsJ3NhY3V0ZSc6J1xcXFx1MDE1QicsJ1NhY3V0ZSc6J1xcXFx1MDE1QScsJ3NicXVvJzonXFxcXHUyMDFBJywnc2MnOidcXFxcdTIyN0InLCdTYyc6J1xcXFx1MkFCQycsJ3NjYXAnOidcXFxcdTJBQjgnLCdzY2Fyb24nOidcXFxcdTAxNjEnLCdTY2Fyb24nOidcXFxcdTAxNjAnLCdzY2N1ZSc6J1xcXFx1MjI3RCcsJ3NjZSc6J1xcXFx1MkFCMCcsJ3NjRSc6J1xcXFx1MkFCNCcsJ3NjZWRpbCc6J1xcXFx1MDE1RicsJ1NjZWRpbCc6J1xcXFx1MDE1RScsJ3NjaXJjJzonXFxcXHUwMTVEJywnU2NpcmMnOidcXFxcdTAxNUMnLCdzY25hcCc6J1xcXFx1MkFCQScsJ3NjbkUnOidcXFxcdTJBQjYnLCdzY25zaW0nOidcXFxcdTIyRTknLCdzY3BvbGludCc6J1xcXFx1MkExMycsJ3Njc2ltJzonXFxcXHUyMjdGJywnc2N5JzonXFxcXHUwNDQxJywnU2N5JzonXFxcXHUwNDIxJywnc2RvdCc6J1xcXFx1MjJDNScsJ3Nkb3RiJzonXFxcXHUyMkExJywnc2RvdGUnOidcXFxcdTJBNjYnLCdzZWFyaGsnOidcXFxcdTI5MjUnLCdzZWFycic6J1xcXFx1MjE5OCcsJ3NlQXJyJzonXFxcXHUyMUQ4Jywnc2VhcnJvdyc6J1xcXFx1MjE5OCcsJ3NlY3QnOidcXFxceEE3Jywnc2VtaSc6JzsnLCdzZXN3YXInOidcXFxcdTI5MjknLCdzZXRtaW51cyc6J1xcXFx1MjIxNicsJ3NldG1uJzonXFxcXHUyMjE2Jywnc2V4dCc6J1xcXFx1MjczNicsJ3Nmcic6J1xcXFx1RDgzNVxcXFx1REQzMCcsJ1Nmcic6J1xcXFx1RDgzNVxcXFx1REQxNicsJ3Nmcm93bic6J1xcXFx1MjMyMicsJ3NoYXJwJzonXFxcXHUyNjZGJywnc2hjaGN5JzonXFxcXHUwNDQ5JywnU0hDSGN5JzonXFxcXHUwNDI5Jywnc2hjeSc6J1xcXFx1MDQ0OCcsJ1NIY3knOidcXFxcdTA0MjgnLCdTaG9ydERvd25BcnJvdyc6J1xcXFx1MjE5MycsJ1Nob3J0TGVmdEFycm93JzonXFxcXHUyMTkwJywnc2hvcnRtaWQnOidcXFxcdTIyMjMnLCdzaG9ydHBhcmFsbGVsJzonXFxcXHUyMjI1JywnU2hvcnRSaWdodEFycm93JzonXFxcXHUyMTkyJywnU2hvcnRVcEFycm93JzonXFxcXHUyMTkxJywnc2h5JzonXFxcXHhBRCcsJ3NpZ21hJzonXFxcXHUwM0MzJywnU2lnbWEnOidcXFxcdTAzQTMnLCdzaWdtYWYnOidcXFxcdTAzQzInLCdzaWdtYXYnOidcXFxcdTAzQzInLCdzaW0nOidcXFxcdTIyM0MnLCdzaW1kb3QnOidcXFxcdTJBNkEnLCdzaW1lJzonXFxcXHUyMjQzJywnc2ltZXEnOidcXFxcdTIyNDMnLCdzaW1nJzonXFxcXHUyQTlFJywnc2ltZ0UnOidcXFxcdTJBQTAnLCdzaW1sJzonXFxcXHUyQTlEJywnc2ltbEUnOidcXFxcdTJBOUYnLCdzaW1uZSc6J1xcXFx1MjI0NicsJ3NpbXBsdXMnOidcXFxcdTJBMjQnLCdzaW1yYXJyJzonXFxcXHUyOTcyJywnc2xhcnInOidcXFxcdTIxOTAnLCdTbWFsbENpcmNsZSc6J1xcXFx1MjIxOCcsJ3NtYWxsc2V0bWludXMnOidcXFxcdTIyMTYnLCdzbWFzaHAnOidcXFxcdTJBMzMnLCdzbWVwYXJzbCc6J1xcXFx1MjlFNCcsJ3NtaWQnOidcXFxcdTIyMjMnLCdzbWlsZSc6J1xcXFx1MjMyMycsJ3NtdCc6J1xcXFx1MkFBQScsJ3NtdGUnOidcXFxcdTJBQUMnLCdzbXRlcyc6J1xcXFx1MkFBQ1xcXFx1RkUwMCcsJ3NvZnRjeSc6J1xcXFx1MDQ0QycsJ1NPRlRjeSc6J1xcXFx1MDQyQycsJ3NvbCc6Jy8nLCdzb2xiJzonXFxcXHUyOUM0Jywnc29sYmFyJzonXFxcXHUyMzNGJywnc29wZic6J1xcXFx1RDgzNVxcXFx1REQ2NCcsJ1NvcGYnOidcXFxcdUQ4MzVcXFxcdURENEEnLCdzcGFkZXMnOidcXFxcdTI2NjAnLCdzcGFkZXN1aXQnOidcXFxcdTI2NjAnLCdzcGFyJzonXFxcXHUyMjI1Jywnc3FjYXAnOidcXFxcdTIyOTMnLCdzcWNhcHMnOidcXFxcdTIyOTNcXFxcdUZFMDAnLCdzcWN1cCc6J1xcXFx1MjI5NCcsJ3NxY3Vwcyc6J1xcXFx1MjI5NFxcXFx1RkUwMCcsJ1NxcnQnOidcXFxcdTIyMUEnLCdzcXN1Yic6J1xcXFx1MjI4RicsJ3Nxc3ViZSc6J1xcXFx1MjI5MScsJ3Nxc3Vic2V0JzonXFxcXHUyMjhGJywnc3FzdWJzZXRlcSc6J1xcXFx1MjI5MScsJ3Nxc3VwJzonXFxcXHUyMjkwJywnc3FzdXBlJzonXFxcXHUyMjkyJywnc3FzdXBzZXQnOidcXFxcdTIyOTAnLCdzcXN1cHNldGVxJzonXFxcXHUyMjkyJywnc3F1JzonXFxcXHUyNUExJywnc3F1YXJlJzonXFxcXHUyNUExJywnU3F1YXJlJzonXFxcXHUyNUExJywnU3F1YXJlSW50ZXJzZWN0aW9uJzonXFxcXHUyMjkzJywnU3F1YXJlU3Vic2V0JzonXFxcXHUyMjhGJywnU3F1YXJlU3Vic2V0RXF1YWwnOidcXFxcdTIyOTEnLCdTcXVhcmVTdXBlcnNldCc6J1xcXFx1MjI5MCcsJ1NxdWFyZVN1cGVyc2V0RXF1YWwnOidcXFxcdTIyOTInLCdTcXVhcmVVbmlvbic6J1xcXFx1MjI5NCcsJ3NxdWFyZic6J1xcXFx1MjVBQScsJ3NxdWYnOidcXFxcdTI1QUEnLCdzcmFycic6J1xcXFx1MjE5MicsJ3NzY3InOidcXFxcdUQ4MzVcXFxcdURDQzgnLCdTc2NyJzonXFxcXHVEODM1XFxcXHVEQ0FFJywnc3NldG1uJzonXFxcXHUyMjE2Jywnc3NtaWxlJzonXFxcXHUyMzIzJywnc3N0YXJmJzonXFxcXHUyMkM2Jywnc3Rhcic6J1xcXFx1MjYwNicsJ1N0YXInOidcXFxcdTIyQzYnLCdzdGFyZic6J1xcXFx1MjYwNScsJ3N0cmFpZ2h0ZXBzaWxvbic6J1xcXFx1MDNGNScsJ3N0cmFpZ2h0cGhpJzonXFxcXHUwM0Q1Jywnc3RybnMnOidcXFxceEFGJywnc3ViJzonXFxcXHUyMjgyJywnU3ViJzonXFxcXHUyMkQwJywnc3ViZG90JzonXFxcXHUyQUJEJywnc3ViZSc6J1xcXFx1MjI4NicsJ3N1YkUnOidcXFxcdTJBQzUnLCdzdWJlZG90JzonXFxcXHUyQUMzJywnc3VibXVsdCc6J1xcXFx1MkFDMScsJ3N1Ym5lJzonXFxcXHUyMjhBJywnc3VibkUnOidcXFxcdTJBQ0InLCdzdWJwbHVzJzonXFxcXHUyQUJGJywnc3VicmFycic6J1xcXFx1Mjk3OScsJ3N1YnNldCc6J1xcXFx1MjI4MicsJ1N1YnNldCc6J1xcXFx1MjJEMCcsJ3N1YnNldGVxJzonXFxcXHUyMjg2Jywnc3Vic2V0ZXFxJzonXFxcXHUyQUM1JywnU3Vic2V0RXF1YWwnOidcXFxcdTIyODYnLCdzdWJzZXRuZXEnOidcXFxcdTIyOEEnLCdzdWJzZXRuZXFxJzonXFxcXHUyQUNCJywnc3Vic2ltJzonXFxcXHUyQUM3Jywnc3Vic3ViJzonXFxcXHUyQUQ1Jywnc3Vic3VwJzonXFxcXHUyQUQzJywnc3VjYyc6J1xcXFx1MjI3QicsJ3N1Y2NhcHByb3gnOidcXFxcdTJBQjgnLCdzdWNjY3VybHllcSc6J1xcXFx1MjI3RCcsJ1N1Y2NlZWRzJzonXFxcXHUyMjdCJywnU3VjY2VlZHNFcXVhbCc6J1xcXFx1MkFCMCcsJ1N1Y2NlZWRzU2xhbnRFcXVhbCc6J1xcXFx1MjI3RCcsJ1N1Y2NlZWRzVGlsZGUnOidcXFxcdTIyN0YnLCdzdWNjZXEnOidcXFxcdTJBQjAnLCdzdWNjbmFwcHJveCc6J1xcXFx1MkFCQScsJ3N1Y2NuZXFxJzonXFxcXHUyQUI2Jywnc3VjY25zaW0nOidcXFxcdTIyRTknLCdzdWNjc2ltJzonXFxcXHUyMjdGJywnU3VjaFRoYXQnOidcXFxcdTIyMEInLCdzdW0nOidcXFxcdTIyMTEnLCdTdW0nOidcXFxcdTIyMTEnLCdzdW5nJzonXFxcXHUyNjZBJywnc3VwJzonXFxcXHUyMjgzJywnU3VwJzonXFxcXHUyMkQxJywnc3VwMSc6J1xcXFx4QjknLCdzdXAyJzonXFxcXHhCMicsJ3N1cDMnOidcXFxceEIzJywnc3VwZG90JzonXFxcXHUyQUJFJywnc3VwZHN1Yic6J1xcXFx1MkFEOCcsJ3N1cGUnOidcXFxcdTIyODcnLCdzdXBFJzonXFxcXHUyQUM2Jywnc3VwZWRvdCc6J1xcXFx1MkFDNCcsJ1N1cGVyc2V0JzonXFxcXHUyMjgzJywnU3VwZXJzZXRFcXVhbCc6J1xcXFx1MjI4NycsJ3N1cGhzb2wnOidcXFxcdTI3QzknLCdzdXBoc3ViJzonXFxcXHUyQUQ3Jywnc3VwbGFycic6J1xcXFx1Mjk3QicsJ3N1cG11bHQnOidcXFxcdTJBQzInLCdzdXBuZSc6J1xcXFx1MjI4QicsJ3N1cG5FJzonXFxcXHUyQUNDJywnc3VwcGx1cyc6J1xcXFx1MkFDMCcsJ3N1cHNldCc6J1xcXFx1MjI4MycsJ1N1cHNldCc6J1xcXFx1MjJEMScsJ3N1cHNldGVxJzonXFxcXHUyMjg3Jywnc3Vwc2V0ZXFxJzonXFxcXHUyQUM2Jywnc3Vwc2V0bmVxJzonXFxcXHUyMjhCJywnc3Vwc2V0bmVxcSc6J1xcXFx1MkFDQycsJ3N1cHNpbSc6J1xcXFx1MkFDOCcsJ3N1cHN1Yic6J1xcXFx1MkFENCcsJ3N1cHN1cCc6J1xcXFx1MkFENicsJ3N3YXJoayc6J1xcXFx1MjkyNicsJ3N3YXJyJzonXFxcXHUyMTk5Jywnc3dBcnInOidcXFxcdTIxRDknLCdzd2Fycm93JzonXFxcXHUyMTk5Jywnc3dud2FyJzonXFxcXHUyOTJBJywnc3psaWcnOidcXFxceERGJywnVGFiJzonXFxcXHQnLCd0YXJnZXQnOidcXFxcdTIzMTYnLCd0YXUnOidcXFxcdTAzQzQnLCdUYXUnOidcXFxcdTAzQTQnLCd0YnJrJzonXFxcXHUyM0I0JywndGNhcm9uJzonXFxcXHUwMTY1JywnVGNhcm9uJzonXFxcXHUwMTY0JywndGNlZGlsJzonXFxcXHUwMTYzJywnVGNlZGlsJzonXFxcXHUwMTYyJywndGN5JzonXFxcXHUwNDQyJywnVGN5JzonXFxcXHUwNDIyJywndGRvdCc6J1xcXFx1MjBEQicsJ3RlbHJlYyc6J1xcXFx1MjMxNScsJ3Rmcic6J1xcXFx1RDgzNVxcXFx1REQzMScsJ1Rmcic6J1xcXFx1RDgzNVxcXFx1REQxNycsJ3RoZXJlNCc6J1xcXFx1MjIzNCcsJ3RoZXJlZm9yZSc6J1xcXFx1MjIzNCcsJ1RoZXJlZm9yZSc6J1xcXFx1MjIzNCcsJ3RoZXRhJzonXFxcXHUwM0I4JywnVGhldGEnOidcXFxcdTAzOTgnLCd0aGV0YXN5bSc6J1xcXFx1MDNEMScsJ3RoZXRhdic6J1xcXFx1MDNEMScsJ3RoaWNrYXBwcm94JzonXFxcXHUyMjQ4JywndGhpY2tzaW0nOidcXFxcdTIyM0MnLCdUaGlja1NwYWNlJzonXFxcXHUyMDVGXFxcXHUyMDBBJywndGhpbnNwJzonXFxcXHUyMDA5JywnVGhpblNwYWNlJzonXFxcXHUyMDA5JywndGhrYXAnOidcXFxcdTIyNDgnLCd0aGtzaW0nOidcXFxcdTIyM0MnLCd0aG9ybic6J1xcXFx4RkUnLCdUSE9STic6J1xcXFx4REUnLCd0aWxkZSc6J1xcXFx1MDJEQycsJ1RpbGRlJzonXFxcXHUyMjNDJywnVGlsZGVFcXVhbCc6J1xcXFx1MjI0MycsJ1RpbGRlRnVsbEVxdWFsJzonXFxcXHUyMjQ1JywnVGlsZGVUaWxkZSc6J1xcXFx1MjI0OCcsJ3RpbWVzJzonXFxcXHhENycsJ3RpbWVzYic6J1xcXFx1MjJBMCcsJ3RpbWVzYmFyJzonXFxcXHUyQTMxJywndGltZXNkJzonXFxcXHUyQTMwJywndGludCc6J1xcXFx1MjIyRCcsJ3RvZWEnOidcXFxcdTI5MjgnLCd0b3AnOidcXFxcdTIyQTQnLCd0b3Bib3QnOidcXFxcdTIzMzYnLCd0b3BjaXInOidcXFxcdTJBRjEnLCd0b3BmJzonXFxcXHVEODM1XFxcXHVERDY1JywnVG9wZic6J1xcXFx1RDgzNVxcXFx1REQ0QicsJ3RvcGZvcmsnOidcXFxcdTJBREEnLCd0b3NhJzonXFxcXHUyOTI5JywndHByaW1lJzonXFxcXHUyMDM0JywndHJhZGUnOidcXFxcdTIxMjInLCdUUkFERSc6J1xcXFx1MjEyMicsJ3RyaWFuZ2xlJzonXFxcXHUyNUI1JywndHJpYW5nbGVkb3duJzonXFxcXHUyNUJGJywndHJpYW5nbGVsZWZ0JzonXFxcXHUyNUMzJywndHJpYW5nbGVsZWZ0ZXEnOidcXFxcdTIyQjQnLCd0cmlhbmdsZXEnOidcXFxcdTIyNUMnLCd0cmlhbmdsZXJpZ2h0JzonXFxcXHUyNUI5JywndHJpYW5nbGVyaWdodGVxJzonXFxcXHUyMkI1JywndHJpZG90JzonXFxcXHUyNUVDJywndHJpZSc6J1xcXFx1MjI1QycsJ3RyaW1pbnVzJzonXFxcXHUyQTNBJywnVHJpcGxlRG90JzonXFxcXHUyMERCJywndHJpcGx1cyc6J1xcXFx1MkEzOScsJ3RyaXNiJzonXFxcXHUyOUNEJywndHJpdGltZSc6J1xcXFx1MkEzQicsJ3RycGV6aXVtJzonXFxcXHUyM0UyJywndHNjcic6J1xcXFx1RDgzNVxcXFx1RENDOScsJ1RzY3InOidcXFxcdUQ4MzVcXFxcdURDQUYnLCd0c2N5JzonXFxcXHUwNDQ2JywnVFNjeSc6J1xcXFx1MDQyNicsJ3RzaGN5JzonXFxcXHUwNDVCJywnVFNIY3knOidcXFxcdTA0MEInLCd0c3Ryb2snOidcXFxcdTAxNjcnLCdUc3Ryb2snOidcXFxcdTAxNjYnLCd0d2l4dCc6J1xcXFx1MjI2QycsJ3R3b2hlYWRsZWZ0YXJyb3cnOidcXFxcdTIxOUUnLCd0d29oZWFkcmlnaHRhcnJvdyc6J1xcXFx1MjFBMCcsJ3VhY3V0ZSc6J1xcXFx4RkEnLCdVYWN1dGUnOidcXFxceERBJywndWFycic6J1xcXFx1MjE5MScsJ3VBcnInOidcXFxcdTIxRDEnLCdVYXJyJzonXFxcXHUyMTlGJywnVWFycm9jaXInOidcXFxcdTI5NDknLCd1YnJjeSc6J1xcXFx1MDQ1RScsJ1VicmN5JzonXFxcXHUwNDBFJywndWJyZXZlJzonXFxcXHUwMTZEJywnVWJyZXZlJzonXFxcXHUwMTZDJywndWNpcmMnOidcXFxceEZCJywnVWNpcmMnOidcXFxceERCJywndWN5JzonXFxcXHUwNDQzJywnVWN5JzonXFxcXHUwNDIzJywndWRhcnInOidcXFxcdTIxQzUnLCd1ZGJsYWMnOidcXFxcdTAxNzEnLCdVZGJsYWMnOidcXFxcdTAxNzAnLCd1ZGhhcic6J1xcXFx1Mjk2RScsJ3VmaXNodCc6J1xcXFx1Mjk3RScsJ3Vmcic6J1xcXFx1RDgzNVxcXFx1REQzMicsJ1Vmcic6J1xcXFx1RDgzNVxcXFx1REQxOCcsJ3VncmF2ZSc6J1xcXFx4RjknLCdVZ3JhdmUnOidcXFxceEQ5JywndUhhcic6J1xcXFx1Mjk2MycsJ3VoYXJsJzonXFxcXHUyMUJGJywndWhhcnInOidcXFxcdTIxQkUnLCd1aGJsayc6J1xcXFx1MjU4MCcsJ3VsY29ybic6J1xcXFx1MjMxQycsJ3VsY29ybmVyJzonXFxcXHUyMzFDJywndWxjcm9wJzonXFxcXHUyMzBGJywndWx0cmknOidcXFxcdTI1RjgnLCd1bWFjcic6J1xcXFx1MDE2QicsJ1VtYWNyJzonXFxcXHUwMTZBJywndW1sJzonXFxcXHhBOCcsJ1VuZGVyQmFyJzonXycsJ1VuZGVyQnJhY2UnOidcXFxcdTIzREYnLCdVbmRlckJyYWNrZXQnOidcXFxcdTIzQjUnLCdVbmRlclBhcmVudGhlc2lzJzonXFxcXHUyM0REJywnVW5pb24nOidcXFxcdTIyQzMnLCdVbmlvblBsdXMnOidcXFxcdTIyOEUnLCd1b2dvbic6J1xcXFx1MDE3MycsJ1VvZ29uJzonXFxcXHUwMTcyJywndW9wZic6J1xcXFx1RDgzNVxcXFx1REQ2NicsJ1VvcGYnOidcXFxcdUQ4MzVcXFxcdURENEMnLCd1cGFycm93JzonXFxcXHUyMTkxJywnVXBhcnJvdyc6J1xcXFx1MjFEMScsJ1VwQXJyb3cnOidcXFxcdTIxOTEnLCdVcEFycm93QmFyJzonXFxcXHUyOTEyJywnVXBBcnJvd0Rvd25BcnJvdyc6J1xcXFx1MjFDNScsJ3VwZG93bmFycm93JzonXFxcXHUyMTk1JywnVXBkb3duYXJyb3cnOidcXFxcdTIxRDUnLCdVcERvd25BcnJvdyc6J1xcXFx1MjE5NScsJ1VwRXF1aWxpYnJpdW0nOidcXFxcdTI5NkUnLCd1cGhhcnBvb25sZWZ0JzonXFxcXHUyMUJGJywndXBoYXJwb29ucmlnaHQnOidcXFxcdTIxQkUnLCd1cGx1cyc6J1xcXFx1MjI4RScsJ1VwcGVyTGVmdEFycm93JzonXFxcXHUyMTk2JywnVXBwZXJSaWdodEFycm93JzonXFxcXHUyMTk3JywndXBzaSc6J1xcXFx1MDNDNScsJ1Vwc2knOidcXFxcdTAzRDInLCd1cHNpaCc6J1xcXFx1MDNEMicsJ3Vwc2lsb24nOidcXFxcdTAzQzUnLCdVcHNpbG9uJzonXFxcXHUwM0E1JywnVXBUZWUnOidcXFxcdTIyQTUnLCdVcFRlZUFycm93JzonXFxcXHUyMUE1JywndXB1cGFycm93cyc6J1xcXFx1MjFDOCcsJ3VyY29ybic6J1xcXFx1MjMxRCcsJ3VyY29ybmVyJzonXFxcXHUyMzFEJywndXJjcm9wJzonXFxcXHUyMzBFJywndXJpbmcnOidcXFxcdTAxNkYnLCdVcmluZyc6J1xcXFx1MDE2RScsJ3VydHJpJzonXFxcXHUyNUY5JywndXNjcic6J1xcXFx1RDgzNVxcXFx1RENDQScsJ1VzY3InOidcXFxcdUQ4MzVcXFxcdURDQjAnLCd1dGRvdCc6J1xcXFx1MjJGMCcsJ3V0aWxkZSc6J1xcXFx1MDE2OScsJ1V0aWxkZSc6J1xcXFx1MDE2OCcsJ3V0cmknOidcXFxcdTI1QjUnLCd1dHJpZic6J1xcXFx1MjVCNCcsJ3V1YXJyJzonXFxcXHUyMUM4JywndXVtbCc6J1xcXFx4RkMnLCdVdW1sJzonXFxcXHhEQycsJ3V3YW5nbGUnOidcXFxcdTI5QTcnLCd2YW5ncnQnOidcXFxcdTI5OUMnLCd2YXJlcHNpbG9uJzonXFxcXHUwM0Y1JywndmFya2FwcGEnOidcXFxcdTAzRjAnLCd2YXJub3RoaW5nJzonXFxcXHUyMjA1JywndmFycGhpJzonXFxcXHUwM0Q1JywndmFycGknOidcXFxcdTAzRDYnLCd2YXJwcm9wdG8nOidcXFxcdTIyMUQnLCd2YXJyJzonXFxcXHUyMTk1JywndkFycic6J1xcXFx1MjFENScsJ3ZhcnJobyc6J1xcXFx1MDNGMScsJ3ZhcnNpZ21hJzonXFxcXHUwM0MyJywndmFyc3Vic2V0bmVxJzonXFxcXHUyMjhBXFxcXHVGRTAwJywndmFyc3Vic2V0bmVxcSc6J1xcXFx1MkFDQlxcXFx1RkUwMCcsJ3ZhcnN1cHNldG5lcSc6J1xcXFx1MjI4QlxcXFx1RkUwMCcsJ3ZhcnN1cHNldG5lcXEnOidcXFxcdTJBQ0NcXFxcdUZFMDAnLCd2YXJ0aGV0YSc6J1xcXFx1MDNEMScsJ3ZhcnRyaWFuZ2xlbGVmdCc6J1xcXFx1MjJCMicsJ3ZhcnRyaWFuZ2xlcmlnaHQnOidcXFxcdTIyQjMnLCd2QmFyJzonXFxcXHUyQUU4JywnVmJhcic6J1xcXFx1MkFFQicsJ3ZCYXJ2JzonXFxcXHUyQUU5JywndmN5JzonXFxcXHUwNDMyJywnVmN5JzonXFxcXHUwNDEyJywndmRhc2gnOidcXFxcdTIyQTInLCd2RGFzaCc6J1xcXFx1MjJBOCcsJ1ZkYXNoJzonXFxcXHUyMkE5JywnVkRhc2gnOidcXFxcdTIyQUInLCdWZGFzaGwnOidcXFxcdTJBRTYnLCd2ZWUnOidcXFxcdTIyMjgnLCdWZWUnOidcXFxcdTIyQzEnLCd2ZWViYXInOidcXFxcdTIyQkInLCd2ZWVlcSc6J1xcXFx1MjI1QScsJ3ZlbGxpcCc6J1xcXFx1MjJFRScsJ3ZlcmJhcic6J3wnLCdWZXJiYXInOidcXFxcdTIwMTYnLCd2ZXJ0JzonfCcsJ1ZlcnQnOidcXFxcdTIwMTYnLCdWZXJ0aWNhbEJhcic6J1xcXFx1MjIyMycsJ1ZlcnRpY2FsTGluZSc6J3wnLCdWZXJ0aWNhbFNlcGFyYXRvcic6J1xcXFx1Mjc1OCcsJ1ZlcnRpY2FsVGlsZGUnOidcXFxcdTIyNDAnLCdWZXJ5VGhpblNwYWNlJzonXFxcXHUyMDBBJywndmZyJzonXFxcXHVEODM1XFxcXHVERDMzJywnVmZyJzonXFxcXHVEODM1XFxcXHVERDE5Jywndmx0cmknOidcXFxcdTIyQjInLCd2bnN1Yic6J1xcXFx1MjI4MlxcXFx1MjBEMicsJ3Zuc3VwJzonXFxcXHUyMjgzXFxcXHUyMEQyJywndm9wZic6J1xcXFx1RDgzNVxcXFx1REQ2NycsJ1ZvcGYnOidcXFxcdUQ4MzVcXFxcdURENEQnLCd2cHJvcCc6J1xcXFx1MjIxRCcsJ3ZydHJpJzonXFxcXHUyMkIzJywndnNjcic6J1xcXFx1RDgzNVxcXFx1RENDQicsJ1ZzY3InOidcXFxcdUQ4MzVcXFxcdURDQjEnLCd2c3VibmUnOidcXFxcdTIyOEFcXFxcdUZFMDAnLCd2c3VibkUnOidcXFxcdTJBQ0JcXFxcdUZFMDAnLCd2c3VwbmUnOidcXFxcdTIyOEJcXFxcdUZFMDAnLCd2c3VwbkUnOidcXFxcdTJBQ0NcXFxcdUZFMDAnLCdWdmRhc2gnOidcXFxcdTIyQUEnLCd2emlnemFnJzonXFxcXHUyOTlBJywnd2NpcmMnOidcXFxcdTAxNzUnLCdXY2lyYyc6J1xcXFx1MDE3NCcsJ3dlZGJhcic6J1xcXFx1MkE1RicsJ3dlZGdlJzonXFxcXHUyMjI3JywnV2VkZ2UnOidcXFxcdTIyQzAnLCd3ZWRnZXEnOidcXFxcdTIyNTknLCd3ZWllcnAnOidcXFxcdTIxMTgnLCd3ZnInOidcXFxcdUQ4MzVcXFxcdUREMzQnLCdXZnInOidcXFxcdUQ4MzVcXFxcdUREMUEnLCd3b3BmJzonXFxcXHVEODM1XFxcXHVERDY4JywnV29wZic6J1xcXFx1RDgzNVxcXFx1REQ0RScsJ3dwJzonXFxcXHUyMTE4Jywnd3InOidcXFxcdTIyNDAnLCd3cmVhdGgnOidcXFxcdTIyNDAnLCd3c2NyJzonXFxcXHVEODM1XFxcXHVEQ0NDJywnV3Njcic6J1xcXFx1RDgzNVxcXFx1RENCMicsJ3hjYXAnOidcXFxcdTIyQzInLCd4Y2lyYyc6J1xcXFx1MjVFRicsJ3hjdXAnOidcXFxcdTIyQzMnLCd4ZHRyaSc6J1xcXFx1MjVCRCcsJ3hmcic6J1xcXFx1RDgzNVxcXFx1REQzNScsJ1hmcic6J1xcXFx1RDgzNVxcXFx1REQxQicsJ3hoYXJyJzonXFxcXHUyN0Y3JywneGhBcnInOidcXFxcdTI3RkEnLCd4aSc6J1xcXFx1MDNCRScsJ1hpJzonXFxcXHUwMzlFJywneGxhcnInOidcXFxcdTI3RjUnLCd4bEFycic6J1xcXFx1MjdGOCcsJ3htYXAnOidcXFxcdTI3RkMnLCd4bmlzJzonXFxcXHUyMkZCJywneG9kb3QnOidcXFxcdTJBMDAnLCd4b3BmJzonXFxcXHVEODM1XFxcXHVERDY5JywnWG9wZic6J1xcXFx1RDgzNVxcXFx1REQ0RicsJ3hvcGx1cyc6J1xcXFx1MkEwMScsJ3hvdGltZSc6J1xcXFx1MkEwMicsJ3hyYXJyJzonXFxcXHUyN0Y2JywneHJBcnInOidcXFxcdTI3RjknLCd4c2NyJzonXFxcXHVEODM1XFxcXHVEQ0NEJywnWHNjcic6J1xcXFx1RDgzNVxcXFx1RENCMycsJ3hzcWN1cCc6J1xcXFx1MkEwNicsJ3h1cGx1cyc6J1xcXFx1MkEwNCcsJ3h1dHJpJzonXFxcXHUyNUIzJywneHZlZSc6J1xcXFx1MjJDMScsJ3h3ZWRnZSc6J1xcXFx1MjJDMCcsJ3lhY3V0ZSc6J1xcXFx4RkQnLCdZYWN1dGUnOidcXFxceEREJywneWFjeSc6J1xcXFx1MDQ0RicsJ1lBY3knOidcXFxcdTA0MkYnLCd5Y2lyYyc6J1xcXFx1MDE3NycsJ1ljaXJjJzonXFxcXHUwMTc2JywneWN5JzonXFxcXHUwNDRCJywnWWN5JzonXFxcXHUwNDJCJywneWVuJzonXFxcXHhBNScsJ3lmcic6J1xcXFx1RDgzNVxcXFx1REQzNicsJ1lmcic6J1xcXFx1RDgzNVxcXFx1REQxQycsJ3lpY3knOidcXFxcdTA0NTcnLCdZSWN5JzonXFxcXHUwNDA3JywneW9wZic6J1xcXFx1RDgzNVxcXFx1REQ2QScsJ1lvcGYnOidcXFxcdUQ4MzVcXFxcdURENTAnLCd5c2NyJzonXFxcXHVEODM1XFxcXHVEQ0NFJywnWXNjcic6J1xcXFx1RDgzNVxcXFx1RENCNCcsJ3l1Y3knOidcXFxcdTA0NEUnLCdZVWN5JzonXFxcXHUwNDJFJywneXVtbCc6J1xcXFx4RkYnLCdZdW1sJzonXFxcXHUwMTc4JywnemFjdXRlJzonXFxcXHUwMTdBJywnWmFjdXRlJzonXFxcXHUwMTc5JywnemNhcm9uJzonXFxcXHUwMTdFJywnWmNhcm9uJzonXFxcXHUwMTdEJywnemN5JzonXFxcXHUwNDM3JywnWmN5JzonXFxcXHUwNDE3JywnemRvdCc6J1xcXFx1MDE3QycsJ1pkb3QnOidcXFxcdTAxN0InLCd6ZWV0cmYnOidcXFxcdTIxMjgnLCdaZXJvV2lkdGhTcGFjZSc6J1xcXFx1MjAwQicsJ3pldGEnOidcXFxcdTAzQjYnLCdaZXRhJzonXFxcXHUwMzk2JywnemZyJzonXFxcXHVEODM1XFxcXHVERDM3JywnWmZyJzonXFxcXHUyMTI4JywnemhjeSc6J1xcXFx1MDQzNicsJ1pIY3knOidcXFxcdTA0MTYnLCd6aWdyYXJyJzonXFxcXHUyMUREJywnem9wZic6J1xcXFx1RDgzNVxcXFx1REQ2QicsJ1pvcGYnOidcXFxcdTIxMjQnLCd6c2NyJzonXFxcXHVEODM1XFxcXHVEQ0NGJywnWnNjcic6J1xcXFx1RDgzNVxcXFx1RENCNScsJ3p3aic6J1xcXFx1MjAwRCcsJ3p3bmonOidcXFxcdTIwMEMnfTtcXG5cXHR2YXIgZGVjb2RlTWFwTGVnYWN5ID0geydhYWN1dGUnOidcXFxceEUxJywnQWFjdXRlJzonXFxcXHhDMScsJ2FjaXJjJzonXFxcXHhFMicsJ0FjaXJjJzonXFxcXHhDMicsJ2FjdXRlJzonXFxcXHhCNCcsJ2FlbGlnJzonXFxcXHhFNicsJ0FFbGlnJzonXFxcXHhDNicsJ2FncmF2ZSc6J1xcXFx4RTAnLCdBZ3JhdmUnOidcXFxceEMwJywnYW1wJzonJicsJ0FNUCc6JyYnLCdhcmluZyc6J1xcXFx4RTUnLCdBcmluZyc6J1xcXFx4QzUnLCdhdGlsZGUnOidcXFxceEUzJywnQXRpbGRlJzonXFxcXHhDMycsJ2F1bWwnOidcXFxceEU0JywnQXVtbCc6J1xcXFx4QzQnLCdicnZiYXInOidcXFxceEE2JywnY2NlZGlsJzonXFxcXHhFNycsJ0NjZWRpbCc6J1xcXFx4QzcnLCdjZWRpbCc6J1xcXFx4QjgnLCdjZW50JzonXFxcXHhBMicsJ2NvcHknOidcXFxceEE5JywnQ09QWSc6J1xcXFx4QTknLCdjdXJyZW4nOidcXFxceEE0JywnZGVnJzonXFxcXHhCMCcsJ2RpdmlkZSc6J1xcXFx4RjcnLCdlYWN1dGUnOidcXFxceEU5JywnRWFjdXRlJzonXFxcXHhDOScsJ2VjaXJjJzonXFxcXHhFQScsJ0VjaXJjJzonXFxcXHhDQScsJ2VncmF2ZSc6J1xcXFx4RTgnLCdFZ3JhdmUnOidcXFxceEM4JywnZXRoJzonXFxcXHhGMCcsJ0VUSCc6J1xcXFx4RDAnLCdldW1sJzonXFxcXHhFQicsJ0V1bWwnOidcXFxceENCJywnZnJhYzEyJzonXFxcXHhCRCcsJ2ZyYWMxNCc6J1xcXFx4QkMnLCdmcmFjMzQnOidcXFxceEJFJywnZ3QnOic+JywnR1QnOic+JywnaWFjdXRlJzonXFxcXHhFRCcsJ0lhY3V0ZSc6J1xcXFx4Q0QnLCdpY2lyYyc6J1xcXFx4RUUnLCdJY2lyYyc6J1xcXFx4Q0UnLCdpZXhjbCc6J1xcXFx4QTEnLCdpZ3JhdmUnOidcXFxceEVDJywnSWdyYXZlJzonXFxcXHhDQycsJ2lxdWVzdCc6J1xcXFx4QkYnLCdpdW1sJzonXFxcXHhFRicsJ0l1bWwnOidcXFxceENGJywnbGFxdW8nOidcXFxceEFCJywnbHQnOic8JywnTFQnOic8JywnbWFjcic6J1xcXFx4QUYnLCdtaWNybyc6J1xcXFx4QjUnLCdtaWRkb3QnOidcXFxceEI3JywnbmJzcCc6J1xcXFx4QTAnLCdub3QnOidcXFxceEFDJywnbnRpbGRlJzonXFxcXHhGMScsJ050aWxkZSc6J1xcXFx4RDEnLCdvYWN1dGUnOidcXFxceEYzJywnT2FjdXRlJzonXFxcXHhEMycsJ29jaXJjJzonXFxcXHhGNCcsJ09jaXJjJzonXFxcXHhENCcsJ29ncmF2ZSc6J1xcXFx4RjInLCdPZ3JhdmUnOidcXFxceEQyJywnb3JkZic6J1xcXFx4QUEnLCdvcmRtJzonXFxcXHhCQScsJ29zbGFzaCc6J1xcXFx4RjgnLCdPc2xhc2gnOidcXFxceEQ4Jywnb3RpbGRlJzonXFxcXHhGNScsJ090aWxkZSc6J1xcXFx4RDUnLCdvdW1sJzonXFxcXHhGNicsJ091bWwnOidcXFxceEQ2JywncGFyYSc6J1xcXFx4QjYnLCdwbHVzbW4nOidcXFxceEIxJywncG91bmQnOidcXFxceEEzJywncXVvdCc6J1xcXCInLCdRVU9UJzonXFxcIicsJ3JhcXVvJzonXFxcXHhCQicsJ3JlZyc6J1xcXFx4QUUnLCdSRUcnOidcXFxceEFFJywnc2VjdCc6J1xcXFx4QTcnLCdzaHknOidcXFxceEFEJywnc3VwMSc6J1xcXFx4QjknLCdzdXAyJzonXFxcXHhCMicsJ3N1cDMnOidcXFxceEIzJywnc3psaWcnOidcXFxceERGJywndGhvcm4nOidcXFxceEZFJywnVEhPUk4nOidcXFxceERFJywndGltZXMnOidcXFxceEQ3JywndWFjdXRlJzonXFxcXHhGQScsJ1VhY3V0ZSc6J1xcXFx4REEnLCd1Y2lyYyc6J1xcXFx4RkInLCdVY2lyYyc6J1xcXFx4REInLCd1Z3JhdmUnOidcXFxceEY5JywnVWdyYXZlJzonXFxcXHhEOScsJ3VtbCc6J1xcXFx4QTgnLCd1dW1sJzonXFxcXHhGQycsJ1V1bWwnOidcXFxceERDJywneWFjdXRlJzonXFxcXHhGRCcsJ1lhY3V0ZSc6J1xcXFx4REQnLCd5ZW4nOidcXFxceEE1JywneXVtbCc6J1xcXFx4RkYnfTtcXG5cXHR2YXIgZGVjb2RlTWFwTnVtZXJpYyA9IHsnMCc6J1xcXFx1RkZGRCcsJzEyOCc6J1xcXFx1MjBBQycsJzEzMCc6J1xcXFx1MjAxQScsJzEzMSc6J1xcXFx1MDE5MicsJzEzMic6J1xcXFx1MjAxRScsJzEzMyc6J1xcXFx1MjAyNicsJzEzNCc6J1xcXFx1MjAyMCcsJzEzNSc6J1xcXFx1MjAyMScsJzEzNic6J1xcXFx1MDJDNicsJzEzNyc6J1xcXFx1MjAzMCcsJzEzOCc6J1xcXFx1MDE2MCcsJzEzOSc6J1xcXFx1MjAzOScsJzE0MCc6J1xcXFx1MDE1MicsJzE0Mic6J1xcXFx1MDE3RCcsJzE0NSc6J1xcXFx1MjAxOCcsJzE0Nic6J1xcXFx1MjAxOScsJzE0Nyc6J1xcXFx1MjAxQycsJzE0OCc6J1xcXFx1MjAxRCcsJzE0OSc6J1xcXFx1MjAyMicsJzE1MCc6J1xcXFx1MjAxMycsJzE1MSc6J1xcXFx1MjAxNCcsJzE1Mic6J1xcXFx1MDJEQycsJzE1Myc6J1xcXFx1MjEyMicsJzE1NCc6J1xcXFx1MDE2MScsJzE1NSc6J1xcXFx1MjAzQScsJzE1Nic6J1xcXFx1MDE1MycsJzE1OCc6J1xcXFx1MDE3RScsJzE1OSc6J1xcXFx1MDE3OCd9O1xcblxcdHZhciBpbnZhbGlkUmVmZXJlbmNlQ29kZVBvaW50cyA9IFsxLDIsMyw0LDUsNiw3LDgsMTEsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksMzAsMzEsMTI3LDEyOCwxMjksMTMwLDEzMSwxMzIsMTMzLDEzNCwxMzUsMTM2LDEzNywxMzgsMTM5LDE0MCwxNDEsMTQyLDE0MywxNDQsMTQ1LDE0NiwxNDcsMTQ4LDE0OSwxNTAsMTUxLDE1MiwxNTMsMTU0LDE1NSwxNTYsMTU3LDE1OCwxNTksNjQ5NzYsNjQ5NzcsNjQ5NzgsNjQ5NzksNjQ5ODAsNjQ5ODEsNjQ5ODIsNjQ5ODMsNjQ5ODQsNjQ5ODUsNjQ5ODYsNjQ5ODcsNjQ5ODgsNjQ5ODksNjQ5OTAsNjQ5OTEsNjQ5OTIsNjQ5OTMsNjQ5OTQsNjQ5OTUsNjQ5OTYsNjQ5OTcsNjQ5OTgsNjQ5OTksNjUwMDAsNjUwMDEsNjUwMDIsNjUwMDMsNjUwMDQsNjUwMDUsNjUwMDYsNjUwMDcsNjU1MzQsNjU1MzUsMTMxMDcwLDEzMTA3MSwxOTY2MDYsMTk2NjA3LDI2MjE0MiwyNjIxNDMsMzI3Njc4LDMyNzY3OSwzOTMyMTQsMzkzMjE1LDQ1ODc1MCw0NTg3NTEsNTI0Mjg2LDUyNDI4Nyw1ODk4MjIsNTg5ODIzLDY1NTM1OCw2NTUzNTksNzIwODk0LDcyMDg5NSw3ODY0MzAsNzg2NDMxLDg1MTk2Niw4NTE5NjcsOTE3NTAyLDkxNzUwMyw5ODMwMzgsOTgzMDM5LDEwNDg1NzQsMTA0ODU3NSwxMTE0MTEwLDExMTQxMTFdO1xcblxcblxcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcblxcdHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xcblxcblxcdHZhciBvYmplY3QgPSB7fTtcXG5cXHR2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3QuaGFzT3duUHJvcGVydHk7XFxuXFx0dmFyIGhhcyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHlOYW1lKSB7XFxuXFx0XFx0cmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eU5hbWUpO1xcblxcdH07XFxuXFxuXFx0dmFyIGNvbnRhaW5zID0gZnVuY3Rpb24oYXJyYXksIHZhbHVlKSB7XFxuXFx0XFx0dmFyIGluZGV4ID0gLTE7XFxuXFx0XFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcXG5cXHRcXHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcblxcdFxcdFxcdGlmIChhcnJheVtpbmRleF0gPT0gdmFsdWUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHR9O1xcblxcblxcdHZhciBtZXJnZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGRlZmF1bHRzKSB7XFxuXFx0XFx0aWYgKCFvcHRpb25zKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGRlZmF1bHRzO1xcblxcdFxcdH1cXG5cXHRcXHR2YXIgcmVzdWx0ID0ge307XFxuXFx0XFx0dmFyIGtleTtcXG5cXHRcXHRmb3IgKGtleSBpbiBkZWZhdWx0cykge1xcblxcdFxcdFxcdC8vIEEgYGhhc093blByb3BlcnR5YCBjaGVjayBpcyBub3QgbmVlZGVkIGhlcmUsIHNpbmNlIG9ubHkgcmVjb2duaXplZFxcblxcdFxcdFxcdC8vIG9wdGlvbiBuYW1lcyBhcmUgdXNlZCBhbnl3YXkuIEFueSBvdGhlcnMgYXJlIGlnbm9yZWQuXFxuXFx0XFx0XFx0cmVzdWx0W2tleV0gPSBoYXMob3B0aW9ucywga2V5KSA/IG9wdGlvbnNba2V5XSA6IGRlZmF1bHRzW2tleV07XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFx0fTtcXG5cXG5cXHQvLyBNb2RpZmllZCB2ZXJzaW9uIG9mIGB1Y3MyZW5jb2RlYDsgc2VlIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZS5cXG5cXHR2YXIgY29kZVBvaW50VG9TeW1ib2wgPSBmdW5jdGlvbihjb2RlUG9pbnQsIHN0cmljdCkge1xcblxcdFxcdHZhciBvdXRwdXQgPSAnJztcXG5cXHRcXHRpZiAoKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikgfHwgY29kZVBvaW50ID4gMHgxMEZGRkYpIHtcXG5cXHRcXHRcXHQvLyBTZWUgaXNzdWUgIzQ6XFxuXFx0XFx0XFx0Ly8g4oCcT3RoZXJ3aXNlLCBpZiB0aGUgbnVtYmVyIGlzIGluIHRoZSByYW5nZSAweEQ4MDAgdG8gMHhERkZGIG9yIGlzXFxuXFx0XFx0XFx0Ly8gZ3JlYXRlciB0aGFuIDB4MTBGRkZGLCB0aGVuIHRoaXMgaXMgYSBwYXJzZSBlcnJvci4gUmV0dXJuIGEgVStGRkZEXFxuXFx0XFx0XFx0Ly8gUkVQTEFDRU1FTlQgQ0hBUkFDVEVSLuKAnVxcblxcdFxcdFxcdGlmIChzdHJpY3QpIHtcXG5cXHRcXHRcXHRcXHRwYXJzZUVycm9yKCdjaGFyYWN0ZXIgcmVmZXJlbmNlIG91dHNpZGUgdGhlIHBlcm1pc3NpYmxlIFVuaWNvZGUgcmFuZ2UnKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuICdcXFxcdUZGRkQnO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoaGFzKGRlY29kZU1hcE51bWVyaWMsIGNvZGVQb2ludCkpIHtcXG5cXHRcXHRcXHRpZiAoc3RyaWN0KSB7XFxuXFx0XFx0XFx0XFx0cGFyc2VFcnJvcignZGlzYWxsb3dlZCBjaGFyYWN0ZXIgcmVmZXJlbmNlJyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBkZWNvZGVNYXBOdW1lcmljW2NvZGVQb2ludF07XFxuXFx0XFx0fVxcblxcdFxcdGlmIChzdHJpY3QgJiYgY29udGFpbnMoaW52YWxpZFJlZmVyZW5jZUNvZGVQb2ludHMsIGNvZGVQb2ludCkpIHtcXG5cXHRcXHRcXHRwYXJzZUVycm9yKCdkaXNhbGxvd2VkIGNoYXJhY3RlciByZWZlcmVuY2UnKTtcXG5cXHRcXHR9XFxuXFx0XFx0aWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xcblxcdFxcdFxcdGNvZGVQb2ludCAtPSAweDEwMDAwO1xcblxcdFxcdFxcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcXG5cXHRcXHRcXHRjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRjtcXG5cXHRcXHR9XFxuXFx0XFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xcblxcdFxcdHJldHVybiBvdXRwdXQ7XFxuXFx0fTtcXG5cXG5cXHR2YXIgaGV4RXNjYXBlID0gZnVuY3Rpb24oY29kZVBvaW50KSB7XFxuXFx0XFx0cmV0dXJuICcmI3gnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgJzsnO1xcblxcdH07XFxuXFxuXFx0dmFyIGRlY0VzY2FwZSA9IGZ1bmN0aW9uKGNvZGVQb2ludCkge1xcblxcdFxcdHJldHVybiAnJiMnICsgY29kZVBvaW50ICsgJzsnO1xcblxcdH07XFxuXFxuXFx0dmFyIHBhcnNlRXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKSB7XFxuXFx0XFx0dGhyb3cgRXJyb3IoJ1BhcnNlIGVycm9yOiAnICsgbWVzc2FnZSk7XFxuXFx0fTtcXG5cXG5cXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG5cXHR2YXIgZW5jb2RlID0gZnVuY3Rpb24oc3RyaW5nLCBvcHRpb25zKSB7XFxuXFx0XFx0b3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMsIGVuY29kZS5vcHRpb25zKTtcXG5cXHRcXHR2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XFxuXFx0XFx0aWYgKHN0cmljdCAmJiByZWdleEludmFsaWRSYXdDb2RlUG9pbnQudGVzdChzdHJpbmcpKSB7XFxuXFx0XFx0XFx0cGFyc2VFcnJvcignZm9yYmlkZGVuIGNvZGUgcG9pbnQnKTtcXG5cXHRcXHR9XFxuXFx0XFx0dmFyIGVuY29kZUV2ZXJ5dGhpbmcgPSBvcHRpb25zLmVuY29kZUV2ZXJ5dGhpbmc7XFxuXFx0XFx0dmFyIHVzZU5hbWVkUmVmZXJlbmNlcyA9IG9wdGlvbnMudXNlTmFtZWRSZWZlcmVuY2VzO1xcblxcdFxcdHZhciBhbGxvd1Vuc2FmZVN5bWJvbHMgPSBvcHRpb25zLmFsbG93VW5zYWZlU3ltYm9scztcXG5cXHRcXHR2YXIgZXNjYXBlQ29kZVBvaW50ID0gb3B0aW9ucy5kZWNpbWFsID8gZGVjRXNjYXBlIDogaGV4RXNjYXBlO1xcblxcblxcdFxcdHZhciBlc2NhcGVCbXBTeW1ib2wgPSBmdW5jdGlvbihzeW1ib2wpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZXNjYXBlQ29kZVBvaW50KHN5bWJvbC5jaGFyQ29kZUF0KDApKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdGlmIChlbmNvZGVFdmVyeXRoaW5nKSB7XFxuXFx0XFx0XFx0Ly8gRW5jb2RlIEFTQ0lJIHN5bWJvbHMuXFxuXFx0XFx0XFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhBc2NpaVdoaXRlbGlzdCwgZnVuY3Rpb24oc3ltYm9sKSB7XFxuXFx0XFx0XFx0XFx0Ly8gVXNlIG5hbWVkIHJlZmVyZW5jZXMgaWYgcmVxdWVzdGVkICYgcG9zc2libGUuXFxuXFx0XFx0XFx0XFx0aWYgKHVzZU5hbWVkUmVmZXJlbmNlcyAmJiBoYXMoZW5jb2RlTWFwLCBzeW1ib2wpKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICcmJyArIGVuY29kZU1hcFtzeW1ib2xdICsgJzsnO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gZXNjYXBlQm1wU3ltYm9sKHN5bWJvbCk7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0Ly8gU2hvcnRlbiBhIGZldyBlc2NhcGVzIHRoYXQgcmVwcmVzZW50IHR3byBzeW1ib2xzLCBvZiB3aGljaCBhdCBsZWFzdCBvbmVcXG5cXHRcXHRcXHQvLyBpcyB3aXRoaW4gdGhlIEFTQ0lJIHJhbmdlLlxcblxcdFxcdFxcdGlmICh1c2VOYW1lZFJlZmVyZW5jZXMpIHtcXG5cXHRcXHRcXHRcXHRzdHJpbmcgPSBzdHJpbmdcXG5cXHRcXHRcXHRcXHRcXHQucmVwbGFjZSgvJmd0O1xcXFx1MjBEMi9nLCAnJm52Z3Q7JylcXG5cXHRcXHRcXHRcXHRcXHQucmVwbGFjZSgvJmx0O1xcXFx1MjBEMi9nLCAnJm52bHQ7JylcXG5cXHRcXHRcXHRcXHRcXHQucmVwbGFjZSgvJiN4NjY7JiN4NkE7L2csICcmZmpsaWc7Jyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIEVuY29kZSBub24tQVNDSUkgc3ltYm9scy5cXG5cXHRcXHRcXHRpZiAodXNlTmFtZWRSZWZlcmVuY2VzKSB7XFxuXFx0XFx0XFx0XFx0Ly8gRW5jb2RlIG5vbi1BU0NJSSBzeW1ib2xzIHRoYXQgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBuYW1lZCByZWZlcmVuY2UuXFxuXFx0XFx0XFx0XFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhFbmNvZGVOb25Bc2NpaSwgZnVuY3Rpb24oc3RyaW5nKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gTm90ZTogdGhlcmUgaXMgbm8gbmVlZCB0byBjaGVjayBgaGFzKGVuY29kZU1hcCwgc3RyaW5nKWAgaGVyZS5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gJyYnICsgZW5jb2RlTWFwW3N0cmluZ10gKyAnOyc7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIE5vdGU6IGFueSByZW1haW5pbmcgbm9uLUFTQ0lJIHN5bWJvbHMgYXJlIGhhbmRsZWQgb3V0c2lkZSBvZiB0aGUgYGlmYC5cXG5cXHRcXHR9IGVsc2UgaWYgKHVzZU5hbWVkUmVmZXJlbmNlcykge1xcblxcdFxcdFxcdC8vIEFwcGx5IG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzLlxcblxcdFxcdFxcdC8vIEVuY29kZSBgPD5cXFwiJyZgIHVzaW5nIG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzLlxcblxcdFxcdFxcdGlmICghYWxsb3dVbnNhZmVTeW1ib2xzKSB7XFxuXFx0XFx0XFx0XFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhFc2NhcGUsIGZ1bmN0aW9uKHN0cmluZykge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAnJicgKyBlbmNvZGVNYXBbc3RyaW5nXSArICc7JzsgLy8gbm8gbmVlZCB0byBjaGVjayBgaGFzKClgIGhlcmVcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gU2hvcnRlbiBlc2NhcGVzIHRoYXQgcmVwcmVzZW50IHR3byBzeW1ib2xzLCBvZiB3aGljaCBhdCBsZWFzdCBvbmUgaXNcXG5cXHRcXHRcXHQvLyBgPD5cXFwiJyZgLlxcblxcdFxcdFxcdHN0cmluZyA9IHN0cmluZ1xcblxcdFxcdFxcdFxcdC5yZXBsYWNlKC8mZ3Q7XFxcXHUyMEQyL2csICcmbnZndDsnKVxcblxcdFxcdFxcdFxcdC5yZXBsYWNlKC8mbHQ7XFxcXHUyMEQyL2csICcmbnZsdDsnKTtcXG5cXHRcXHRcXHQvLyBFbmNvZGUgbm9uLUFTQ0lJIHN5bWJvbHMgdGhhdCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIG5hbWVkIHJlZmVyZW5jZS5cXG5cXHRcXHRcXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleEVuY29kZU5vbkFzY2lpLCBmdW5jdGlvbihzdHJpbmcpIHtcXG5cXHRcXHRcXHRcXHQvLyBOb3RlOiB0aGVyZSBpcyBubyBuZWVkIHRvIGNoZWNrIGBoYXMoZW5jb2RlTWFwLCBzdHJpbmcpYCBoZXJlLlxcblxcdFxcdFxcdFxcdHJldHVybiAnJicgKyBlbmNvZGVNYXBbc3RyaW5nXSArICc7JztcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9IGVsc2UgaWYgKCFhbGxvd1Vuc2FmZVN5bWJvbHMpIHtcXG5cXHRcXHRcXHQvLyBFbmNvZGUgYDw+XFxcIicmYCB1c2luZyBoZXhhZGVjaW1hbCBlc2NhcGVzLCBub3cgdGhhdCB0aGV54oCZcmUgbm90IGhhbmRsZWRcXG5cXHRcXHRcXHQvLyB1c2luZyBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcy5cXG5cXHRcXHRcXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleEVzY2FwZSwgZXNjYXBlQm1wU3ltYm9sKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHN0cmluZ1xcblxcdFxcdFxcdC8vIEVuY29kZSBhc3RyYWwgc3ltYm9scy5cXG5cXHRcXHRcXHQucmVwbGFjZShyZWdleEFzdHJhbFN5bWJvbHMsIGZ1bmN0aW9uKCQwKSB7XFxuXFx0XFx0XFx0XFx0Ly8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXFxuXFx0XFx0XFx0XFx0dmFyIGhpZ2ggPSAkMC5jaGFyQ29kZUF0KDApO1xcblxcdFxcdFxcdFxcdHZhciBsb3cgPSAkMC5jaGFyQ29kZUF0KDEpO1xcblxcdFxcdFxcdFxcdHZhciBjb2RlUG9pbnQgPSAoaGlnaCAtIDB4RDgwMCkgKiAweDQwMCArIGxvdyAtIDB4REMwMCArIDB4MTAwMDA7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGVzY2FwZUNvZGVQb2ludChjb2RlUG9pbnQpO1xcblxcdFxcdFxcdH0pXFxuXFx0XFx0XFx0Ly8gRW5jb2RlIGFueSByZW1haW5pbmcgQk1QIHN5bWJvbHMgdGhhdCBhcmUgbm90IHByaW50YWJsZSBBU0NJSSBzeW1ib2xzXFxuXFx0XFx0XFx0Ly8gdXNpbmcgYSBoZXhhZGVjaW1hbCBlc2NhcGUuXFxuXFx0XFx0XFx0LnJlcGxhY2UocmVnZXhCbXBXaGl0ZWxpc3QsIGVzY2FwZUJtcFN5bWJvbCk7XFxuXFx0fTtcXG5cXHQvLyBFeHBvc2UgZGVmYXVsdCBvcHRpb25zIChzbyB0aGV5IGNhbiBiZSBvdmVycmlkZGVuIGdsb2JhbGx5KS5cXG5cXHRlbmNvZGUub3B0aW9ucyA9IHtcXG5cXHRcXHQnYWxsb3dVbnNhZmVTeW1ib2xzJzogZmFsc2UsXFxuXFx0XFx0J2VuY29kZUV2ZXJ5dGhpbmcnOiBmYWxzZSxcXG5cXHRcXHQnc3RyaWN0JzogZmFsc2UsXFxuXFx0XFx0J3VzZU5hbWVkUmVmZXJlbmNlcyc6IGZhbHNlLFxcblxcdFxcdCdkZWNpbWFsJyA6IGZhbHNlXFxuXFx0fTtcXG5cXG5cXHR2YXIgZGVjb2RlID0gZnVuY3Rpb24oaHRtbCwgb3B0aW9ucykge1xcblxcdFxcdG9wdGlvbnMgPSBtZXJnZShvcHRpb25zLCBkZWNvZGUub3B0aW9ucyk7XFxuXFx0XFx0dmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xcblxcdFxcdGlmIChzdHJpY3QgJiYgcmVnZXhJbnZhbGlkRW50aXR5LnRlc3QoaHRtbCkpIHtcXG5cXHRcXHRcXHRwYXJzZUVycm9yKCdtYWxmb3JtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZScpO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gaHRtbC5yZXBsYWNlKHJlZ2V4RGVjb2RlLCBmdW5jdGlvbigkMCwgJDEsICQyLCAkMywgJDQsICQ1LCAkNiwgJDcpIHtcXG5cXHRcXHRcXHR2YXIgY29kZVBvaW50O1xcblxcdFxcdFxcdHZhciBzZW1pY29sb247XFxuXFx0XFx0XFx0dmFyIGRlY0RpZ2l0cztcXG5cXHRcXHRcXHR2YXIgaGV4RGlnaXRzO1xcblxcdFxcdFxcdHZhciByZWZlcmVuY2U7XFxuXFx0XFx0XFx0dmFyIG5leHQ7XFxuXFx0XFx0XFx0aWYgKCQxKSB7XFxuXFx0XFx0XFx0XFx0Ly8gRGVjb2RlIGRlY2ltYWwgZXNjYXBlcywgZS5nLiBgJiMxMTk1NTg7YC5cXG5cXHRcXHRcXHRcXHRkZWNEaWdpdHMgPSAkMTtcXG5cXHRcXHRcXHRcXHRzZW1pY29sb24gPSAkMjtcXG5cXHRcXHRcXHRcXHRpZiAoc3RyaWN0ICYmICFzZW1pY29sb24pIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXJzZUVycm9yKCdjaGFyYWN0ZXIgcmVmZXJlbmNlIHdhcyBub3QgdGVybWluYXRlZCBieSBhIHNlbWljb2xvbicpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRjb2RlUG9pbnQgPSBwYXJzZUludChkZWNEaWdpdHMsIDEwKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gY29kZVBvaW50VG9TeW1ib2woY29kZVBvaW50LCBzdHJpY3QpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoJDMpIHtcXG5cXHRcXHRcXHRcXHQvLyBEZWNvZGUgaGV4YWRlY2ltYWwgZXNjYXBlcywgZS5nLiBgJiN4MUQzMDY7YC5cXG5cXHRcXHRcXHRcXHRoZXhEaWdpdHMgPSAkMztcXG5cXHRcXHRcXHRcXHRzZW1pY29sb24gPSAkNDtcXG5cXHRcXHRcXHRcXHRpZiAoc3RyaWN0ICYmICFzZW1pY29sb24pIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXJzZUVycm9yKCdjaGFyYWN0ZXIgcmVmZXJlbmNlIHdhcyBub3QgdGVybWluYXRlZCBieSBhIHNlbWljb2xvbicpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRjb2RlUG9pbnQgPSBwYXJzZUludChoZXhEaWdpdHMsIDE2KTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gY29kZVBvaW50VG9TeW1ib2woY29kZVBvaW50LCBzdHJpY3QpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoJDUpIHtcXG5cXHRcXHRcXHRcXHQvLyBEZWNvZGUgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZXMgd2l0aCB0cmFpbGluZyBgO2AsIGUuZy4gYCZjb3B5O2AuXFxuXFx0XFx0XFx0XFx0cmVmZXJlbmNlID0gJDU7XFxuXFx0XFx0XFx0XFx0aWYgKGhhcyhkZWNvZGVNYXAsIHJlZmVyZW5jZSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZGVjb2RlTWFwW3JlZmVyZW5jZV07XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBBbWJpZ3VvdXMgYW1wZXJzYW5kLiBodHRwczovL210aHMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHNcXG5cXHRcXHRcXHRcXHRcXHRpZiAoc3RyaWN0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cGFyc2VFcnJvcihcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQnbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZSB3YXMgbm90IHRlcm1pbmF0ZWQgYnkgYSBzZW1pY29sb24nXFxuXFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICQwO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gSWYgd2XigJlyZSBzdGlsbCBoZXJlLCBpdOKAmXMgYSBsZWdhY3kgcmVmZXJlbmNlIGZvciBzdXJlLiBObyBuZWVkIGZvciBhblxcblxcdFxcdFxcdC8vIGV4dHJhIGBpZmAgY2hlY2suXFxuXFx0XFx0XFx0Ly8gRGVjb2RlIG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzIHdpdGhvdXQgdHJhaWxpbmcgYDtgLCBlLmcuIGAmYW1wYFxcblxcdFxcdFxcdC8vIFRoaXMgaXMgb25seSBhIHBhcnNlIGVycm9yIGlmIGl0IGdldHMgY29udmVydGVkIHRvIGAmYCwgb3IgaWYgaXQgaXNcXG5cXHRcXHRcXHQvLyBmb2xsb3dlZCBieSBgPWAgaW4gYW4gYXR0cmlidXRlIGNvbnRleHQuXFxuXFx0XFx0XFx0cmVmZXJlbmNlID0gJDY7XFxuXFx0XFx0XFx0bmV4dCA9ICQ3O1xcblxcdFxcdFxcdGlmIChuZXh0ICYmIG9wdGlvbnMuaXNBdHRyaWJ1dGVWYWx1ZSkge1xcblxcdFxcdFxcdFxcdGlmIChzdHJpY3QgJiYgbmV4dCA9PSAnPScpIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXJzZUVycm9yKCdgJmAgZGlkIG5vdCBzdGFydCBhIGNoYXJhY3RlciByZWZlcmVuY2UnKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuICQwO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0aWYgKHN0cmljdCkge1xcblxcdFxcdFxcdFxcdFxcdHBhcnNlRXJyb3IoXFxuXFx0XFx0XFx0XFx0XFx0XFx0J25hbWVkIGNoYXJhY3RlciByZWZlcmVuY2Ugd2FzIG5vdCB0ZXJtaW5hdGVkIGJ5IGEgc2VtaWNvbG9uJ1xcblxcdFxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8vIE5vdGU6IHRoZXJlIGlzIG5vIG5lZWQgdG8gY2hlY2sgYGhhcyhkZWNvZGVNYXBMZWdhY3ksIHJlZmVyZW5jZSlgLlxcblxcdFxcdFxcdFxcdHJldHVybiBkZWNvZGVNYXBMZWdhY3lbcmVmZXJlbmNlXSArIChuZXh0IHx8ICcnKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFx0fTtcXG5cXHQvLyBFeHBvc2UgZGVmYXVsdCBvcHRpb25zIChzbyB0aGV5IGNhbiBiZSBvdmVycmlkZGVuIGdsb2JhbGx5KS5cXG5cXHRkZWNvZGUub3B0aW9ucyA9IHtcXG5cXHRcXHQnaXNBdHRyaWJ1dGVWYWx1ZSc6IGZhbHNlLFxcblxcdFxcdCdzdHJpY3QnOiBmYWxzZVxcblxcdH07XFxuXFxuXFx0dmFyIGVzY2FwZSA9IGZ1bmN0aW9uKHN0cmluZykge1xcblxcdFxcdHJldHVybiBzdHJpbmcucmVwbGFjZShyZWdleEVzY2FwZSwgZnVuY3Rpb24oJDApIHtcXG5cXHRcXHRcXHQvLyBOb3RlOiB0aGVyZSBpcyBubyBuZWVkIHRvIGNoZWNrIGBoYXMoZXNjYXBlTWFwLCAkMClgIGhlcmUuXFxuXFx0XFx0XFx0cmV0dXJuIGVzY2FwZU1hcFskMF07XFxuXFx0XFx0fSk7XFxuXFx0fTtcXG5cXG5cXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG5cXHR2YXIgaGUgPSB7XFxuXFx0XFx0J3ZlcnNpb24nOiAnMS4xLjEnLFxcblxcdFxcdCdlbmNvZGUnOiBlbmNvZGUsXFxuXFx0XFx0J2RlY29kZSc6IGRlY29kZSxcXG5cXHRcXHQnZXNjYXBlJzogZXNjYXBlLFxcblxcdFxcdCd1bmVzY2FwZSc6IGRlY29kZVxcblxcdH07XFxuXFxuXFx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXFxuXFx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxcblxcdGlmIChcXG5cXHRcXHRmYWxzZVxcblxcdCkge1xcblxcdFxcdGRlZmluZShmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZXR1cm4gaGU7XFxuXFx0XFx0fSk7XFxuXFx0fVxcdGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xcblxcdFxcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcXG5cXHRcXHRcXHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBoZTtcXG5cXHRcXHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxcblxcdFxcdFxcdGZvciAodmFyIGtleSBpbiBoZSkge1xcblxcdFxcdFxcdFxcdGhhcyhoZSwga2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IGhlW2tleV0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxcblxcdFxcdHJvb3QuaGUgPSBoZTtcXG5cXHR9XFxuXFxufSh0aGlzKSk7XFxuXFxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7fV0sNDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XFxuICB2YXIgZSwgbVxcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXFxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcXG4gIHZhciBuQml0cyA9IC03XFxuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXFxuXFxuICBpICs9IGRcXG5cXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXFxuICBzID4+PSAoLW5CaXRzKVxcbiAgbkJpdHMgKz0gZUxlblxcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cXG5cXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXFxuICBlID4+PSAoLW5CaXRzKVxcbiAgbkJpdHMgKz0gbUxlblxcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cXG5cXG4gIGlmIChlID09PSAwKSB7XFxuICAgIGUgPSAxIC0gZUJpYXNcXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcXG4gIH0gZWxzZSB7XFxuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcXG4gICAgZSA9IGUgLSBlQmlhc1xcbiAgfVxcbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcXG59XFxuXFxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xcbiAgdmFyIGUsIG0sIGNcXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXFxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXFxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXFxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXFxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXFxuXFxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxcblxcbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcXG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXFxuICAgIGUgPSBlTWF4XFxuICB9IGVsc2Uge1xcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xcbiAgICAgIGUtLVxcbiAgICAgIGMgKj0gMlxcbiAgICB9XFxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxcbiAgICB9XFxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xcbiAgICAgIGUrK1xcbiAgICAgIGMgLz0gMlxcbiAgICB9XFxuXFxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xcbiAgICAgIG0gPSAwXFxuICAgICAgZSA9IGVNYXhcXG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxcbiAgICAgIGUgPSBlICsgZUJpYXNcXG4gICAgfSBlbHNlIHtcXG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcXG4gICAgICBlID0gMFxcbiAgICB9XFxuICB9XFxuXFxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxcblxcbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxcbiAgZUxlbiArPSBtTGVuXFxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XFxuXFxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcXG59XFxuXFxufSx7fV0sNTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XFxuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXFxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XFxuICAgICAgY29uc3RydWN0b3I6IHtcXG4gICAgICAgIHZhbHVlOiBjdG9yLFxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9O1xcbn0gZWxzZSB7XFxuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcXG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cXG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXFxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxcbiAgfVxcbn1cXG5cXG59LHt9XSw1MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyohXFxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxcbiAqXFxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XFxuICogQGxpY2Vuc2UgIE1JVFxcbiAqL1xcblxcbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3NpbmdcXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XFxuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxcbn1cXG5cXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XFxuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxcbn1cXG5cXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxcbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XFxuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcXG59XFxuXFxufSx7fV0sNTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xcblxcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XFxuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XFxufTtcXG5cXG59LHt9XSw1MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xcbnZhciBfMDc3NyA9IHBhcnNlSW50KCcwNzc3JywgOCk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBta2RpclAubWtkaXJwID0gbWtkaXJQLm1rZGlyUCA9IG1rZGlyUDtcXG5cXG5mdW5jdGlvbiBta2RpclAgKHAsIG9wdHMsIGYsIG1hZGUpIHtcXG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICBmID0gb3B0cztcXG4gICAgICAgIG9wdHMgPSB7fTtcXG4gICAgfVxcbiAgICBlbHNlIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcXG4gICAgICAgIG9wdHMgPSB7IG1vZGU6IG9wdHMgfTtcXG4gICAgfVxcbiAgICBcXG4gICAgdmFyIG1vZGUgPSBvcHRzLm1vZGU7XFxuICAgIHZhciB4ZnMgPSBvcHRzLmZzIHx8IGZzO1xcbiAgICBcXG4gICAgaWYgKG1vZGUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgbW9kZSA9IF8wNzc3ICYgKH5wcm9jZXNzLnVtYXNrKCkpO1xcbiAgICB9XFxuICAgIGlmICghbWFkZSkgbWFkZSA9IG51bGw7XFxuICAgIFxcbiAgICB2YXIgY2IgPSBmIHx8IGZ1bmN0aW9uICgpIHt9O1xcbiAgICBwID0gcGF0aC5yZXNvbHZlKHApO1xcbiAgICBcXG4gICAgeGZzLm1rZGlyKHAsIG1vZGUsIGZ1bmN0aW9uIChlcikge1xcbiAgICAgICAgaWYgKCFlcikge1xcbiAgICAgICAgICAgIG1hZGUgPSBtYWRlIHx8IHA7XFxuICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIG1hZGUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc3dpdGNoIChlci5jb2RlKSB7XFxuICAgICAgICAgICAgY2FzZSAnRU5PRU5UJzpcXG4gICAgICAgICAgICAgICAgbWtkaXJQKHBhdGguZGlybmFtZShwKSwgb3B0cywgZnVuY3Rpb24gKGVyLCBtYWRlKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXIpIGNiKGVyLCBtYWRlKTtcXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgbWtkaXJQKHAsIG9wdHMsIGNiLCBtYWRlKTtcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGFueSBvdGhlciBlcnJvciwganVzdCBzZWUgaWYgdGhlcmUncyBhIGRpclxcbiAgICAgICAgICAgIC8vIHRoZXJlIGFscmVhZHkuICBJZiBzbywgdGhlbiBob29yYXkhICBJZiBub3QsIHRoZW4gc29tZXRoaW5nXFxuICAgICAgICAgICAgLy8gaXMgYm9ya2VkLlxcbiAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgIHhmcy5zdGF0KHAsIGZ1bmN0aW9uIChlcjIsIHN0YXQpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzdGF0IGZhaWxzLCB0aGVuIHRoYXQncyBzdXBlciB3ZWlyZC5cXG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCB0aGUgb3JpZ2luYWwgZXJyb3IgYmUgdGhlIGZhaWx1cmUgcmVhc29uLlxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyMiB8fCAhc3RhdC5pc0RpcmVjdG9yeSgpKSBjYihlciwgbWFkZSlcXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgY2IobnVsbCwgbWFkZSk7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgfSk7XFxufVxcblxcbm1rZGlyUC5zeW5jID0gZnVuY3Rpb24gc3luYyAocCwgb3B0cywgbWFkZSkge1xcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XFxuICAgICAgICBvcHRzID0geyBtb2RlOiBvcHRzIH07XFxuICAgIH1cXG4gICAgXFxuICAgIHZhciBtb2RlID0gb3B0cy5tb2RlO1xcbiAgICB2YXIgeGZzID0gb3B0cy5mcyB8fCBmcztcXG4gICAgXFxuICAgIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIG1vZGUgPSBfMDc3NyAmICh+cHJvY2Vzcy51bWFzaygpKTtcXG4gICAgfVxcbiAgICBpZiAoIW1hZGUpIG1hZGUgPSBudWxsO1xcblxcbiAgICBwID0gcGF0aC5yZXNvbHZlKHApO1xcblxcbiAgICB0cnkge1xcbiAgICAgICAgeGZzLm1rZGlyU3luYyhwLCBtb2RlKTtcXG4gICAgICAgIG1hZGUgPSBtYWRlIHx8IHA7XFxuICAgIH1cXG4gICAgY2F0Y2ggKGVycjApIHtcXG4gICAgICAgIHN3aXRjaCAoZXJyMC5jb2RlKSB7XFxuICAgICAgICAgICAgY2FzZSAnRU5PRU5UJyA6XFxuICAgICAgICAgICAgICAgIG1hZGUgPSBzeW5jKHBhdGguZGlybmFtZShwKSwgb3B0cywgbWFkZSk7XFxuICAgICAgICAgICAgICAgIHN5bmMocCwgb3B0cywgbWFkZSk7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGFueSBvdGhlciBlcnJvciwganVzdCBzZWUgaWYgdGhlcmUncyBhIGRpclxcbiAgICAgICAgICAgIC8vIHRoZXJlIGFscmVhZHkuICBJZiBzbywgdGhlbiBob29yYXkhICBJZiBub3QsIHRoZW4gc29tZXRoaW5nXFxuICAgICAgICAgICAgLy8gaXMgYm9ya2VkLlxcbiAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgIHZhciBzdGF0O1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgc3RhdCA9IHhmcy5zdGF0U3luYyhwKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyMSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyMDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXQuaXNEaXJlY3RvcnkoKSkgdGhyb3cgZXJyMDtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG1hZGU7XFxufTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiX3Byb2Nlc3NcXFwiOjU2LFxcXCJmc1xcXCI6NDAsXFxcInBhdGhcXFwiOjQwfV0sNTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qKlxcbiAqIEhlbHBlcnMuXFxuICovXFxuXFxudmFyIHMgPSAxMDAwO1xcbnZhciBtID0gcyAqIDYwO1xcbnZhciBoID0gbSAqIDYwO1xcbnZhciBkID0gaCAqIDI0O1xcbnZhciB5ID0gZCAqIDM2NS4yNTtcXG5cXG4vKipcXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxcbiAqXFxuICogT3B0aW9uczpcXG4gKlxcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxcbiAqXFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXFxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXFxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XFxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcXG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcXG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XFxuICB9XFxuICB0aHJvdyBuZXcgRXJyb3IoXFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcXG4gICk7XFxufTtcXG5cXG4vKipcXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXFxuICogQHJldHVybiB7TnVtYmVyfVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xcbiAgc3RyID0gU3RyaW5nKHN0cik7XFxuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xcbiAgICByZXR1cm47XFxuICB9XFxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXFxcZCspP1xcXFwuP1xcXFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxcbiAgICBzdHJcXG4gICk7XFxuICBpZiAoIW1hdGNoKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XFxuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xcbiAgc3dpdGNoICh0eXBlKSB7XFxuICAgIGNhc2UgJ3llYXJzJzpcXG4gICAgY2FzZSAneWVhcic6XFxuICAgIGNhc2UgJ3lycyc6XFxuICAgIGNhc2UgJ3lyJzpcXG4gICAgY2FzZSAneSc6XFxuICAgICAgcmV0dXJuIG4gKiB5O1xcbiAgICBjYXNlICdkYXlzJzpcXG4gICAgY2FzZSAnZGF5JzpcXG4gICAgY2FzZSAnZCc6XFxuICAgICAgcmV0dXJuIG4gKiBkO1xcbiAgICBjYXNlICdob3Vycyc6XFxuICAgIGNhc2UgJ2hvdXInOlxcbiAgICBjYXNlICdocnMnOlxcbiAgICBjYXNlICdocic6XFxuICAgIGNhc2UgJ2gnOlxcbiAgICAgIHJldHVybiBuICogaDtcXG4gICAgY2FzZSAnbWludXRlcyc6XFxuICAgIGNhc2UgJ21pbnV0ZSc6XFxuICAgIGNhc2UgJ21pbnMnOlxcbiAgICBjYXNlICdtaW4nOlxcbiAgICBjYXNlICdtJzpcXG4gICAgICByZXR1cm4gbiAqIG07XFxuICAgIGNhc2UgJ3NlY29uZHMnOlxcbiAgICBjYXNlICdzZWNvbmQnOlxcbiAgICBjYXNlICdzZWNzJzpcXG4gICAgY2FzZSAnc2VjJzpcXG4gICAgY2FzZSAncyc6XFxuICAgICAgcmV0dXJuIG4gKiBzO1xcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XFxuICAgIGNhc2UgJ21zZWNzJzpcXG4gICAgY2FzZSAnbXNlYyc6XFxuICAgIGNhc2UgJ21zJzpcXG4gICAgICByZXR1cm4gbjtcXG4gICAgZGVmYXVsdDpcXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXFxuICpcXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcXG4gKiBAcmV0dXJuIHtTdHJpbmd9XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcXG4gIGlmIChtcyA+PSBkKSB7XFxuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XFxuICB9XFxuICBpZiAobXMgPj0gaCkge1xcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xcbiAgfVxcbiAgaWYgKG1zID49IG0pIHtcXG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcXG4gIH1cXG4gIGlmIChtcyA+PSBzKSB7XFxuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XFxuICB9XFxuICByZXR1cm4gbXMgKyAnbXMnO1xcbn1cXG5cXG4vKipcXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cXG4gKlxcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xcbiAqIEByZXR1cm4ge1N0cmluZ31cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XFxuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcXG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XFxuICAgIG1zICsgJyBtcyc7XFxufVxcblxcbi8qKlxcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxcbiAqL1xcblxcbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xcbiAgaWYgKG1zIDwgbikge1xcbiAgICByZXR1cm47XFxuICB9XFxuICBpZiAobXMgPCBuICogMS41KSB7XFxuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xcbiAgfVxcbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcXG59XFxuXFxufSx7fV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbmlmICghcHJvY2Vzcy52ZXJzaW9uIHx8XFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcXG4gIG1vZHVsZS5leHBvcnRzID0gbmV4dFRpY2s7XFxufSBlbHNlIHtcXG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcy5uZXh0VGljaztcXG59XFxuXFxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFxcImNhbGxiYWNrXFxcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcXG4gIH1cXG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xcbiAgdmFyIGFyZ3MsIGk7XFxuICBzd2l0Y2ggKGxlbikge1xcbiAgY2FzZSAwOlxcbiAgY2FzZSAxOlxcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XFxuICBjYXNlIDI6XFxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcXG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xcbiAgICB9KTtcXG4gIGNhc2UgMzpcXG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XFxuICAgIH0pO1xcbiAgY2FzZSA0OlxcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcXG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xcbiAgICB9KTtcXG4gIGRlZmF1bHQ6XFxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XFxuICAgIGkgPSAwO1xcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XFxuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xcbiAgICB9XFxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcXG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcXG4gICAgfSk7XFxuICB9XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCJfcHJvY2Vzc1xcXCI6NTZ9XSw1NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXFxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xcblxcbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxcblxcbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XFxuXFxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XFxufVxcbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xcbn1cXG4oZnVuY3Rpb24gKCkge1xcbiAgICB0cnkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xcbiAgICAgICAgfVxcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XFxuICAgICAgICB9XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XFxuICAgIH1cXG59ICgpKVxcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XFxuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XFxuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XFxuICAgIH1cXG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XFxuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XFxuICAgIH0gY2F0Y2goZSl7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcXG4gICAgICAgIH0gY2F0Y2goZSl7XFxuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG5cXG59XFxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcXG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xcbiAgICB9XFxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XFxuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XFxuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcXG4gICAgfSBjYXRjaCAoZSl7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpe1xcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxcbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcblxcblxcbn1cXG52YXIgcXVldWUgPSBbXTtcXG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcXG52YXIgY3VycmVudFF1ZXVlO1xcbnZhciBxdWV1ZUluZGV4ID0gLTE7XFxuXFxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcXG4gICAgfVxcbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XFxuICAgICAgICBkcmFpblF1ZXVlKCk7XFxuICAgIH1cXG59XFxuXFxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcXG4gICAgaWYgKGRyYWluaW5nKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XFxuICAgIGRyYWluaW5nID0gdHJ1ZTtcXG5cXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcXG4gICAgd2hpbGUobGVuKSB7XFxuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcXG4gICAgICAgIHF1ZXVlID0gW107XFxuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XFxuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xcbiAgICB9XFxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XFxuICAgIGRyYWluaW5nID0gZmFsc2U7XFxuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcXG59XFxuXFxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcXG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcXG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XFxuICAgIH1cXG59O1xcblxcbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcXG4gICAgdGhpcy5mdW4gPSBmdW47XFxuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcXG59XFxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcXG59O1xcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XFxucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcXG5wcm9jZXNzLmVudiA9IHt9O1xcbnByb2Nlc3MuYXJndiA9IFtdO1xcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcXG5cXG5mdW5jdGlvbiBub29wKCkge31cXG5cXG5wcm9jZXNzLm9uID0gbm9vcDtcXG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcXG5wcm9jZXNzLm9uY2UgPSBub29wO1xcbnByb2Nlc3Mub2ZmID0gbm9vcDtcXG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcXG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XFxucHJvY2Vzcy5lbWl0ID0gbm9vcDtcXG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XFxucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcXG5cXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XFxuXFxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xcbn07XFxuXFxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcXG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xcbn07XFxucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcXG5cXG59LHt9XSw1NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xcblxcbn0se1xcXCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1xcXCI6NTh9XSw1ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xcbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cXG4vLyBXcml0YWJsZS5cXG5cXG4ndXNlIHN0cmljdCc7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG5cXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xcbiAgdmFyIGtleXMgPSBbXTtcXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcXG4gICAga2V5cy5wdXNoKGtleSk7XFxuICB9cmV0dXJuIGtleXM7XFxufTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XFxudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XFxudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XFxuXFxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcXG5cXG52YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcXG5mb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcXG4gIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xcbn1cXG5cXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xcblxcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcXG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XFxuXFxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xcblxcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcXG5cXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XFxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcXG5cXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xcbn1cXG5cXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXFxuZnVuY3Rpb24gb25lbmQoKSB7XFxuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xcblxcbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxcbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXFxuICBwcm9jZXNzTmV4dFRpY2sob25FbmROVCwgdGhpcyk7XFxufVxcblxcbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xcbiAgc2VsZi5lbmQoKTtcXG59XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xcbiAgfSxcXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxcbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcXG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XFxuICB9XFxufSk7XFxuXFxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XFxuICB0aGlzLnB1c2gobnVsbCk7XFxuICB0aGlzLmVuZCgpO1xcblxcbiAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcnIpO1xcbn07XFxuXFxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgZih4c1tpXSwgaSk7XFxuICB9XFxufVxcbn0se1xcXCIuL19zdHJlYW1fcmVhZGFibGVcXFwiOjYwLFxcXCIuL19zdHJlYW1fd3JpdGFibGVcXFwiOjYyLFxcXCJjb3JlLXV0aWwtaXNcXFwiOjQyLFxcXCJpbmhlcml0c1xcXCI6NTAsXFxcInByb2Nlc3MtbmV4dGljay1hcmdzXFxcIjo1NX1dLDU5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcbi8vIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXFxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXFxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG5cXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxcblxcbid1c2Ugc3RyaWN0JztcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xcblxcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XFxuXFxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcXG5cXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xcbn1cXG5cXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICBjYihudWxsLCBjaHVuayk7XFxufTtcXG59LHtcXFwiLi9fc3RyZWFtX3RyYW5zZm9ybVxcXCI6NjEsXFxcImNvcmUtdXRpbC1pc1xcXCI6NDIsXFxcImluaGVyaXRzXFxcIjo1MH1dLDYwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcbi8vIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXFxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXFxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG5cXG4ndXNlIHN0cmljdCc7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG5cXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgRHVwbGV4O1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xcblxcbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcXG59O1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vLyBUT0RPKGJtZXVyZXIpOiBDaGFuZ2UgdGhpcyBiYWNrIHRvIGNvbnN0IG9uY2UgaG9sZSBjaGVja3MgYXJlXFxuLy8gcHJvcGVybHkgb3B0aW1pemVkIGF3YXkgZWFybHkgaW4gSWduaXRpb24rVHVyYm9GYW4uXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XFxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XFxuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xcbn1cXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XFxufVxcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcXG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XFxudmFyIGRlYnVnID0gdm9pZCAwO1xcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XFxuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XFxufSBlbHNlIHtcXG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XFxufVxcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xcbnZhciBTdHJpbmdEZWNvZGVyO1xcblxcbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XFxuXFxudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcXG5cXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XFxuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxcbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXFxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxcbiAgICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcXG4gICAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxcbiAgICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXFxuICAgIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcXG5cXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XFxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcXG5cXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xcblxcbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXFxcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcXFwiXFxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xcblxcbiAgLy8gY2FzdCB0byBpbnRzLlxcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xcblxcbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXFxuICAvLyBhcnJheS5zaGlmdCgpXFxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XFxuICB0aGlzLmxlbmd0aCA9IDA7XFxuICB0aGlzLnBpcGVzID0gbnVsbDtcXG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XFxuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XFxuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcXG5cXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXFxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXFxcImxhdGVyXFxcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXFxuICB0aGlzLnN5bmMgPSB0cnVlO1xcblxcbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcXG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxcbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcXG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XFxuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XFxuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xcblxcbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xcblxcbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxcbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxcbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XFxuXFxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcXG5cXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcXG5cXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XFxuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcXG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XFxuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XFxuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcXG5cXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XFxuXFxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XFxuXFxuICAvLyBsZWdhY3lcXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xcblxcbiAgaWYgKG9wdGlvbnMpIHtcXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XFxuXFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xcbiAgfVxcblxcbiAgU3RyZWFtLmNhbGwodGhpcyk7XFxufVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XFxuICB9LFxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXFxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcXG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcXG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XFxuICB9XFxufSk7XFxuXFxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XFxuICB0aGlzLnB1c2gobnVsbCk7XFxuICBjYihlcnIpO1xcbn07XFxuXFxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXFxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxcblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG4gIHZhciBza2lwQ2h1bmtDaGVjaztcXG5cXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcXG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcXG4gICAgICAgIGVuY29kaW5nID0gJyc7XFxuICAgICAgfVxcbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xcbiAgfVxcblxcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xcbn07XFxuXFxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcXG59O1xcblxcbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XFxuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XFxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcXG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xcbiAgfSBlbHNlIHtcXG4gICAgdmFyIGVyO1xcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xcbiAgICBpZiAoZXIpIHtcXG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XFxuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XFxuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcXG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50JykpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcXG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcXG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcXG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xcbn1cXG5cXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XFxuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xcbiAgICBzdHJlYW0ucmVhZCgwKTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXFxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcXG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcXG5cXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XFxuICB9XFxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xcbn1cXG5cXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XFxuICB2YXIgZXI7XFxuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcXG4gIH1cXG4gIHJldHVybiBlcjtcXG59XFxuXFxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXFxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxcbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcXG59XFxuXFxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XFxufTtcXG5cXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XFxuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcXG4gIGlmIChuID49IE1BWF9IV00pIHtcXG4gICAgbiA9IE1BWF9IV007XFxuICB9IGVsc2Uge1xcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cXG4gICAgLy8gdGlueSBhbW91bnRzXFxuICAgIG4tLTtcXG4gICAgbiB8PSBuID4+PiAxO1xcbiAgICBuIHw9IG4gPj4+IDI7XFxuICAgIG4gfD0gbiA+Pj4gNDtcXG4gICAgbiB8PSBuID4+PiA4O1xcbiAgICBuIHw9IG4gPj4+IDE2O1xcbiAgICBuKys7XFxuICB9XFxuICByZXR1cm4gbjtcXG59XFxuXFxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxcbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcXG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcXG4gIGlmIChuICE9PSBuKSB7XFxuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XFxuICB9XFxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcXG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XFxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XFxuICAgIHJldHVybiAwO1xcbiAgfVxcbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcXG59XFxuXFxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XFxuICBkZWJ1ZygncmVhZCcsIG4pO1xcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuICB2YXIgbk9yaWcgPSBuO1xcblxcbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xcblxcbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXFxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XFxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xcbiAgICByZXR1cm4gbnVsbDtcXG4gIH1cXG5cXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcXG5cXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XFxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xcbiAgICByZXR1cm4gbnVsbDtcXG4gIH1cXG5cXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxcbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxcbiAgLy9cXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xcbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cXG4gIC8vXFxuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxcbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXFxuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXFxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcXG4gIC8vICdyZWFkYWJsZScgZXRjLlxcbiAgLy9cXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cXG5cXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XFxuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XFxuXFxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcXG4gICAgZG9SZWFkID0gdHJ1ZTtcXG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcXG4gIH1cXG5cXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XFxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXFxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xcbiAgICBkb1JlYWQgPSBmYWxzZTtcXG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcXG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcXG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XFxuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XFxuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcXG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxcbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XFxuICB9XFxuXFxuICB2YXIgcmV0O1xcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xcblxcbiAgaWYgKHJldCA9PT0gbnVsbCkge1xcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xcbiAgICBuID0gMDtcXG4gIH0gZWxzZSB7XFxuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xcbiAgfVxcblxcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcXG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xcblxcbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXFxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XFxuICB9XFxuXFxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xcblxcbiAgcmV0dXJuIHJldDtcXG59O1xcblxcbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XFxuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XFxuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcXG4gICAgfVxcbiAgfVxcbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xcblxcbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXFxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcXG59XFxuXFxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXFxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXFxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxcbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcXG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcXG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcXG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xcbiAgICBpZiAoc3RhdGUuc3luYykgcHJvY2Vzc05leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XFxuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XFxuICBmbG93KHN0cmVhbSk7XFxufVxcblxcbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXFxuLy8gaXQncyBpbiBwcm9ncmVzcy5cXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXFxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XFxuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XFxuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcXG4gICAgcHJvY2Vzc05leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcXG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcXG4gICAgc3RyZWFtLnJlYWQoMCk7XFxuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxcbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xcbiAgfVxcbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcXG59XFxuXFxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxcbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXFxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFxcXCJsZW5ndGhcXFwiIGlzIHNvbWV3aGF0XFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxcblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XFxuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcXG59O1xcblxcblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XFxuICB2YXIgc3JjID0gdGhpcztcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuXFxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcXG4gICAgY2FzZSAwOlxcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAxOlxcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcXG4gICAgICBicmVhaztcXG4gICAgZGVmYXVsdDpcXG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xcbiAgICAgIGJyZWFrO1xcbiAgfVxcbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcXG5cXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XFxuXFxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3NOZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xcblxcbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcXG4gICAgZGVidWcoJ29udW5waXBlJyk7XFxuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XFxuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcXG4gICAgICAgIGNsZWFudXAoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xcbiAgICBkZWJ1Zygnb25lbmQnKTtcXG4gICAgZGVzdC5lbmQoKTtcXG4gIH1cXG5cXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcXG4gIC8vIHRvbyBzbG93LlxcbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcXG5cXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XFxuICAgIGRlYnVnKCdjbGVhbnVwJyk7XFxuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XFxuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XFxuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XFxuXFxuICAgIGNsZWFuZWRVcCA9IHRydWU7XFxuXFxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXFxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XFxuICB9XFxuXFxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXFxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXFxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xcbiAgICBkZWJ1Zygnb25kYXRhJyk7XFxuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcXG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXFxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XFxuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcXG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xcbiAgICAgIH1cXG4gICAgICBzcmMucGF1c2UoKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXFxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXFxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XFxuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xcbiAgICB1bnBpcGUoKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcXG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcXG4gIH1cXG5cXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcXG5cXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXFxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XFxuICAgIHVucGlwZSgpO1xcbiAgfVxcbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XFxuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xcbiAgICB1bnBpcGUoKTtcXG4gIH1cXG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xcblxcbiAgZnVuY3Rpb24gdW5waXBlKCkge1xcbiAgICBkZWJ1ZygndW5waXBlJyk7XFxuICAgIHNyYy51bnBpcGUoZGVzdCk7XFxuICB9XFxuXFxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xcbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcXG5cXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcXG4gICAgc3JjLnJlc3VtZSgpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGRlc3Q7XFxufTtcXG5cXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcXG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XFxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XFxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcXG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcXG4gICAgICBmbG93KHNyYyk7XFxuICAgIH1cXG4gIH07XFxufVxcblxcblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xcblxcbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xcblxcbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcXG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXFxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcXG5cXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XFxuXFxuICAgIC8vIGdvdCBhIG1hdGNoLlxcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XFxuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XFxuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG5cXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXFxuXFxuICBpZiAoIWRlc3QpIHtcXG4gICAgLy8gcmVtb3ZlIGFsbC5cXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XFxuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XFxuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcXG4gICAgfXJldHVybiB0aGlzO1xcbiAgfVxcblxcbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XFxuXFxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XFxuXFxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXFxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XFxuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XFxuXFxuICBpZiAoZXYgPT09ICdkYXRhJykge1xcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XFxuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XFxuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcXG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XFxuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XFxuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XFxuICAgICAgICBwcm9jZXNzTmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XFxuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcXG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiByZXM7XFxufTtcXG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XFxuXFxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XFxuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XFxuICBzZWxmLnJlYWQoMCk7XFxufVxcblxcbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXFxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcXG4gICAgZGVidWcoJ3Jlc3VtZScpO1xcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcXG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcXG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XFxuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XFxuICAgIHByb2Nlc3NOZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XFxuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcXG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcXG4gICAgc3RyZWFtLnJlYWQoMCk7XFxuICB9XFxuXFxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcXG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xcbiAgZmxvdyhzdHJlYW0pO1xcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xcbn1cXG5cXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XFxuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XFxuICAgIGRlYnVnKCdwYXVzZScpO1xcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcXG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcXG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XFxufVxcblxcbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXFxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxcbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxcblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcXG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XFxuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcXG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBzZWxmLnB1c2goY2h1bmspO1xcbiAgICB9XFxuXFxuICAgIHNlbGYucHVzaChudWxsKTtcXG4gIH0pO1xcblxcbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XFxuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcXG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XFxuXFxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XFxuXFxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xcbiAgICBpZiAoIXJldCkge1xcbiAgICAgIHBhdXNlZCA9IHRydWU7XFxuICAgICAgc3RyZWFtLnBhdXNlKCk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxcbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXFxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcXG4gICAgICAgIH07XFxuICAgICAgfShpKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcXG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgc2VsZi5lbWl0LmJpbmQoc2VsZiwga1Byb3h5RXZlbnRzW25dKSk7XFxuICB9XFxuXFxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXFxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbiAobikge1xcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xcbiAgICBpZiAocGF1c2VkKSB7XFxuICAgICAgcGF1c2VkID0gZmFsc2U7XFxuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgcmV0dXJuIHNlbGY7XFxufTtcXG5cXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXFxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XFxuXFxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxcbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXFxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxcbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XFxuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcXG5cXG4gIHZhciByZXQ7XFxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcXG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcXG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XFxuICB9IGVsc2Uge1xcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcXG4gIH1cXG5cXG4gIHJldHVybiByZXQ7XFxufVxcblxcbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXFxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcXG4gIHZhciByZXQ7XFxuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcXG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcXG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XFxuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XFxuICB9IGVsc2Uge1xcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XFxuICB9XFxuICByZXR1cm4gcmV0O1xcbn1cXG5cXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXFxuLy8gY2h1bmtzLlxcbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXFxuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XFxuICB2YXIgcCA9IGxpc3QuaGVhZDtcXG4gIHZhciBjID0gMTtcXG4gIHZhciByZXQgPSBwLmRhdGE7XFxuICBuIC09IHJldC5sZW5ndGg7XFxuICB3aGlsZSAocCA9IHAubmV4dCkge1xcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xcbiAgICBuIC09IG5iO1xcbiAgICBpZiAobiA9PT0gMCkge1xcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xcbiAgICAgICAgKytjO1xcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcXG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XFxuICAgICAgfVxcbiAgICAgIGJyZWFrO1xcbiAgICB9XFxuICAgICsrYztcXG4gIH1cXG4gIGxpc3QubGVuZ3RoIC09IGM7XFxuICByZXR1cm4gcmV0O1xcbn1cXG5cXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXFxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxcbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcXG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XFxuICB2YXIgcCA9IGxpc3QuaGVhZDtcXG4gIHZhciBjID0gMTtcXG4gIHAuZGF0YS5jb3B5KHJldCk7XFxuICBuIC09IHAuZGF0YS5sZW5ndGg7XFxuICB3aGlsZSAocCA9IHAubmV4dCkge1xcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XFxuICAgIG4gLT0gbmI7XFxuICAgIGlmIChuID09PSAwKSB7XFxuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XFxuICAgICAgICArK2M7XFxuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBsaXN0LmhlYWQgPSBwO1xcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcXG4gICAgICB9XFxuICAgICAgYnJlYWs7XFxuICAgIH1cXG4gICAgKytjO1xcbiAgfVxcbiAgbGlzdC5sZW5ndGggLT0gYztcXG4gIHJldHVybiByZXQ7XFxufVxcblxcbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xcblxcbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxcbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXFxcImVuZFJlYWRhYmxlKClcXFwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XFxuXFxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcXG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xcbiAgICBwcm9jZXNzTmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXFxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XFxuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcXG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XFxuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICBmKHhzW2ldLCBpKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcXG4gIH1cXG4gIHJldHVybiAtMTtcXG59XFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi9fc3RyZWFtX2R1cGxleFxcXCI6NTgsXFxcIi4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0XFxcIjo2MyxcXFwiLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3lcXFwiOjY0LFxcXCIuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtXFxcIjo2NSxcXFwiX3Byb2Nlc3NcXFwiOjU2LFxcXCJjb3JlLXV0aWwtaXNcXFwiOjQyLFxcXCJldmVudHNcXFwiOjQ3LFxcXCJpbmhlcml0c1xcXCI6NTAsXFxcImlzYXJyYXlcXFwiOjUyLFxcXCJwcm9jZXNzLW5leHRpY2stYXJnc1xcXCI6NTUsXFxcInNhZmUtYnVmZmVyXFxcIjo3MCxcXFwic3RyaW5nX2RlY29kZXIvXFxcIjo3MixcXFwidXRpbFxcXCI6Mzh9XSw2MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xcbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXFxcImZpbHRlclxcXCIsXFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxcbi8vXFxuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxcbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cXG4vL1xcbi8vIEhlcmUncyBob3cgdGhpcyB3b3JrczpcXG4vL1xcbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXFxuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cXG4vL1xcbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXFxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xcbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cXG4vL1xcbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcXG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXFxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxcbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cXG4vL1xcbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXFxuXFxuJ3VzZSBzdHJpY3QnO1xcblxcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xcblxcbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xcblxcbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKHN0cmVhbSkge1xcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlciwgZGF0YSkge1xcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XFxuICB9O1xcblxcbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XFxuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcXG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XFxuICB0aGlzLndyaXRlZW5jb2RpbmcgPSBudWxsO1xcbn1cXG5cXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XFxuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XFxuXFxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xcblxcbiAgaWYgKCFjYikge1xcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XFxuICB9XFxuXFxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcXG4gIHRzLndyaXRlY2IgPSBudWxsO1xcblxcbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcXG5cXG4gIGNiKGVyKTtcXG5cXG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcXG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcXG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xcbiAgICBzdHJlYW0uX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XFxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XFxuXFxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcXG5cXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKHRoaXMpO1xcblxcbiAgdmFyIHN0cmVhbSA9IHRoaXM7XFxuXFxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcXG5cXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XFxuXFxuICBpZiAob3B0aW9ucykge1xcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcXG5cXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XFxuICB9XFxuXFxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXFxuICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XFxuICAgICAgZG9uZShzdHJlYW0sIGVyLCBkYXRhKTtcXG4gICAgfSk7ZWxzZSBkb25lKHN0cmVhbSk7XFxuICB9KTtcXG59XFxuXFxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XFxufTtcXG5cXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXFxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cXG4vL1xcbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXFxuLy9cXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xcbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3VcXG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxcblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcXG59O1xcblxcblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xcbiAgdHMud3JpdGVjYiA9IGNiO1xcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcXG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XFxuICB9XFxufTtcXG5cXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxcbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXFxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcXG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xcblxcbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XFxuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XFxuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XFxuICB9IGVsc2Uge1xcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXFxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxcbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcXG4gIH1cXG59O1xcblxcblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xcbiAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XFxuICAgIGNiKGVycjIpO1xcbiAgICBfdGhpcy5lbWl0KCdjbG9zZScpO1xcbiAgfSk7XFxufTtcXG5cXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcXG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcXG5cXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7XFxuXFxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXFxuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcXG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XFxuXFxuICBpZiAod3MubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xcblxcbiAgaWYgKHRzLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XFxuXFxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XFxufVxcbn0se1xcXCIuL19zdHJlYW1fZHVwbGV4XFxcIjo1OCxcXFwiY29yZS11dGlsLWlzXFxcIjo0MixcXFwiaW5oZXJpdHNcXFwiOjUwfV0sNjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxcbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxcblxcbid1c2Ugc3RyaWN0JztcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcblxcbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XFxuXFxuLyogPHJlcGxhY2VtZW50PiAqL1xcbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcXG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcXG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcXG4gIHRoaXMubmV4dCA9IG51bGw7XFxufVxcblxcbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxcbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcXG4gIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICB0aGlzLm5leHQgPSBudWxsO1xcbiAgdGhpcy5lbnRyeSA9IG51bGw7XFxuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcXG4gIH07XFxufVxcbi8qIDwvcmVwbGFjZW1lbnQ+ICovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcHJvY2Vzc05leHRUaWNrO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIER1cGxleDtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XFxudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgaW50ZXJuYWxVdGlsID0ge1xcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXFxufTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XFxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XFxuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xcbn1cXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XFxufVxcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XFxuXFxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcXG5cXG5mdW5jdGlvbiBub3AoKSB7fVxcblxcbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XFxuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xcblxcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xcblxcbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XFxuXFxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXFxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcXG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XFxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcXG5cXG4gIC8vIGNhc3QgdG8gaW50cy5cXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcXG5cXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTtcXG5cXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXFxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XFxuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XFxuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcXG5cXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcXG5cXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xcbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXFxuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxcbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcXG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcXG5cXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xcblxcbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcXG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcXG4gIC8vIHNvY2tldCBvciBmaWxlLlxcbiAgdGhpcy5sZW5ndGggPSAwO1xcblxcbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xcblxcbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxcbiAgdGhpcy5jb3JrZWQgPSAwO1xcblxcbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXFxcImxhdGVyXFxcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxcbiAgdGhpcy5zeW5jID0gdHJ1ZTtcXG5cXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xcblxcbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XFxuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XFxuICB9O1xcblxcbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXFxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xcblxcbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxcbiAgdGhpcy53cml0ZWxlbiA9IDA7XFxuXFxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XFxuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xcblxcbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xcblxcbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcXG5cXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXFxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xcblxcbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xcblxcbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xcbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcXG59XFxuXFxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcXG4gIHZhciBvdXQgPSBbXTtcXG4gIHdoaWxlIChjdXJyZW50KSB7XFxuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xcbiAgfVxcbiAgcmV0dXJuIG91dDtcXG59O1xcblxcbihmdW5jdGlvbiAoKSB7XFxuICB0cnkge1xcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XFxuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxcbiAgICB9KTtcXG4gIH0gY2F0Y2ggKF8pIHt9XFxufSkoKTtcXG5cXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXFxudmFyIHJlYWxIYXNJbnN0YW5jZTtcXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XFxuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XFxuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XFxuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xcblxcbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcXG4gICAgfVxcbiAgfSk7XFxufSBlbHNlIHtcXG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcXG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XFxuICB9O1xcbn1cXG5cXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XFxuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xcblxcbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXFxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cXG5cXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXFxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXFxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XFxuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XFxuICB9XFxuXFxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XFxuXFxuICAvLyBsZWdhY3kuXFxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcXG5cXG4gIGlmIChvcHRpb25zKSB7XFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xcblxcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcXG5cXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XFxuXFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xcbiAgfVxcblxcbiAgU3RyZWFtLmNhbGwodGhpcyk7XFxufVxcblxcbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XFxufTtcXG5cXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcXG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XFxuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xcbiAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XFxufVxcblxcbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxcbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XFxuICB2YXIgdmFsaWQgPSB0cnVlO1xcbiAgdmFyIGVyID0gZmFsc2U7XFxuXFxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcXG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcXG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XFxuICB9XFxuICBpZiAoZXIpIHtcXG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xcbiAgICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcXG4gICAgdmFsaWQgPSBmYWxzZTtcXG4gIH1cXG4gIHJldHVybiB2YWxpZDtcXG59XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XFxuICB2YXIgcmV0ID0gZmFsc2U7XFxuICB2YXIgaXNCdWYgPSBfaXNVaW50OEFycmF5KGNodW5rKSAmJiAhc3RhdGUub2JqZWN0TW9kZTtcXG5cXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xcbiAgfVxcblxcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBjYiA9IGVuY29kaW5nO1xcbiAgICBlbmNvZGluZyA9IG51bGw7XFxuICB9XFxuXFxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcXG5cXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xcblxcbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XFxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XFxuICB9XFxuXFxuICByZXR1cm4gcmV0O1xcbn07XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xcblxcbiAgc3RhdGUuY29ya2VkKys7XFxufTtcXG5cXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcXG5cXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcXG4gICAgc3RhdGUuY29ya2VkLS07XFxuXFxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcXG4gIH1cXG59O1xcblxcbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcXG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcXG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XFxuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XFxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XFxuICB9XFxuICByZXR1cm4gY2h1bms7XFxufVxcblxcbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXFxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICBpZiAoIWlzQnVmKSB7XFxuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XFxuICAgICAgaXNCdWYgPSB0cnVlO1xcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XFxuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcXG4gICAgfVxcbiAgfVxcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xcblxcbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcXG5cXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXFxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcXG5cXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XFxuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XFxuICAgICAgY2h1bms6IGNodW5rLFxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcXG4gICAgICBpc0J1ZjogaXNCdWYsXFxuICAgICAgY2FsbGJhY2s6IGNiLFxcbiAgICAgIG5leHQ6IG51bGxcXG4gICAgfTtcXG4gICAgaWYgKGxhc3QpIHtcXG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XFxuICAgIH1cXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcXG4gIH0gZWxzZSB7XFxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XFxuICB9XFxuXFxuICByZXR1cm4gcmV0O1xcbn1cXG5cXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcXG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcXG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xcbiAgc3RhdGUuc3luYyA9IHRydWU7XFxuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XFxuICBzdGF0ZS5zeW5jID0gZmFsc2U7XFxufVxcblxcbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcXG4gIC0tc3RhdGUucGVuZGluZ2NiO1xcblxcbiAgaWYgKHN5bmMpIHtcXG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xcbiAgICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcXG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cXG4gICAgLy8gYWZ0ZXIgZXJyb3JcXG4gICAgcHJvY2Vzc05leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcXG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XFxuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxcbiAgICAvLyBpdCBpcyBhc3luY1xcbiAgICBjYihlcik7XFxuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XFxuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcXG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XFxuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XFxuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcXG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcXG4gIHN0YXRlLndyaXRlbGVuID0gMDtcXG59XFxuXFxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XFxuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XFxuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XFxuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xcblxcbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcXG5cXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XFxuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xcblxcbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XFxuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHN5bmMpIHtcXG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xcbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcXG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cXG4gICAgfSBlbHNlIHtcXG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcXG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcXG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xcbiAgY2IoKTtcXG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xcbn1cXG5cXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxcbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcXG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XFxuICB9XFxufVxcblxcbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XFxuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XFxuXFxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXFxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XFxuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XFxuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XFxuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xcblxcbiAgICB2YXIgY291bnQgPSAwO1xcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XFxuICAgIHdoaWxlIChlbnRyeSkge1xcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcXG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XFxuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xcbiAgICAgIGNvdW50ICs9IDE7XFxuICAgIH1cXG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xcblxcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XFxuXFxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXFxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcXG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XFxuICAgIGlmIChob2xkZXIubmV4dCkge1xcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcXG4gICAgd2hpbGUgKGVudHJ5KSB7XFxuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XFxuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XFxuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XFxuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xcblxcbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XFxuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXFxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XFxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXFxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xcbiAgfVxcblxcbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xcbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XFxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XFxufVxcblxcbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XFxufTtcXG5cXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xcblxcbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBjYiA9IGNodW5rO1xcbiAgICBjaHVuayA9IG51bGw7XFxuICAgIGVuY29kaW5nID0gbnVsbDtcXG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGNiID0gZW5jb2Rpbmc7XFxuICAgIGVuY29kaW5nID0gbnVsbDtcXG4gIH1cXG5cXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XFxuXFxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xcbiAgICB0aGlzLnVuY29yaygpO1xcbiAgfVxcblxcbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxcbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xcbn07XFxuXFxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcXG59XFxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcXG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcXG4gICAgaWYgKGVycikge1xcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XFxuICAgIH1cXG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XFxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xcbiAgfSk7XFxufVxcbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XFxuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcXG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XFxuICAgICAgcHJvY2Vzc05leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XFxuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xcbiAgaWYgKG5lZWQpIHtcXG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XFxuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG5lZWQ7XFxufVxcblxcbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XFxuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XFxuICBpZiAoY2IpIHtcXG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzTmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcXG4gIH1cXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcXG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xcbn1cXG5cXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XFxuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XFxuICB3aGlsZSAoZW50cnkpIHtcXG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XFxuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xcbiAgICBjYihlcnIpO1xcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XFxuICB9XFxuICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XFxuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcXG4gIH0gZWxzZSB7XFxuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGNvcmtSZXE7XFxuICB9XFxufVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XFxuICB9LFxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXFxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcXG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcXG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XFxuICB9XFxufSk7XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xcbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XFxuICB0aGlzLmVuZCgpO1xcbiAgY2IoZXJyKTtcXG59O1xcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4vX3N0cmVhbV9kdXBsZXhcXFwiOjU4LFxcXCIuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveVxcXCI6NjQsXFxcIi4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW1cXFwiOjY1LFxcXCJfcHJvY2Vzc1xcXCI6NTYsXFxcImNvcmUtdXRpbC1pc1xcXCI6NDIsXFxcImluaGVyaXRzXFxcIjo1MCxcXFwicHJvY2Vzcy1uZXh0aWNrLWFyZ3NcXFwiOjU1LFxcXCJzYWZlLWJ1ZmZlclxcXCI6NzAsXFxcInV0aWwtZGVwcmVjYXRlXFxcIjo3M31dLDYzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XFxuICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xcblxcbiAgICB0aGlzLmhlYWQgPSBudWxsO1xcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xcbiAgICB0aGlzLmxlbmd0aCA9IDA7XFxuICB9XFxuXFxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7XFxuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XFxuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xcbiAgICArK3RoaXMubGVuZ3RoO1xcbiAgfTtcXG5cXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcXG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcXG4gICAgdGhpcy5oZWFkID0gZW50cnk7XFxuICAgICsrdGhpcy5sZW5ndGg7XFxuICB9O1xcblxcbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XFxuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XFxuICAgIC0tdGhpcy5sZW5ndGg7XFxuICAgIHJldHVybiByZXQ7XFxuICB9O1xcblxcbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcXG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcXG4gICAgdGhpcy5sZW5ndGggPSAwO1xcbiAgfTtcXG5cXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHtcXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XFxuICAgIHZhciBwID0gdGhpcy5oZWFkO1xcbiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XFxuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XFxuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XFxuICAgIH1yZXR1cm4gcmV0O1xcbiAgfTtcXG5cXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7XFxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XFxuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XFxuICAgIHZhciBwID0gdGhpcy5oZWFkO1xcbiAgICB2YXIgaSA9IDA7XFxuICAgIHdoaWxlIChwKSB7XFxuICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XFxuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xcbiAgICAgIHAgPSBwLm5leHQ7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJldDtcXG4gIH07XFxuXFxuICByZXR1cm4gQnVmZmVyTGlzdDtcXG59KCk7XFxufSx7XFxcInNhZmUtYnVmZmVyXFxcIjo3MH1dLDY0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG5cXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXFxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XFxuICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcXG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XFxuXFxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcXG4gICAgaWYgKGNiKSB7XFxuICAgICAgY2IoZXJyKTtcXG4gICAgfSBlbHNlIGlmIChlcnIgJiYgKCF0aGlzLl93cml0YWJsZVN0YXRlIHx8ICF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHtcXG4gICAgICBwcm9jZXNzTmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XFxuICAgIH1cXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXFxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcXG5cXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcXG4gIH1cXG5cXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcXG4gIH1cXG5cXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcXG4gICAgICBwcm9jZXNzTmV4dFRpY2soZW1pdEVycm9yTlQsIF90aGlzLCBlcnIpO1xcbiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoY2IpIHtcXG4gICAgICBjYihlcnIpO1xcbiAgICB9XFxuICB9KTtcXG59XFxuXFxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XFxuICB9XFxuXFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XFxuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICBkZXN0cm95OiBkZXN0cm95LFxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3lcXG59O1xcbn0se1xcXCJwcm9jZXNzLW5leHRpY2stYXJnc1xcXCI6NTV9XSw2NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XFxuXFxufSx7XFxcImV2ZW50c1xcXCI6NDd9XSw2NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuUGFzc1Rocm91Z2hcXG5cXG59LHtcXFwiLi9yZWFkYWJsZVxcXCI6Njd9XSw2NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcXG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcXG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcXG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XFxuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcXG5cXG59LHtcXFwiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcXFwiOjU4LFxcXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXFxcIjo1OSxcXFwiLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qc1xcXCI6NjAsXFxcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXFxcIjo2MSxcXFwiLi9saWIvX3N0cmVhbV93cml0YWJsZS5qc1xcXCI6NjJ9XSw2ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuVHJhbnNmb3JtXFxuXFxufSx7XFxcIi4vcmVhZGFibGVcXFwiOjY3fV0sNjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xcblxcbn0se1xcXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXFxcIjo2Mn1dLDcwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXFxudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXFxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcXG5cXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXFxuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXFxuICB9XFxufVxcbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcXG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXFxufSBlbHNlIHtcXG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXFxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXFxufVxcblxcbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXFxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcXG5cXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXFxuICB9XFxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XFxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxcbiAgfVxcbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIGJ1Zi5maWxsKDApXFxuICB9XFxuICByZXR1cm4gYnVmXFxufVxcblxcblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcXG4gIH1cXG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcXG59XFxuXFxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcXG4gIH1cXG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxcbn1cXG5cXG59LHtcXFwiYnVmZmVyXFxcIjo0MX1dLDcxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcbi8vIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXFxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXFxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcXG5cXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcXG5cXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcXG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcXG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcXG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XFxuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XFxuXFxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcXG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xcblxcblxcblxcbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcXG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxcblxcbmZ1bmN0aW9uIFN0cmVhbSgpIHtcXG4gIEVFLmNhbGwodGhpcyk7XFxufVxcblxcblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcXG4gIHZhciBzb3VyY2UgPSB0aGlzO1xcblxcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XFxuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XFxuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcXG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcXG5cXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XFxuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcXG5cXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxcbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XFxuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XFxuICB9XFxuXFxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcXG4gICAgZGlkT25FbmQgPSB0cnVlO1xcblxcbiAgICBkZXN0LmVuZCgpO1xcbiAgfVxcblxcblxcbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcXG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XFxuICAgIGRpZE9uRW5kID0gdHJ1ZTtcXG5cXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xcbiAgfVxcblxcbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxcbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xcbiAgICBjbGVhbnVwKCk7XFxuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XFxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cXG4gICAgfVxcbiAgfVxcblxcbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcXG5cXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXFxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xcblxcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xcblxcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XFxuXFxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XFxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcXG5cXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcXG4gIH1cXG5cXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XFxuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XFxuXFxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xcblxcbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcXG5cXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXFxuICByZXR1cm4gZGVzdDtcXG59O1xcblxcbn0se1xcXCJldmVudHNcXFwiOjQ3LFxcXCJpbmhlcml0c1xcXCI6NTAsXFxcInJlYWRhYmxlLXN0cmVhbS9kdXBsZXguanNcXFwiOjU3LFxcXCJyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanNcXFwiOjY2LFxcXCJyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanNcXFwiOjY3LFxcXCJyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzXFxcIjo2OCxcXFwicmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzXFxcIjo2OX1dLDcyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xcblxcbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XFxuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XFxuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcXG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIGRlZmF1bHQ6XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcbn07XFxuXFxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XFxuICB2YXIgcmV0cmllZDtcXG4gIHdoaWxlICh0cnVlKSB7XFxuICAgIHN3aXRjaCAoZW5jKSB7XFxuICAgICAgY2FzZSAndXRmOCc6XFxuICAgICAgY2FzZSAndXRmLTgnOlxcbiAgICAgICAgcmV0dXJuICd1dGY4JztcXG4gICAgICBjYXNlICd1Y3MyJzpcXG4gICAgICBjYXNlICd1Y3MtMic6XFxuICAgICAgY2FzZSAndXRmMTZsZSc6XFxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcXG4gICAgICBjYXNlICdsYXRpbjEnOlxcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XFxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XFxuICAgICAgY2FzZSAnYmFzZTY0JzpcXG4gICAgICBjYXNlICdhc2NpaSc6XFxuICAgICAgY2FzZSAnaGV4JzpcXG4gICAgICAgIHJldHVybiBlbmM7XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XFxuICAgIH1cXG4gIH1cXG59O1xcblxcbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcXG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XFxuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcXG4gIHJldHVybiBuZW5jIHx8IGVuYztcXG59XFxuXFxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxcbi8vIGNoYXJhY3RlcnMuXFxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcXG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XFxuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xcbiAgdmFyIG5iO1xcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XFxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcXG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xcbiAgICAgIG5iID0gNDtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAndXRmOCc6XFxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcXG4gICAgICBuYiA9IDQ7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ2Jhc2U2NCc6XFxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcXG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcXG4gICAgICBuYiA9IDM7XFxuICAgICAgYnJlYWs7XFxuICAgIGRlZmF1bHQ6XFxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xcbiAgICAgIHJldHVybjtcXG4gIH1cXG4gIHRoaXMubGFzdE5lZWQgPSAwO1xcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XFxufVxcblxcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcXG4gIHZhciByO1xcbiAgdmFyIGk7XFxuICBpZiAodGhpcy5sYXN0TmVlZCkge1xcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XFxuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcXG4gIH0gZWxzZSB7XFxuICAgIGkgPSAwO1xcbiAgfVxcbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xcbiAgcmV0dXJuIHIgfHwgJyc7XFxufTtcXG5cXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xcblxcbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXFxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xcblxcbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcXG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcXG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcXG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xcbiAgfVxcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcXG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcXG59O1xcblxcbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcXG4vLyBjb250aW51YXRpb24gYnl0ZS5cXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcXG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xcbiAgcmV0dXJuIC0xO1xcbn1cXG5cXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXFxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxcbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XFxuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcXG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcXG4gIGlmIChuYiA+PSAwKSB7XFxuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XFxuICAgIHJldHVybiBuYjtcXG4gIH1cXG4gIGlmICgtLWogPCBpKSByZXR1cm4gMDtcXG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xcbiAgaWYgKG5iID49IDApIHtcXG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcXG4gICAgcmV0dXJuIG5iO1xcbiAgfVxcbiAgaWYgKC0taiA8IGkpIHJldHVybiAwO1xcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XFxuICBpZiAobmIgPj0gMCkge1xcbiAgICBpZiAobmIgPiAwKSB7XFxuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xcbiAgICB9XFxuICAgIHJldHVybiBuYjtcXG4gIH1cXG4gIHJldHVybiAwO1xcbn1cXG5cXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxcbi8vIG9uZSwgd2UgXFxcInJlcGxhY2VcXFwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcXG4vLyBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzICgnXFxcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2RpbmdcXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXFxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXFxuLy8gbG9vcC5cXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcXG4gICAgcmV0dXJuICdcXFxcdWZmZmQnLnJlcGVhdChwKTtcXG4gIH1cXG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XFxuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XFxuICAgICAgcmV0dXJuICdcXFxcdWZmZmQnLnJlcGVhdChwICsgMSk7XFxuICAgIH1cXG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XFxuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XFxuICAgICAgICByZXR1cm4gJ1xcXFx1ZmZmZCcucmVwZWF0KHAgKyAyKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxcbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcXG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XFxuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcXG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcXG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XFxuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcXG4gIH1cXG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xcbn1cXG5cXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcXG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcXG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcXG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XFxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XFxufVxcblxcbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgZm9yIGVhY2ggYnVmZmVyZWQgYnl0ZSBvZiBhIChwYXJ0aWFsKVxcbi8vIGNoYXJhY3RlciBuZWVkcyB0byBiZSBhZGRlZCB0byB0aGUgb3V0cHV0LlxcbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XFxuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XFxuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFxcXHVmZmZkJy5yZXBlYXQodGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcXG4gIHJldHVybiByO1xcbn1cXG5cXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxcbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXFxuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XFxuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcXG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcXG4gICAgaWYgKHIpIHtcXG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XFxuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XFxuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcXG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gcjtcXG4gIH1cXG4gIHRoaXMubGFzdE5lZWQgPSAxO1xcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XFxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xcbn1cXG5cXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxcbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcXG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcXG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcXG4gIH1cXG4gIHJldHVybiByO1xcbn1cXG5cXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcXG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcXG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcXG4gIHRoaXMubGFzdFRvdGFsID0gMztcXG4gIGlmIChuID09PSAxKSB7XFxuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xcbiAgfSBlbHNlIHtcXG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XFxuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xcbiAgfVxcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xcbn1cXG5cXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XFxuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XFxuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XFxuICByZXR1cm4gcjtcXG59XFxuXFxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcXG59XFxuXFxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XFxufVxcbn0se1xcXCJzYWZlLWJ1ZmZlclxcXCI6NzB9XSw3MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChnbG9iYWwpe1xcblxcbi8qKlxcbiAqIE1vZHVsZSBleHBvcnRzLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xcblxcbi8qKlxcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXFxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cXG4gKlxcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxcbiAqXFxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXFxuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXFxuICpcXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxcbiAqXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXFxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFxcXCJkZXByZWNhdGVkXFxcIiB2ZXJzaW9uIG9mIGBmbmBcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XFxuICAgIHJldHVybiBmbjtcXG4gIH1cXG5cXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XFxuICAgIGlmICghd2FybmVkKSB7XFxuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcXG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XFxuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xcbiAgICAgIH1cXG4gICAgICB3YXJuZWQgPSB0cnVlO1xcbiAgICB9XFxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxcbiAqIEByZXR1cm5zIHtCb29sZWFufVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcXG4gIHRyeSB7XFxuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xcbiAgfSBjYXRjaCAoXykge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcXG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcXG59XFxuXFxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7fV0sNzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbmFyZ3VtZW50c1s0XVs1MF1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpXFxufSx7XFxcImR1cFxcXCI6NTB9XSw3NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcXG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXFxuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcXG59XFxufSx7fV0sNzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xcbiAgICB9XFxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcXG4gIH1cXG5cXG4gIHZhciBpID0gMTtcXG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcXG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcXG4gICAgc3dpdGNoICh4KSB7XFxuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XFxuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XFxuICAgICAgY2FzZSAnJWonOlxcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XFxuICAgICAgICB9IGNhdGNoIChfKSB7XFxuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XFxuICAgICAgICB9XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIHJldHVybiB4O1xcbiAgICB9XFxuICB9KTtcXG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XFxuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XFxuICAgICAgc3RyICs9ICcgJyArIHg7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBzdHI7XFxufTtcXG5cXG5cXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxcbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXFxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXFxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcXG4gICAgcmV0dXJuIGZuO1xcbiAgfVxcblxcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcXG4gICAgaWYgKCF3YXJuZWQpIHtcXG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcXG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XFxuICAgICAgfVxcbiAgICAgIHdhcm5lZCA9IHRydWU7XFxuICAgIH1cXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICB9XFxuXFxuICByZXR1cm4gZGVwcmVjYXRlZDtcXG59O1xcblxcblxcbnZhciBkZWJ1Z3MgPSB7fTtcXG52YXIgZGVidWdFbnZpcm9uO1xcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcXG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XFxuICBpZiAoIWRlYnVnc1tzZXRdKSB7XFxuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcXFxcXGInICsgc2V0ICsgJ1xcXFxcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XFxuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xcbiAgICAgIH07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gZGVidWdzW3NldF07XFxufTtcXG5cXG5cXG4vKipcXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXFxuICpcXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXFxuICovXFxuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xcbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XFxuICAvLyBkZWZhdWx0IG9wdGlvbnNcXG4gIHZhciBjdHggPSB7XFxuICAgIHNlZW46IFtdLFxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxcbiAgfTtcXG4gIC8vIGxlZ2FjeS4uLlxcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcXG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcXG4gICAgLy8gbGVnYWN5Li4uXFxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcXG4gIH0gZWxzZSBpZiAob3B0cykge1xcbiAgICAvLyBnb3QgYW4gXFxcIm9wdGlvbnNcXFwiIG9iamVjdFxcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcXG4gIH1cXG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XFxuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcXG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcXG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcXG59XFxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcXG5cXG5cXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3NcXG5pbnNwZWN0LmNvbG9ycyA9IHtcXG4gICdib2xkJyA6IFsxLCAyMl0sXFxuICAnaXRhbGljJyA6IFszLCAyM10sXFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXFxuICAnYmxhY2snIDogWzMwLCAzOV0sXFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcXG4gICdjeWFuJyA6IFszNiwgMzldLFxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXFxuICAncmVkJyA6IFszMSwgMzldLFxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxcbn07XFxuXFxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXFxuaW5zcGVjdC5zdHlsZXMgPSB7XFxuICAnc3BlY2lhbCc6ICdjeWFuJyxcXG4gICdudW1iZXInOiAneWVsbG93JyxcXG4gICdib29sZWFuJzogJ3llbGxvdycsXFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxcbiAgJ251bGwnOiAnYm9sZCcsXFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcXG4gICdkYXRlJzogJ21hZ2VudGEnLFxcbiAgLy8gXFxcIm5hbWVcXFwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXFxuICAncmVnZXhwJzogJ3JlZCdcXG59O1xcblxcblxcbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcXG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XFxuXFxuICBpZiAoc3R5bGUpIHtcXG4gICAgcmV0dXJuICdcXFxcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXFxuICAgICAgICAgICAnXFxcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gc3RyO1xcbiAgfVxcbn1cXG5cXG5cXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xcbiAgcmV0dXJuIHN0cjtcXG59XFxuXFxuXFxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcXG4gIHZhciBoYXNoID0ge307XFxuXFxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XFxuICAgIGhhc2hbdmFsXSA9IHRydWU7XFxuICB9KTtcXG5cXG4gIHJldHVybiBoYXNoO1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcXG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXFxuICAgICAgdmFsdWUgJiZcXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXFxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXFxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXFxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XFxuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXQ7XFxuICB9XFxuXFxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcXG4gIGlmIChwcmltaXRpdmUpIHtcXG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcXG4gIH1cXG5cXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XFxuXFxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcXG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcXG4gIH1cXG5cXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcXG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcXG4gIH1cXG5cXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcXG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XFxuICAgIH1cXG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XFxuICAgIH1cXG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcXG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XFxuICAgIH1cXG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XFxuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcXG5cXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcXG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xcbiAgICBhcnJheSA9IHRydWU7XFxuICAgIGJyYWNlcyA9IFsnWycsICddJ107XFxuICB9XFxuXFxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcXG4gIH1cXG5cXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXFxuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XFxuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xcbiAgfVxcblxcbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXFxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XFxuICB9XFxuXFxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXFxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcXG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcXG4gIH1cXG5cXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcXG4gIH1cXG5cXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XFxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcXG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xcbiAgICB9XFxuICB9XFxuXFxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcXG5cXG4gIHZhciBvdXRwdXQ7XFxuICBpZiAoYXJyYXkpIHtcXG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XFxuICB9IGVsc2Uge1xcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcXG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgY3R4LnNlZW4ucG9wKCk7XFxuXFxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XFxuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XFxuICAgIHZhciBzaW1wbGUgPSAnXFxcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cXFwifFxcXCIkL2csICcnKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFxcXCJcXFxcXFxcXCdcXFwiKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXFxcXFxcXCIvZywgJ1xcXCInKSArICdcXFxcJyc7XFxuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcXG4gIH1cXG4gIGlmIChpc051bWJlcih2YWx1ZSkpXFxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XFxuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XFxuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXFxcIm9iamVjdFxcXCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxcbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXFxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XFxufVxcblxcblxcbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XFxuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XFxuICB2YXIgb3V0cHV0ID0gW107XFxuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcXG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBvdXRwdXQucHVzaCgnJyk7XFxuICAgIH1cXG4gIH1cXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcXG4gICAgaWYgKCFrZXkubWF0Y2goL15cXFxcZCskLykpIHtcXG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxcbiAgICAgICAgICBrZXksIHRydWUpKTtcXG4gICAgfVxcbiAgfSk7XFxuICByZXR1cm4gb3V0cHV0O1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XFxuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xcbiAgaWYgKGRlc2MuZ2V0KSB7XFxuICAgIGlmIChkZXNjLnNldCkge1xcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIGlmIChkZXNjLnNldCkge1xcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XFxuICAgIH1cXG4gIH1cXG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcXG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcXG4gIH1cXG4gIGlmICghc3RyKSB7XFxuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcXG4gICAgICB9XFxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXFxcbicpID4gLTEpIHtcXG4gICAgICAgIGlmIChhcnJheSkge1xcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcXG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XFxuICAgICAgICAgIH0pLmpvaW4oJ1xcXFxuJykuc3Vic3RyKDIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc3RyID0gJ1xcXFxuJyArIHN0ci5zcGxpdCgnXFxcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XFxuICAgICAgICAgIH0pLmpvaW4oJ1xcXFxuJyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcXG4gICAgfVxcbiAgfVxcbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XFxuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXFxcZCskLykpIHtcXG4gICAgICByZXR1cm4gc3RyO1xcbiAgICB9XFxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XFxuICAgIGlmIChuYW1lLm1hdGNoKC9eXFxcIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVxcXCIkLykpIHtcXG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcXG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFxcXCJcXFxcXFxcXCdcXFwiKVxcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcXFxcXFxcIi9nLCAnXFxcIicpXFxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cXFwifFxcXCIkKS9nLCBcXFwiJ1xcXCIpO1xcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcXG59XFxuXFxuXFxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcXG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XFxuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcXG4gICAgbnVtTGluZXNFc3QrKztcXG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXFxcbicpID49IDApIG51bUxpbmVzRXN0Kys7XFxuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcXFx1MDAxYlxcXFxbXFxcXGRcXFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xcbiAgfSwgMCk7XFxuXFxuICBpZiAobGVuZ3RoID4gNjApIHtcXG4gICAgcmV0dXJuIGJyYWNlc1swXSArXFxuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxcXG4gJykgK1xcbiAgICAgICAgICAgJyAnICtcXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxcXG4gICcpICtcXG4gICAgICAgICAgICcgJyArXFxuICAgICAgICAgICBicmFjZXNbMV07XFxuICB9XFxuXFxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xcbn1cXG5cXG5cXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XFxuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XFxufVxcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XFxuXFxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcXG59XFxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XFxuXFxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcXG59XFxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XFxuXFxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XFxuICByZXR1cm4gYXJnID09IG51bGw7XFxufVxcbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcXG5cXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcXG59XFxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xcblxcbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xcbn1cXG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XFxuXFxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XFxufVxcbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcXG5cXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcXG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcXG59XFxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xcblxcbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XFxuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XFxufVxcbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcXG5cXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XFxufVxcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcXG5cXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XFxufVxcbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xcblxcbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXFxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XFxufVxcbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XFxuXFxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xcbn1cXG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xcblxcbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xcbn1cXG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XFxuXFxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xcblxcbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XFxufVxcblxcblxcbmZ1bmN0aW9uIHBhZChuKSB7XFxuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcXG59XFxuXFxuXFxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XFxuXFxuLy8gMjYgRmViIDE2OjE5OjM0XFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcXG59XFxuXFxuXFxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XFxuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcXG59O1xcblxcblxcbi8qKlxcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cXG4gKlxcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxcbiAqXFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxcbiAqICAgICBwcm90b3R5cGUuXFxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXFxuICovXFxuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuXFxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcXG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcXG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xcblxcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcXG4gIHdoaWxlIChpLS0pIHtcXG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xcbiAgfVxcbiAgcmV0dXJuIG9yaWdpbjtcXG59O1xcblxcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se1xcXCIuL3N1cHBvcnQvaXNCdWZmZXJcXFwiOjc1LFxcXCJfcHJvY2Vzc1xcXCI6NTYsXFxcImluaGVyaXRzXFxcIjo3NH1dfSx7fSxbMV0pO1xcblwiIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3JjKSB7XG5cdGZ1bmN0aW9uIGxvZyhlcnJvcikge1xuXHRcdCh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIilcblx0XHQmJiAoY29uc29sZS5lcnJvciB8fCBjb25zb2xlLmxvZykoXCJbU2NyaXB0IExvYWRlcl1cIiwgZXJyb3IpO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIElFID08IDhcblx0ZnVuY3Rpb24gaXNJRSgpIHtcblx0XHRyZXR1cm4gdHlwZW9mIGF0dGFjaEV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSBcInVuZGVmaW5lZFwiO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIGV4ZWNTY3JpcHQgIT09IFwidW5kZWZpbmVkXCIgJiYgaXNJRSgpKSB7XG5cdFx0XHRleGVjU2NyaXB0KHNyYyk7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgZXZhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0ZXZhbC5jYWxsKG51bGwsIHNyYyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxvZyhcIkV2YWxFcnJvcjogTm8gZXZhbCBmdW5jdGlvbiBhdmFpbGFibGVcIik7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGxvZyhlcnJvcik7XG5cdH1cbn1cbiIsInJlcXVpcmUoXCIhIS9Vc2Vycy9hcnJhbS90dXJpbmcvcHJvamVjdHMvZ2FtZS10aW1lL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvVXNlcnMvYXJyYW0vdHVyaW5nL3Byb2plY3RzL2dhbWUtdGltZS9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvYXJyYW0vdHVyaW5nL3Byb2plY3RzL2dhbWUtdGltZS9ub2RlX21vZHVsZXMvbW9jaGEvbW9jaGEuanNcIikpIl0sInNvdXJjZVJvb3QiOiIifQ==